{"Chart_1":[{"entropy_rank":1,"patch_id":1,"patch_code":"if (dataset == null) {\r\n            return result;\r\n        }"}],"Chart_11":[{"entropy_rank":1,"patch_id":1,"patch_code":"PathIterator iterator2 = p2.getPathIterator(null);PathIterator iterator2 = p1.getPathIterator(null);"}],"Chart_12":[{"entropy_rank":1,"patch_id":23,"patch_code":"\r\n        PiePlot piePlot = new PiePlot(null);\r\n        this.pieChart = new JFreeChart(piePlot);\r\n        this.pieChart.removeLegend();\r\n        this.dataExtractOrder = TableOrder.BY_COLUMN;\r\n        this.pieChart.setBackgroundPaint(null);\r\n        TextTitle seriesTitle = new TextTitle(\"Series Title\",\r\n                new Font(\"SansSerif\", Font.BOLD, 12));\r\n        seriesTitle.setPosition(RectangleEdge.BOTTOM);\r\n        this.pieChart.setTitle(seriesTitle);\r\n        this.aggregatedItemsKey = \"Other\";\r\n        this.aggregatedItemsPaint = Color.lightGray;\r\n        this.sectionPaints = new HashMap();\n\tthis.dataset = dataset;\n"},{"entropy_rank":2,"patch_id":26,"patch_code":"setDataset(dataset);this.dataset = dataset;"},{"entropy_rank":3,"patch_id":22,"patch_code":"\r\n        PiePlot piePlot = new PiePlot(null);\r\n        this.pieChart = new JFreeChart(piePlot);\r\n        this.pieChart.removeLegend();\r\n        this.dataExtractOrder = TableOrder.BY_COLUMN;\r\n        this.pieChart.setBackgroundPaint(null);\r\n        TextTitle seriesTitle = new TextTitle(\"Series Title\",\r\n                new Font(\"SansSerif\", Font.BOLD, 12));\r\n        seriesTitle.setPosition(RectangleEdge.BOTTOM);\r\n        this.pieChart.setTitle(seriesTitle);\r\n        this.aggregatedItemsKey = \"Other\";\r\n        this.aggregatedItemsPaint = Color.lightGray;\n\tthis.dataset = dataset;\n"},{"entropy_rank":4,"patch_id":1,"patch_code":"this.dataset = getDataset();this.dataset = dataset;"},{"entropy_rank":5,"patch_id":28,"patch_code":"this.dataset = dataset;\n\tsetDataset(dataset);this.dataset = dataset;"},{"entropy_rank":6,"patch_id":27,"patch_code":"setDataset(dataset);\n\tthis.dataset = dataset;this.dataset = dataset;"},{"entropy_rank":7,"patch_id":29,"patch_code":"prefetchSectionPaints();\n\tthis.dataset = dataset;this.dataset = dataset;"},{"entropy_rank":8,"patch_id":30,"patch_code":"this.dataset = dataset;\n\tprefetchSectionPaints();this.dataset = dataset;"},{"entropy_rank":9,"patch_id":24,"patch_code":"this.dataset = dataset;"},{"entropy_rank":10,"patch_id":21,"patch_code":"\r\n        PiePlot piePlot = new PiePlot(null);\r\n        this.pieChart = new JFreeChart(piePlot);\r\n        this.pieChart.removeLegend();\r\n        this.dataExtractOrder = TableOrder.BY_COLUMN;\r\n        this.pieChart.setBackgroundPaint(null);\r\n        TextTitle seriesTitle = new TextTitle(\"Series Title\",\r\n                new Font(\"SansSerif\", Font.BOLD, 12));\r\n        seriesTitle.setPosition(RectangleEdge.BOTTOM);\r\n        this.pieChart.setTitle(seriesTitle);\r\n        this.aggregatedItemsKey = \"Other\";\n\tthis.dataset = dataset;\n"},{"entropy_rank":11,"patch_id":15,"patch_code":"\r\n        PiePlot piePlot = new PiePlot(null);\r\n        this.pieChart = new JFreeChart(piePlot);\r\n        this.pieChart.removeLegend();\n\tthis.dataset = dataset;\n"},{"entropy_rank":12,"patch_id":14,"patch_code":"\r\n        PiePlot piePlot = new PiePlot(null);\r\n        this.pieChart = new JFreeChart(piePlot);\n\tthis.dataset = dataset;\n"},{"entropy_rank":13,"patch_id":10,"patch_code":"if (dataset != null) {\n\tthis.dataset = dataset;\n\t}\nthis.dataset = dataset;\n\t}\n"},{"entropy_rank":14,"patch_id":17,"patch_code":"\r\n        PiePlot piePlot = new PiePlot(null);\r\n        this.pieChart = new JFreeChart(piePlot);\r\n        this.pieChart.removeLegend();\r\n        this.dataExtractOrder = TableOrder.BY_COLUMN;\r\n        this.pieChart.setBackgroundPaint(null);\n\tthis.dataset = dataset;\n"},{"entropy_rank":15,"patch_id":19,"patch_code":"\r\n        PiePlot piePlot = new PiePlot(null);\r\n        this.pieChart = new JFreeChart(piePlot);\r\n        this.pieChart.removeLegend();\r\n        this.dataExtractOrder = TableOrder.BY_COLUMN;\r\n        this.pieChart.setBackgroundPaint(null);\r\n        TextTitle seriesTitle = new TextTitle(\"Series Title\",\r\n                new Font(\"SansSerif\", Font.BOLD, 12));\r\n        seriesTitle.setPosition(RectangleEdge.BOTTOM);\n\tthis.dataset = dataset;\n"},{"entropy_rank":16,"patch_id":18,"patch_code":"\r\n        PiePlot piePlot = new PiePlot(null);\r\n        this.pieChart = new JFreeChart(piePlot);\r\n        this.pieChart.removeLegend();\r\n        this.dataExtractOrder = TableOrder.BY_COLUMN;\r\n        this.pieChart.setBackgroundPaint(null);\r\n        TextTitle seriesTitle = new TextTitle(\"Series Title\",\r\n                new Font(\"SansSerif\", Font.BOLD, 12));\n\tthis.dataset = dataset;\n"},{"entropy_rank":17,"patch_id":13,"patch_code":"\r\n        PiePlot piePlot = new PiePlot(null);\n\tthis.dataset = dataset;\n"},{"entropy_rank":18,"patch_id":20,"patch_code":"\r\n        PiePlot piePlot = new PiePlot(null);\r\n        this.pieChart = new JFreeChart(piePlot);\r\n        this.pieChart.removeLegend();\r\n        this.dataExtractOrder = TableOrder.BY_COLUMN;\r\n        this.pieChart.setBackgroundPaint(null);\r\n        TextTitle seriesTitle = new TextTitle(\"Series Title\",\r\n                new Font(\"SansSerif\", Font.BOLD, 12));\r\n        seriesTitle.setPosition(RectangleEdge.BOTTOM);\r\n        this.pieChart.setTitle(seriesTitle);\n\tthis.dataset = dataset;\n"},{"entropy_rank":19,"patch_id":16,"patch_code":"\r\n        PiePlot piePlot = new PiePlot(null);\r\n        this.pieChart = new JFreeChart(piePlot);\r\n        this.pieChart.removeLegend();\r\n        this.dataExtractOrder = TableOrder.BY_COLUMN;\n\tthis.dataset = dataset;\n"}],"Chart_13":[{"entropy_rank":2,"patch_id":29,"patch_code":"if (LengthConstraintType.FIXED == null) {\n\t    throw new IllegalArgumentException(\"Null 'LengthConstraintType.FIXED' argument.\");\n\t}\nRectangleConstraint c4 = new RectangleConstraint(0.0,\r\n                    new Range(0.0, constraint.getWidth() - w[2]),\r\n                    LengthConstraintType.RANGE, h[2], null,\r\n                    LengthConstraintType.FIXED);RectangleConstraint c4 = new RectangleConstraint(0.0,\r\n                    new Range(0.0, constraint.getWidth() - w[2]),\r\n                    LengthConstraintType.RANGE, h[2], null,\r\n                    LengthConstraintType.FIXED);"},{"entropy_rank":3,"patch_id":19,"patch_code":"if (LengthConstraintType.RANGE == null) {\n\t    throw new IllegalArgumentException(\"Null 'LengthConstraintType.RANGE' argument.\");\n\t}\nRectangleConstraint c4 = new RectangleConstraint(0.0,\r\n                    new Range(0.0, constraint.getWidth() - w[2]),\r\n                    LengthConstraintType.RANGE, h[2], null,\r\n                    LengthConstraintType.FIXED);RectangleConstraint c4 = new RectangleConstraint(0.0,\r\n                    new Range(0.0, constraint.getWidth() - w[2]),\r\n                    LengthConstraintType.RANGE, h[2], null,\r\n                    LengthConstraintType.FIXED);"},{"entropy_rank":4,"patch_id":14,"patch_code":"if (w == null) {\n\t    throw new IllegalArgumentException(\"Null 'w' argument.\");\n\t}\nRectangleConstraint c4 = new RectangleConstraint(0.0,\r\n                    new Range(0.0, constraint.getWidth() - w[2]),\r\n                    LengthConstraintType.RANGE, h[2], null,\r\n                    LengthConstraintType.FIXED);RectangleConstraint c4 = new RectangleConstraint(0.0,\r\n                    new Range(0.0, constraint.getWidth() - w[2]),\r\n                    LengthConstraintType.RANGE, h[2], null,\r\n                    LengthConstraintType.FIXED);"},{"entropy_rank":5,"patch_id":8,"patch_code":"if (constraint == null) {\n\t    throw new IllegalArgumentException(\"Null 'constraint' argument.\");\n\t}\nRectangleConstraint c4 = new RectangleConstraint(0.0,\r\n                    new Range(0.0, constraint.getWidth() - w[2]),\r\n                    LengthConstraintType.RANGE, h[2], null,\r\n                    LengthConstraintType.FIXED);RectangleConstraint c4 = new RectangleConstraint(0.0,\r\n                    new Range(0.0, constraint.getWidth() - w[2]),\r\n                    LengthConstraintType.RANGE, h[2], null,\r\n                    LengthConstraintType.FIXED);"},{"entropy_rank":6,"patch_id":24,"patch_code":"if (h == null) {\n\t    throw new IllegalArgumentException(\"Null 'h' argument.\");\n\t}\nRectangleConstraint c4 = new RectangleConstraint(0.0,\r\n                    new Range(0.0, constraint.getWidth() - w[2]),\r\n                    LengthConstraintType.RANGE, h[2], null,\r\n                    LengthConstraintType.FIXED);RectangleConstraint c4 = new RectangleConstraint(0.0,\r\n                    new Range(0.0, constraint.getWidth() - w[2]),\r\n                    LengthConstraintType.RANGE, h[2], null,\r\n                    LengthConstraintType.FIXED);"},{"entropy_rank":7,"patch_id":32,"patch_code":"if (LengthConstraintType.FIXED == null) return new Size2D();\n\t RectangleConstraint c4 = new RectangleConstraint(0.0,\r\n                    new Range(0.0, constraint.getWidth() - w[2]),\r\n                    LengthConstraintType.RANGE, h[2], null,\r\n                    LengthConstraintType.FIXED);RectangleConstraint c4 = new RectangleConstraint(0.0,\r\n                    new Range(0.0, constraint.getWidth() - w[2]),\r\n                    LengthConstraintType.RANGE, h[2], null,\r\n                    LengthConstraintType.FIXED);"},{"entropy_rank":8,"patch_id":22,"patch_code":"if (LengthConstraintType.RANGE == null) return new Size2D();\n\t RectangleConstraint c4 = new RectangleConstraint(0.0,\r\n                    new Range(0.0, constraint.getWidth() - w[2]),\r\n                    LengthConstraintType.RANGE, h[2], null,\r\n                    LengthConstraintType.FIXED);RectangleConstraint c4 = new RectangleConstraint(0.0,\r\n                    new Range(0.0, constraint.getWidth() - w[2]),\r\n                    LengthConstraintType.RANGE, h[2], null,\r\n                    LengthConstraintType.FIXED);"},{"entropy_rank":9,"patch_id":3,"patch_code":"RectangleConstraint c4 = new RectangleConstraint(0.0,\r\n                    new Range(0.0, constraint.getWidth() - w[2]),\r\n                    LengthConstraintType.RANGE, h[2], null,\r\n                    LengthConstraintType.RANGE);RectangleConstraint c4 = new RectangleConstraint(0.0,\r\n                    new Range(0.0, constraint.getWidth() - w[2]),\r\n                    LengthConstraintType.RANGE, h[2], null,\r\n                    LengthConstraintType.FIXED);"},{"entropy_rank":10,"patch_id":17,"patch_code":"if (w == null) return new Size2D();\n\t RectangleConstraint c4 = new RectangleConstraint(0.0,\r\n                    new Range(0.0, constraint.getWidth() - w[2]),\r\n                    LengthConstraintType.RANGE, h[2], null,\r\n                    LengthConstraintType.FIXED);RectangleConstraint c4 = new RectangleConstraint(0.0,\r\n                    new Range(0.0, constraint.getWidth() - w[2]),\r\n                    LengthConstraintType.RANGE, h[2], null,\r\n                    LengthConstraintType.FIXED);"},{"entropy_rank":11,"patch_id":30,"patch_code":"if (LengthConstraintType.FIXED == null) {\n\t    return null;\n\t}\nRectangleConstraint c4 = new RectangleConstraint(0.0,\r\n                    new Range(0.0, constraint.getWidth() - w[2]),\r\n                    LengthConstraintType.RANGE, h[2], null,\r\n                    LengthConstraintType.FIXED);RectangleConstraint c4 = new RectangleConstraint(0.0,\r\n                    new Range(0.0, constraint.getWidth() - w[2]),\r\n                    LengthConstraintType.RANGE, h[2], null,\r\n                    LengthConstraintType.FIXED);"},{"entropy_rank":12,"patch_id":12,"patch_code":"if (constraint == null) return new Size2D();\n\t RectangleConstraint c4 = new RectangleConstraint(0.0,\r\n                    new Range(0.0, constraint.getWidth() - w[2]),\r\n                    LengthConstraintType.RANGE, h[2], null,\r\n                    LengthConstraintType.FIXED);RectangleConstraint c4 = new RectangleConstraint(0.0,\r\n                    new Range(0.0, constraint.getWidth() - w[2]),\r\n                    LengthConstraintType.RANGE, h[2], null,\r\n                    LengthConstraintType.FIXED);"},{"entropy_rank":13,"patch_id":20,"patch_code":"if (LengthConstraintType.RANGE == null) {\n\t    return null;\n\t}\nRectangleConstraint c4 = new RectangleConstraint(0.0,\r\n                    new Range(0.0, constraint.getWidth() - w[2]),\r\n                    LengthConstraintType.RANGE, h[2], null,\r\n                    LengthConstraintType.FIXED);RectangleConstraint c4 = new RectangleConstraint(0.0,\r\n                    new Range(0.0, constraint.getWidth() - w[2]),\r\n                    LengthConstraintType.RANGE, h[2], null,\r\n                    LengthConstraintType.FIXED);"},{"entropy_rank":14,"patch_id":15,"patch_code":"if (w == null) {\n\t    return null;\n\t}\nRectangleConstraint c4 = new RectangleConstraint(0.0,\r\n                    new Range(0.0, constraint.getWidth() - w[2]),\r\n                    LengthConstraintType.RANGE, h[2], null,\r\n                    LengthConstraintType.FIXED);RectangleConstraint c4 = new RectangleConstraint(0.0,\r\n                    new Range(0.0, constraint.getWidth() - w[2]),\r\n                    LengthConstraintType.RANGE, h[2], null,\r\n                    LengthConstraintType.FIXED);"},{"entropy_rank":15,"patch_id":27,"patch_code":"if (h == null) return new Size2D();\n\t RectangleConstraint c4 = new RectangleConstraint(0.0,\r\n                    new Range(0.0, constraint.getWidth() - w[2]),\r\n                    LengthConstraintType.RANGE, h[2], null,\r\n                    LengthConstraintType.FIXED);RectangleConstraint c4 = new RectangleConstraint(0.0,\r\n                    new Range(0.0, constraint.getWidth() - w[2]),\r\n                    LengthConstraintType.RANGE, h[2], null,\r\n                    LengthConstraintType.FIXED);"},{"entropy_rank":16,"patch_id":9,"patch_code":"if (constraint == null) {\n\t    return null;\n\t}\nRectangleConstraint c4 = new RectangleConstraint(0.0,\r\n                    new Range(0.0, constraint.getWidth() - w[2]),\r\n                    LengthConstraintType.RANGE, h[2], null,\r\n                    LengthConstraintType.FIXED);RectangleConstraint c4 = new RectangleConstraint(0.0,\r\n                    new Range(0.0, constraint.getWidth() - w[2]),\r\n                    LengthConstraintType.RANGE, h[2], null,\r\n                    LengthConstraintType.FIXED);"},{"entropy_rank":17,"patch_id":25,"patch_code":"if (h == null) {\n\t    return null;\n\t}\nRectangleConstraint c4 = new RectangleConstraint(0.0,\r\n                    new Range(0.0, constraint.getWidth() - w[2]),\r\n                    LengthConstraintType.RANGE, h[2], null,\r\n                    LengthConstraintType.FIXED);RectangleConstraint c4 = new RectangleConstraint(0.0,\r\n                    new Range(0.0, constraint.getWidth() - w[2]),\r\n                    LengthConstraintType.RANGE, h[2], null,\r\n                    LengthConstraintType.FIXED);"},{"entropy_rank":18,"patch_id":2,"patch_code":"RectangleConstraint c4 = new RectangleConstraint(0.0,\r\n                    new Range(0.0, constraint.getWidth() - w[2]),\r\n                    LengthConstraintType.RANGE, h[2], null,\r\n                    LengthConstraintType.NONE);RectangleConstraint c4 = new RectangleConstraint(0.0,\r\n                    new Range(0.0, constraint.getWidth() - w[2]),\r\n                    LengthConstraintType.RANGE, h[2], null,\r\n                    LengthConstraintType.FIXED);"},{"entropy_rank":19,"patch_id":13,"patch_code":"if (w != null) {\n\tRectangleConstraint c4 = new RectangleConstraint(0.0,\r\n                    new Range(0.0, constraint.getWidth() - w[2]),\r\n                    LengthConstraintType.RANGE, h[2], null,\r\n                    LengthConstraintType.FIXED);\r\n            Size2D size = this.rightBlock.arrange(g2, c4);\r\n            w[3] = size.width;\n\t}\nRectangleConstraint c4 = new RectangleConstraint(0.0,\r\n                    new Range(0.0, constraint.getWidth() - w[2]),\r\n                    LengthConstraintType.RANGE, h[2], null,\r\n                    LengthConstraintType.FIXED);\r\n            Size2D size = this.rightBlock.arrange(g2, c4);\r\n            w[3] = size.width;\n\t}\n"}],"Chart_14":[{"entropy_rank":3,"patch_id":43,"patch_code":"boolean removed = getCategories().remove(marker);boolean removed = markers.remove(marker);"},{"entropy_rank":4,"patch_id":82,"patch_code":"boolean removed = markers.remove(getRangeCrosshairValue());boolean removed = markers.remove(marker);"},{"entropy_rank":5,"patch_id":38,"patch_code":"boolean removed = getAnnotations().remove(marker);boolean removed = markers.remove(marker);"},{"entropy_rank":6,"patch_id":92,"patch_code":"boolean removed = markers.remove(isDomainZoomable());boolean removed = markers.remove(marker);"},{"entropy_rank":7,"patch_id":84,"patch_code":"boolean removed = markers.remove(getRangeCrosshairPaint());boolean removed = markers.remove(marker);"},{"entropy_rank":8,"patch_id":52,"patch_code":"boolean removed = markers.remove(getDomainAxisLocation());boolean removed = markers.remove(marker);"},{"entropy_rank":10,"patch_id":93,"patch_code":"boolean removed = markers.remove(isRangeZoomable());boolean removed = markers.remove(marker);"},{"entropy_rank":11,"patch_id":80,"patch_code":"boolean removed = markers.remove(isRangeCrosshairVisible());boolean removed = markers.remove(marker);"},{"entropy_rank":12,"patch_id":77,"patch_code":"boolean removed = markers.remove(getLegendItems());boolean removed = markers.remove(marker);"},{"entropy_rank":13,"patch_id":72,"patch_code":"boolean removed = markers.remove(getDomainGridlinePaint());boolean removed = markers.remove(marker);"},{"entropy_rank":14,"patch_id":51,"patch_code":"boolean removed = markers.remove(getDomainAxis());boolean removed = markers.remove(marker);"},{"entropy_rank":15,"patch_id":63,"patch_code":"boolean removed = markers.remove(getDataset());boolean removed = markers.remove(marker);"},{"entropy_rank":16,"patch_id":70,"patch_code":"boolean removed = markers.remove(getDomainGridlinePosition());boolean removed = markers.remove(marker);"},{"entropy_rank":16,"patch_id":81,"patch_code":"boolean removed = markers.remove(isRangeCrosshairLockedOnData());boolean removed = markers.remove(marker);"},{"entropy_rank":18,"patch_id":53,"patch_code":"boolean removed = markers.remove(getDomainAxisEdge());boolean removed = markers.remove(marker);"},{"entropy_rank":19,"patch_id":69,"patch_code":"boolean removed = markers.remove(isDomainGridlinesVisible());boolean removed = markers.remove(marker);"},{"entropy_rank":20,"patch_id":65,"patch_code":"boolean removed = markers.remove(getRenderer());boolean removed = markers.remove(marker);"},{"entropy_rank":20,"patch_id":83,"patch_code":"boolean removed = markers.remove(getRangeCrosshairStroke());boolean removed = markers.remove(marker);"},{"entropy_rank":22,"patch_id":76,"patch_code":"boolean removed = markers.remove(getFixedLegendItems());boolean removed = markers.remove(marker);"},{"entropy_rank":23,"patch_id":66,"patch_code":"boolean removed = markers.remove(getDatasetRenderingOrder());boolean removed = markers.remove(marker);"},{"entropy_rank":24,"patch_id":58,"patch_code":"boolean removed = markers.remove(getRangeAxisLocation());boolean removed = markers.remove(marker);"},{"entropy_rank":25,"patch_id":71,"patch_code":"boolean removed = markers.remove(getDomainGridlineStroke());boolean removed = markers.remove(marker);"},{"entropy_rank":26,"patch_id":48,"patch_code":"boolean removed = markers.remove(getPlotType());boolean removed = markers.remove(marker);"},{"entropy_rank":27,"patch_id":57,"patch_code":"boolean removed = markers.remove(getRangeAxis());boolean removed = markers.remove(marker);"},{"entropy_rank":28,"patch_id":73,"patch_code":"boolean removed = markers.remove(isRangeGridlinesVisible());boolean removed = markers.remove(marker);"},{"entropy_rank":29,"patch_id":94,"patch_code":"boolean removed = markers.remove(getAnchorValue());boolean removed = markers.remove(marker);"},{"entropy_rank":30,"patch_id":50,"patch_code":"boolean removed = markers.remove(getAxisOffset());boolean removed = markers.remove(marker);"},{"entropy_rank":31,"patch_id":59,"patch_code":"boolean removed = markers.remove(getRangeAxisEdge());boolean removed = markers.remove(marker);"},{"entropy_rank":32,"patch_id":90,"patch_code":"boolean removed = markers.remove(getCategories());boolean removed = markers.remove(marker);"},{"entropy_rank":33,"patch_id":75,"patch_code":"boolean removed = markers.remove(getRangeGridlinePaint());boolean removed = markers.remove(marker);"},{"entropy_rank":34,"patch_id":49,"patch_code":"boolean removed = markers.remove(getOrientation());boolean removed = markers.remove(marker);"},{"entropy_rank":35,"patch_id":85,"patch_code":"boolean removed = markers.remove(getAnnotations());boolean removed = markers.remove(marker);"},{"entropy_rank":36,"patch_id":67,"patch_code":"boolean removed = markers.remove(getColumnRenderingOrder());boolean removed = markers.remove(marker);"},{"entropy_rank":37,"patch_id":88,"patch_code":"boolean removed = markers.remove(getFixedDomainAxisSpace());boolean removed = markers.remove(marker);"},{"entropy_rank":38,"patch_id":68,"patch_code":"boolean removed = markers.remove(getRowRenderingOrder());boolean removed = markers.remove(marker);"},{"entropy_rank":39,"patch_id":74,"patch_code":"boolean removed = markers.remove(getRangeGridlineStroke());boolean removed = markers.remove(marker);"},{"entropy_rank":40,"patch_id":89,"patch_code":"boolean removed = markers.remove(getFixedRangeAxisSpace());boolean removed = markers.remove(marker);"},{"entropy_rank":41,"patch_id":91,"patch_code":"boolean removed = markers.remove(getDrawSharedDomainAxis());boolean removed = markers.remove(marker);"}],"Chart_16":[{"entropy_rank":1,"patch_id":59,"patch_code":""},{"entropy_rank":2,"patch_id":56,"patch_code":"\r\n        for (int i = 0; i < categoryKeys.length; i++) {\r\n            if (categoryKeys[i] == null) {\r\n                throw new IllegalArgumentException(\r\n                    \"DefaultIntervalCategoryDataset.setCategoryKeys(): \"\r\n                    + \"null category not permitted.\");\r\n            }\r\n        }\r\n        this.categoryKeys = categoryKeys;\r\n        fireDatasetChanged();\n\tif (categoryKeys.length != this.startData[0].length) {\r\n            throw new IllegalArgumentException(\r\n                    \"The number of categories does not match the data.\");\r\n        }\n"},{"entropy_rank":3,"patch_id":55,"patch_code":"\r\n        for (int i = 0; i < categoryKeys.length; i++) {\r\n            if (categoryKeys[i] == null) {\r\n                throw new IllegalArgumentException(\r\n                    \"DefaultIntervalCategoryDataset.setCategoryKeys(): \"\r\n                    + \"null category not permitted.\");\r\n            }\r\n        }\r\n        this.categoryKeys = categoryKeys;\n\tif (categoryKeys.length != this.startData[0].length) {\r\n            throw new IllegalArgumentException(\r\n                    \"The number of categories does not match the data.\");\r\n        }\n"},{"entropy_rank":4,"patch_id":54,"patch_code":"\r\n        for (int i = 0; i < categoryKeys.length; i++) {\r\n            if (categoryKeys[i] == null) {\r\n                throw new IllegalArgumentException(\r\n                    \"DefaultIntervalCategoryDataset.setCategoryKeys(): \"\r\n                    + \"null category not permitted.\");\r\n            }\r\n        }\n\tif (categoryKeys.length != this.startData[0].length) {\r\n            throw new IllegalArgumentException(\r\n                    \"The number of categories does not match the data.\");\r\n        }\n"},{"entropy_rank":5,"patch_id":46,"patch_code":"if (this.startData == null) {\n\t    throw new IllegalArgumentException(\"Null 'this.startData' argument.\");\n\t}\nif (categoryKeys.length != this.startData[0].length) {\r\n            throw new IllegalArgumentException(\r\n                    \"The number of categories does not match the data.\");\r\n        }if (categoryKeys.length != this.startData[0].length) {\r\n            throw new IllegalArgumentException(\r\n                    \"The number of categories does not match the data.\");\r\n        }"},{"entropy_rank":9,"patch_id":3,"patch_code":"this.categoryKeys = null;"},{"entropy_rank":10,"patch_id":48,"patch_code":"if (this.startData == null) this.startData = this.endData;\n if (categoryKeys.length != this.startData[0].length) {\r\n            throw new IllegalArgumentException(\r\n                    \"The number of categories does not match the data.\");\r\n        }if (categoryKeys.length != this.startData[0].length) {\r\n            throw new IllegalArgumentException(\r\n                    \"The number of categories does not match the data.\");\r\n        }"},{"entropy_rank":12,"patch_id":53,"patch_code":"if (categoryKeys.length != this.startData[0].length) {\r\n            throw new IllegalArgumentException(\r\n                    \"The number of categories does not match the data.\");\r\n        }\n\tif (categoryKeys == null) {\r\n            throw new IllegalArgumentException(\"Null 'categoryKeys' argument.\");\r\n        }\r\n        "},{"entropy_rank":13,"patch_id":7,"patch_code":"if (categoryKeys.length>this.startData[0].length) {\r\n            throw new IllegalArgumentException(\r\n                    \"The number of categories does not match the data.\");\r\n        }if (categoryKeys.length != this.startData[0].length) {\r\n            throw new IllegalArgumentException(\r\n                    \"The number of categories does not match the data.\");\r\n        }"},{"entropy_rank":14,"patch_id":5,"patch_code":"if (categoryKeys.length<this.startData[0].length) {\r\n            throw new IllegalArgumentException(\r\n                    \"The number of categories does not match the data.\");\r\n        }if (categoryKeys.length != this.startData[0].length) {\r\n            throw new IllegalArgumentException(\r\n                    \"The number of categories does not match the data.\");\r\n        }"},{"entropy_rank":15,"patch_id":4,"patch_code":"if (categoryKeys.length==this.startData[0].length) {\r\n            throw new IllegalArgumentException(\r\n                    \"The number of categories does not match the data.\");\r\n        }if (categoryKeys.length != this.startData[0].length) {\r\n            throw new IllegalArgumentException(\r\n                    \"The number of categories does not match the data.\");\r\n        }"},{"entropy_rank":16,"patch_id":47,"patch_code":"if (this.startData == null) {\n\t    return;\n\t}\nif (categoryKeys.length != this.startData[0].length) {\r\n            throw new IllegalArgumentException(\r\n                    \"The number of categories does not match the data.\");\r\n        }if (categoryKeys.length != this.startData[0].length) {\r\n            throw new IllegalArgumentException(\r\n                    \"The number of categories does not match the data.\");\r\n        }"},{"entropy_rank":17,"patch_id":8,"patch_code":"if (categoryKeys.length>=this.startData[0].length) {\r\n            throw new IllegalArgumentException(\r\n                    \"The number of categories does not match the data.\");\r\n        }if (categoryKeys.length != this.startData[0].length) {\r\n            throw new IllegalArgumentException(\r\n                    \"The number of categories does not match the data.\");\r\n        }"},{"entropy_rank":18,"patch_id":6,"patch_code":"if (categoryKeys.length<=this.startData[0].length) {\r\n            throw new IllegalArgumentException(\r\n                    \"The number of categories does not match the data.\");\r\n        }if (categoryKeys.length != this.startData[0].length) {\r\n            throw new IllegalArgumentException(\r\n                    \"The number of categories does not match the data.\");\r\n        }"},{"entropy_rank":19,"patch_id":1,"patch_code":"this.seriesKeys = null;"},{"entropy_rank":20,"patch_id":58,"patch_code":"if (categoryKeys.length != this.startData[0].length) {\r\n            throw new IllegalArgumentException(\r\n                    \"The number of categories does not match the data.\");\r\n        }"},{"entropy_rank":21,"patch_id":52,"patch_code":"if (this.startData != null && this.startData[0] != null) {\n\tif (categoryKeys.length != this.startData[0].length) {\r\n            throw new IllegalArgumentException(\r\n                    \"The number of categories does not match the data.\");\r\n        }\n\t}\nif (categoryKeys.length != this.startData[0].length) {\r\n            throw new IllegalArgumentException(\r\n                    \"The number of categories does not match the data.\");\r\n        }\n\t}\n"},{"entropy_rank":22,"patch_id":45,"patch_code":"if (this.startData != null) {\n\tif (categoryKeys.length != this.startData[0].length) {\r\n            throw new IllegalArgumentException(\r\n                    \"The number of categories does not match the data.\");\r\n        }\n\t}\nif (categoryKeys.length != this.startData[0].length) {\r\n            throw new IllegalArgumentException(\r\n                    \"The number of categories does not match the data.\");\r\n        }\n\t}\n"},{"entropy_rank":23,"patch_id":51,"patch_code":"if (this.startData[0] != null) {if (categoryKeys.length != this.startData[0].length) {\r\n            throw new IllegalArgumentException(\r\n                    \"The number of categories does not match the data.\");\r\n        }\n\t}\nif (categoryKeys.length != this.startData[0].length) {\r\n            throw new IllegalArgumentException(\r\n                    \"The number of categories does not match the data.\");\r\n        }\n\t}\n"}],"Chart_18":[{"entropy_rank":1,"patch_id":1,"patch_code":"if (index==this.keys.size()) {\n        rebuildIndex();\n        }if (index < this.keys.size()) {\n        rebuildIndex();\n        }"},{"entropy_rank":2,"patch_id":4,"patch_code":"if (index>this.keys.size()) {\n        rebuildIndex();\n        }if (index < this.keys.size()) {\n        rebuildIndex();\n        }"},{"entropy_rank":3,"patch_id":5,"patch_code":"if (index>=this.keys.size()) {\n        rebuildIndex();\n        }if (index < this.keys.size()) {\n        rebuildIndex();\n        }"},{"entropy_rank":4,"patch_id":2,"patch_code":"if (index!=this.keys.size()) {\n        rebuildIndex();\n        }if (index < this.keys.size()) {\n        rebuildIndex();\n        }"},{"entropy_rank":5,"patch_id":3,"patch_code":"if (index<=this.keys.size()) {\n        rebuildIndex();\n        }if (index < this.keys.size()) {\n        rebuildIndex();\n        }"}],"Chart_19":[{"entropy_rank":1,"patch_id":56,"patch_code":"if (this.domainAxes == null) {\n\t    throw new IllegalArgumentException(\"Null 'this.domainAxes' argument.\");\n\t}\nreturn this.domainAxes.indexOf(axis);return this.domainAxes.indexOf(axis);"},{"entropy_rank":2,"patch_id":68,"patch_code":"if (axis == null) {\n\t    throw new IllegalArgumentException(\"Null 'axis' argument.\");\n\t}\nreturn this.domainAxes.indexOf(axis);return this.domainAxes.indexOf(axis);"},{"entropy_rank":3,"patch_id":57,"patch_code":"if (this.domainAxes == null) {\n\t    return 0;\n\t}\nreturn this.domainAxes.indexOf(axis);return this.domainAxes.indexOf(axis);"},{"entropy_rank":4,"patch_id":69,"patch_code":"if (axis == null) {\n\t    return 0;\n\t}\nreturn this.domainAxes.indexOf(axis);return this.domainAxes.indexOf(axis);"},{"entropy_rank":5,"patch_id":105,"patch_code":"int result = this.rangeAxes.indexOf(getOrientation());int result = this.rangeAxes.indexOf(axis);"},{"entropy_rank":6,"patch_id":103,"patch_code":"int result = this.datasetToDomainAxisMap.indexOf(axis);int result = this.rangeAxes.indexOf(axis);"},{"entropy_rank":7,"patch_id":59,"patch_code":"if (this.domainAxes == null) this.domainAxes = this.rangeAxes;\n return this.domainAxes.indexOf(axis);return this.domainAxes.indexOf(axis);"},{"entropy_rank":8,"patch_id":72,"patch_code":"if (!(this.domainAxes != null && axis != null)) return 0;\nreturn this.domainAxes.indexOf(axis);return this.domainAxes.indexOf(axis);"},{"entropy_rank":9,"patch_id":58,"patch_code":"if (this.domainAxes == null) this.domainAxes = this.domainAxisLocations;\n return this.domainAxes.indexOf(axis);return this.domainAxes.indexOf(axis);"},{"entropy_rank":10,"patch_id":70,"patch_code":"if (axis == null) axis = new CategoryAxis();\n return this.domainAxes.indexOf(axis);return this.domainAxes.indexOf(axis);"},{"entropy_rank":11,"patch_id":62,"patch_code":"if (this.domainAxes == null) this.domainAxes = this.datasetToDomainAxisMap;\n return this.domainAxes.indexOf(axis);return this.domainAxes.indexOf(axis);"},{"entropy_rank":12,"patch_id":65,"patch_code":"if (this.domainAxes == null) this.domainAxes = new ObjectList();\n return this.domainAxes.indexOf(axis);return this.domainAxes.indexOf(axis);"},{"entropy_rank":13,"patch_id":60,"patch_code":"if (this.domainAxes == null) this.domainAxes = this.rangeAxisLocations;\n return this.domainAxes.indexOf(axis);return this.domainAxes.indexOf(axis);"},{"entropy_rank":14,"patch_id":63,"patch_code":"if (this.domainAxes == null) this.domainAxes = this.datasetToRangeAxisMap;\n return this.domainAxes.indexOf(axis);return this.domainAxes.indexOf(axis);"},{"entropy_rank":15,"patch_id":61,"patch_code":"if (this.domainAxes == null) this.domainAxes = this.datasets;\n return this.domainAxes.indexOf(axis);return this.domainAxes.indexOf(axis);"},{"entropy_rank":16,"patch_id":66,"patch_code":"if (this.domainAxes == null) return this.weight;\n\t return this.domainAxes.indexOf(axis);return this.domainAxes.indexOf(axis);"},{"entropy_rank":17,"patch_id":64,"patch_code":"if (this.domainAxes == null) this.domainAxes = this.renderers;\n return this.domainAxes.indexOf(axis);return this.domainAxes.indexOf(axis);"},{"entropy_rank":20,"patch_id":79,"patch_code":"configureDomainAxes();\n\treturn this.domainAxes.indexOf(axis);return this.domainAxes.indexOf(axis);"},{"entropy_rank":21,"patch_id":71,"patch_code":"if (axis == null) return this.weight;\n\t return this.domainAxes.indexOf(axis);return this.domainAxes.indexOf(axis);"},{"entropy_rank":22,"patch_id":2,"patch_code":"return this.domainAxisLocations.indexOf(axis);return this.domainAxes.indexOf(axis);"},{"entropy_rank":23,"patch_id":83,"patch_code":"configureRangeAxes();\n\treturn this.domainAxes.indexOf(axis);return this.domainAxes.indexOf(axis);"},{"entropy_rank":24,"patch_id":89,"patch_code":"clearAnnotations();\n\treturn this.domainAxes.indexOf(axis);return this.domainAxes.indexOf(axis);"},{"entropy_rank":25,"patch_id":98,"patch_code":"int result = this.rangeAxisLocations.indexOf(axis);int result = this.rangeAxes.indexOf(axis);"},{"entropy_rank":26,"patch_id":11,"patch_code":"return this.domainAxes.indexOf(getDomainAxis());return this.domainAxes.indexOf(axis);"},{"entropy_rank":29,"patch_id":6,"patch_code":"return this.rangeAxisLocations.indexOf(axis);return this.domainAxes.indexOf(axis);"},{"entropy_rank":30,"patch_id":53,"patch_code":"return this.domainAxes.indexOf(isRangeZoomable());return this.domainAxes.indexOf(axis);"},{"entropy_rank":31,"patch_id":1,"patch_code":"return this.rangeAxes.indexOf(axis);return this.domainAxes.indexOf(axis);"},{"entropy_rank":33,"patch_id":52,"patch_code":"return this.domainAxes.indexOf(isDomainZoomable());return this.domainAxes.indexOf(axis);"},{"entropy_rank":35,"patch_id":97,"patch_code":"int result = this.domainAxes.indexOf(axis);int result = this.rangeAxes.indexOf(axis);"},{"entropy_rank":36,"patch_id":17,"patch_code":"return this.domainAxes.indexOf(getRangeAxis());return this.domainAxes.indexOf(axis);"},{"entropy_rank":37,"patch_id":14,"patch_code":"return this.domainAxes.indexOf(getDomainAxisCount());return this.domainAxes.indexOf(axis);"},{"entropy_rank":38,"patch_id":87,"patch_code":"clearRangeMarkers();\n\treturn this.domainAxes.indexOf(axis);return this.domainAxes.indexOf(axis);"},{"entropy_rank":39,"patch_id":20,"patch_code":"return this.domainAxes.indexOf(getRangeAxisCount());return this.domainAxes.indexOf(axis);"},{"entropy_rank":39,"patch_id":18,"patch_code":"return this.domainAxes.indexOf(getRangeAxisLocation());return this.domainAxes.indexOf(axis);"},{"entropy_rank":41,"patch_id":106,"patch_code":"int result = this.rangeAxes.indexOf(getAxisOffset());int result = this.rangeAxes.indexOf(axis);"},{"entropy_rank":42,"patch_id":32,"patch_code":"return this.domainAxes.indexOf(getDomainGridlinePaint());return this.domainAxes.indexOf(axis);"},{"entropy_rank":43,"patch_id":44,"patch_code":"return this.domainAxes.indexOf(getRangeCrosshairPaint());return this.domainAxes.indexOf(axis);"},{"entropy_rank":44,"patch_id":101,"patch_code":"int result = this.domainAxisLocations.indexOf(axis);int result = this.rangeAxes.indexOf(axis);"},{"entropy_rank":45,"patch_id":40,"patch_code":"return this.domainAxes.indexOf(isRangeCrosshairVisible());return this.domainAxes.indexOf(axis);"},{"entropy_rank":46,"patch_id":42,"patch_code":"return this.domainAxes.indexOf(getRangeCrosshairValue());return this.domainAxes.indexOf(axis);"},{"entropy_rank":47,"patch_id":12,"patch_code":"return this.domainAxes.indexOf(getDomainAxisLocation());return this.domainAxes.indexOf(axis);"},{"entropy_rank":49,"patch_id":37,"patch_code":"return this.domainAxes.indexOf(getLegendItems());return this.domainAxes.indexOf(axis);"},{"entropy_rank":50,"patch_id":41,"patch_code":"return this.domainAxes.indexOf(isRangeCrosshairLockedOnData());return this.domainAxes.indexOf(axis);"},{"entropy_rank":52,"patch_id":30,"patch_code":"return this.domainAxes.indexOf(getDomainGridlinePosition());return this.domainAxes.indexOf(axis);"},{"entropy_rank":53,"patch_id":29,"patch_code":"return this.domainAxes.indexOf(isDomainGridlinesVisible());return this.domainAxes.indexOf(axis);"},{"entropy_rank":54,"patch_id":85,"patch_code":"clearDomainMarkers();\n\treturn this.domainAxes.indexOf(axis);return this.domainAxes.indexOf(axis);"},{"entropy_rank":55,"patch_id":50,"patch_code":"return this.domainAxes.indexOf(getCategories());return this.domainAxes.indexOf(axis);"},{"entropy_rank":56,"patch_id":13,"patch_code":"return this.domainAxes.indexOf(getDomainAxisEdge());return this.domainAxes.indexOf(axis);"},{"entropy_rank":57,"patch_id":43,"patch_code":"return this.domainAxes.indexOf(getRangeCrosshairStroke());return this.domainAxes.indexOf(axis);"},{"entropy_rank":58,"patch_id":31,"patch_code":"return this.domainAxes.indexOf(getDomainGridlineStroke());return this.domainAxes.indexOf(axis);"},{"entropy_rank":59,"patch_id":35,"patch_code":"return this.domainAxes.indexOf(getRangeGridlinePaint());return this.domainAxes.indexOf(axis);"},{"entropy_rank":60,"patch_id":27,"patch_code":"return this.domainAxes.indexOf(getColumnRenderingOrder());return this.domainAxes.indexOf(axis);"},{"entropy_rank":63,"patch_id":19,"patch_code":"return this.domainAxes.indexOf(getRangeAxisEdge());return this.domainAxes.indexOf(axis);"},{"entropy_rank":64,"patch_id":48,"patch_code":"return this.domainAxes.indexOf(getFixedDomainAxisSpace());return this.domainAxes.indexOf(axis);"},{"entropy_rank":65,"patch_id":26,"patch_code":"return this.domainAxes.indexOf(getDatasetRenderingOrder());return this.domainAxes.indexOf(axis);"},{"entropy_rank":66,"patch_id":28,"patch_code":"return this.domainAxes.indexOf(getRowRenderingOrder());return this.domainAxes.indexOf(axis);"},{"entropy_rank":67,"patch_id":33,"patch_code":"return this.domainAxes.indexOf(isRangeGridlinesVisible());return this.domainAxes.indexOf(axis);"},{"entropy_rank":68,"patch_id":8,"patch_code":"return this.domainAxes.indexOf(getPlotType());return this.domainAxes.indexOf(axis);"},{"entropy_rank":69,"patch_id":34,"patch_code":"return this.domainAxes.indexOf(getRangeGridlineStroke());return this.domainAxes.indexOf(axis);"},{"entropy_rank":70,"patch_id":54,"patch_code":"return this.domainAxes.indexOf(getAnchorValue());return this.domainAxes.indexOf(axis);"},{"entropy_rank":71,"patch_id":23,"patch_code":"return this.domainAxes.indexOf(getDataset());return this.domainAxes.indexOf(axis);"},{"entropy_rank":72,"patch_id":3,"patch_code":"return this.datasetToDomainAxisMap.indexOf(axis);return this.domainAxes.indexOf(axis);"},{"entropy_rank":73,"patch_id":81,"patch_code":"clearRangeAxes();\n\treturn this.domainAxes.indexOf(axis);return this.domainAxes.indexOf(axis);"},{"entropy_rank":74,"patch_id":36,"patch_code":"return this.domainAxes.indexOf(getFixedLegendItems());return this.domainAxes.indexOf(axis);"},{"entropy_rank":75,"patch_id":9,"patch_code":"return this.domainAxes.indexOf(getOrientation());return this.domainAxes.indexOf(axis);"},{"entropy_rank":76,"patch_id":25,"patch_code":"return this.domainAxes.indexOf(getRenderer());return this.domainAxes.indexOf(axis);"},{"entropy_rank":77,"patch_id":49,"patch_code":"return this.domainAxes.indexOf(getFixedRangeAxisSpace());return this.domainAxes.indexOf(axis);"},{"entropy_rank":78,"patch_id":51,"patch_code":"return this.domainAxes.indexOf(getDrawSharedDomainAxis());return this.domainAxes.indexOf(axis);"},{"entropy_rank":79,"patch_id":45,"patch_code":"return this.domainAxes.indexOf(getAnnotations());return this.domainAxes.indexOf(axis);"},{"entropy_rank":80,"patch_id":24,"patch_code":"return this.domainAxes.indexOf(getDatasetCount());return this.domainAxes.indexOf(axis);"},{"entropy_rank":81,"patch_id":10,"patch_code":"return this.domainAxes.indexOf(getAxisOffset());return this.domainAxes.indexOf(axis);"},{"entropy_rank":82,"patch_id":4,"patch_code":"return this.datasetToRangeAxisMap.indexOf(axis);return this.domainAxes.indexOf(axis);"},{"entropy_rank":83,"patch_id":47,"patch_code":"return this.domainAxes.indexOf(getWeight());return this.domainAxes.indexOf(axis);"},{"entropy_rank":84,"patch_id":7,"patch_code":"return this.renderers.indexOf(axis);return this.domainAxes.indexOf(axis);"},{"entropy_rank":85,"patch_id":5,"patch_code":"return this.datasets.indexOf(axis);return this.domainAxes.indexOf(axis);"}],"Chart_20":[{"entropy_rank":1,"patch_id":83,"patch_code":"super(paint, stroke, outlinePaint, outlineStroke, alpha);super(paint, stroke, paint, stroke, alpha);"},{"entropy_rank":2,"patch_id":1,"patch_code":"super(outlinePaint, outlineStroke, paint, stroke, alpha);super(paint, stroke, paint, stroke, alpha);"},{"entropy_rank":3,"patch_id":53,"patch_code":"super(paint, outlineStroke, outlinePaint, stroke, alpha);super(paint, stroke, paint, stroke, alpha);"},{"entropy_rank":4,"patch_id":65,"patch_code":"super(paint, outlineStroke, paint, outlineStroke, alpha);super(paint, stroke, paint, stroke, alpha);"},{"entropy_rank":5,"patch_id":29,"patch_code":"super(outlinePaint, stroke, paint, outlineStroke, alpha);super(paint, stroke, paint, stroke, alpha);"},{"entropy_rank":6,"patch_id":13,"patch_code":"super(outlinePaint, stroke, outlinePaint, stroke, alpha);super(paint, stroke, paint, stroke, alpha);"}],"Chart_22":[{"entropy_rank":1,"patch_id":39,"patch_code":"removeRow(row);\n\tif (row >= 0) {\r\n        KeyedObjects rowData = (KeyedObjects) this.rows.get(row);\r\n            return rowData.getObject(columnKey);\r\n        }\r\n        else {\r\n            return null;\r\n        }if (row >= 0) {\r\n        KeyedObjects rowData = (KeyedObjects) this.rows.get(row);\r\n            return rowData.getObject(columnKey);\r\n        }\r\n        else {\r\n            return null;\r\n        }"},{"entropy_rank":2,"patch_id":66,"patch_code":"removeRow(columnKey);\n\treturn rowData.getObject(columnKey);return rowData.getObject(columnKey);"},{"entropy_rank":10,"patch_id":27,"patch_code":"if (hashCode() >= 0) {\r\n        KeyedObjects rowData = (KeyedObjects) this.rows.get(row);\r\n            return rowData.getObject(columnKey);\r\n        }\r\n        else {\r\n            return null;\r\n        }if (row >= 0) {\r\n        KeyedObjects rowData = (KeyedObjects) this.rows.get(row);\r\n            return rowData.getObject(columnKey);\r\n        }\r\n        else {\r\n            return null;\r\n        }"},{"entropy_rank":11,"patch_id":24,"patch_code":"if (getColumnCount() >= 0) {\r\n        KeyedObjects rowData = (KeyedObjects) this.rows.get(row);\r\n            return rowData.getObject(columnKey);\r\n        }\r\n        else {\r\n            return null;\r\n        }if (row >= 0) {\r\n        KeyedObjects rowData = (KeyedObjects) this.rows.get(row);\r\n            return rowData.getObject(columnKey);\r\n        }\r\n        else {\r\n            return null;\r\n        }"},{"entropy_rank":12,"patch_id":6,"patch_code":"if ((row >= 0) || (row < 0)) {\r\n        KeyedObjects rowData = (KeyedObjects) this.rows.get(row);\r\n            return rowData.getObject(columnKey);\r\n        }\r\n        else {\r\n            return null;\r\n        }if (row >= 0) {\r\n        KeyedObjects rowData = (KeyedObjects) this.rows.get(row);\r\n            return rowData.getObject(columnKey);\r\n        }\r\n        else {\r\n            return null;\r\n        }"},{"entropy_rank":14,"patch_id":42,"patch_code":"removeColumn(row);\n\tif (row >= 0) {\r\n        KeyedObjects rowData = (KeyedObjects) this.rows.get(row);\r\n            return rowData.getObject(columnKey);\r\n        }\r\n        else {\r\n            return null;\r\n        }if (row >= 0) {\r\n        KeyedObjects rowData = (KeyedObjects) this.rows.get(row);\r\n            return rowData.getObject(columnKey);\r\n        }\r\n        else {\r\n            return null;\r\n        }"},{"entropy_rank":16,"patch_id":34,"patch_code":"return null;if (row >= 0) {\r\n        KeyedObjects rowData = (KeyedObjects) this.rows.get(row);\r\n            return rowData.getObject(columnKey);\r\n        }\r\n        else {\r\n            return null;\r\n        }"},{"entropy_rank":17,"patch_id":9,"patch_code":"if ((row >= 0) && !(row < 0)) {\r\n        KeyedObjects rowData = (KeyedObjects) this.rows.get(row);\r\n            return rowData.getObject(columnKey);\r\n        }\r\n        else {\r\n            return null;\r\n        }if (row >= 0) {\r\n        KeyedObjects rowData = (KeyedObjects) this.rows.get(row);\r\n            return rowData.getObject(columnKey);\r\n        }\r\n        else {\r\n            return null;\r\n        }"},{"entropy_rank":18,"patch_id":7,"patch_code":"if ((row >= 0) && (row < 0)) {\r\n        KeyedObjects rowData = (KeyedObjects) this.rows.get(row);\r\n            return rowData.getObject(columnKey);\r\n        }\r\n        else {\r\n            return null;\r\n        }if (row >= 0) {\r\n        KeyedObjects rowData = (KeyedObjects) this.rows.get(row);\r\n            return rowData.getObject(columnKey);\r\n        }\r\n        else {\r\n            return null;\r\n        }"},{"entropy_rank":19,"patch_id":12,"patch_code":"if (row == column && (row >= 0)) {\r\n        KeyedObjects rowData = (KeyedObjects) this.rows.get(row);\r\n            return rowData.getObject(columnKey);\r\n        }\r\n        else {\r\n            return null;\r\n        }if (row >= 0) {\r\n        KeyedObjects rowData = (KeyedObjects) this.rows.get(row);\r\n            return rowData.getObject(columnKey);\r\n        }\r\n        else {\r\n            return null;\r\n        }"},{"entropy_rank":20,"patch_id":37,"patch_code":""},{"entropy_rank":21,"patch_id":71,"patch_code":"getRowKey(index);removeRow(index);"},{"entropy_rank":22,"patch_id":8,"patch_code":"if ((row >= 0) || !(row < 0)) {\r\n        KeyedObjects rowData = (KeyedObjects) this.rows.get(row);\r\n            return rowData.getObject(columnKey);\r\n        }\r\n        else {\r\n            return null;\r\n        }if (row >= 0) {\r\n        KeyedObjects rowData = (KeyedObjects) this.rows.get(row);\r\n            return rowData.getObject(columnKey);\r\n        }\r\n        else {\r\n            return null;\r\n        }"},{"entropy_rank":23,"patch_id":14,"patch_code":"if (row < column && (row >= 0)) {\r\n        KeyedObjects rowData = (KeyedObjects) this.rows.get(row);\r\n            return rowData.getObject(columnKey);\r\n        }\r\n        else {\r\n            return null;\r\n        }if (row >= 0) {\r\n        KeyedObjects rowData = (KeyedObjects) this.rows.get(row);\r\n            return rowData.getObject(columnKey);\r\n        }\r\n        else {\r\n            return null;\r\n        }"},{"entropy_rank":24,"patch_id":10,"patch_code":"if (row != column && (row >= 0)) {\r\n        KeyedObjects rowData = (KeyedObjects) this.rows.get(row);\r\n            return rowData.getObject(columnKey);\r\n        }\r\n        else {\r\n            return null;\r\n        }if (row >= 0) {\r\n        KeyedObjects rowData = (KeyedObjects) this.rows.get(row);\r\n            return rowData.getObject(columnKey);\r\n        }\r\n        else {\r\n            return null;\r\n        }"},{"entropy_rank":25,"patch_id":13,"patch_code":"if (row == column || (row >= 0)) {\r\n        KeyedObjects rowData = (KeyedObjects) this.rows.get(row);\r\n            return rowData.getObject(columnKey);\r\n        }\r\n        else {\r\n            return null;\r\n        }if (row >= 0) {\r\n        KeyedObjects rowData = (KeyedObjects) this.rows.get(row);\r\n            return rowData.getObject(columnKey);\r\n        }\r\n        else {\r\n            return null;\r\n        }"},{"entropy_rank":26,"patch_id":72,"patch_code":"getColumnKey(index);removeRow(index);"},{"entropy_rank":27,"patch_id":16,"patch_code":"if (row <= column && (row >= 0)) {\r\n        KeyedObjects rowData = (KeyedObjects) this.rows.get(row);\r\n            return rowData.getObject(columnKey);\r\n        }\r\n        else {\r\n            return null;\r\n        }if (row >= 0) {\r\n        KeyedObjects rowData = (KeyedObjects) this.rows.get(row);\r\n            return rowData.getObject(columnKey);\r\n        }\r\n        else {\r\n            return null;\r\n        }"},{"entropy_rank":28,"patch_id":18,"patch_code":"if (row > column && (row >= 0)) {\r\n        KeyedObjects rowData = (KeyedObjects) this.rows.get(row);\r\n            return rowData.getObject(columnKey);\r\n        }\r\n        else {\r\n            return null;\r\n        }if (row >= 0) {\r\n        KeyedObjects rowData = (KeyedObjects) this.rows.get(row);\r\n            return rowData.getObject(columnKey);\r\n        }\r\n        else {\r\n            return null;\r\n        }"},{"entropy_rank":29,"patch_id":11,"patch_code":"if (row != column || (row >= 0)) {\r\n        KeyedObjects rowData = (KeyedObjects) this.rows.get(row);\r\n            return rowData.getObject(columnKey);\r\n        }\r\n        else {\r\n            return null;\r\n        }if (row >= 0) {\r\n        KeyedObjects rowData = (KeyedObjects) this.rows.get(row);\r\n            return rowData.getObject(columnKey);\r\n        }\r\n        else {\r\n            return null;\r\n        }"},{"entropy_rank":30,"patch_id":15,"patch_code":"if (row < column || (row >= 0)) {\r\n        KeyedObjects rowData = (KeyedObjects) this.rows.get(row);\r\n            return rowData.getObject(columnKey);\r\n        }\r\n        else {\r\n            return null;\r\n        }if (row >= 0) {\r\n        KeyedObjects rowData = (KeyedObjects) this.rows.get(row);\r\n            return rowData.getObject(columnKey);\r\n        }\r\n        else {\r\n            return null;\r\n        }"},{"entropy_rank":31,"patch_id":1,"patch_code":"if (row==0) {\r\n        KeyedObjects rowData = (KeyedObjects) this.rows.get(row);\r\n            return rowData.getObject(columnKey);\r\n        }\r\n        else {\r\n            return null;\r\n        }if (row >= 0) {\r\n        KeyedObjects rowData = (KeyedObjects) this.rows.get(row);\r\n            return rowData.getObject(columnKey);\r\n        }\r\n        else {\r\n            return null;\r\n        }"},{"entropy_rank":32,"patch_id":20,"patch_code":"if (row >= column && (row >= 0)) {\r\n        KeyedObjects rowData = (KeyedObjects) this.rows.get(row);\r\n            return rowData.getObject(columnKey);\r\n        }\r\n        else {\r\n            return null;\r\n        }if (row >= 0) {\r\n        KeyedObjects rowData = (KeyedObjects) this.rows.get(row);\r\n            return rowData.getObject(columnKey);\r\n        }\r\n        else {\r\n            return null;\r\n        }"},{"entropy_rank":34,"patch_id":64,"patch_code":"if (rowData == null) return new Object();\n\t return rowData.getObject(columnKey);return rowData.getObject(columnKey);"},{"entropy_rank":35,"patch_id":17,"patch_code":"if (row <= column || (row >= 0)) {\r\n        KeyedObjects rowData = (KeyedObjects) this.rows.get(row);\r\n            return rowData.getObject(columnKey);\r\n        }\r\n        else {\r\n            return null;\r\n        }if (row >= 0) {\r\n        KeyedObjects rowData = (KeyedObjects) this.rows.get(row);\r\n            return rowData.getObject(columnKey);\r\n        }\r\n        else {\r\n            return null;\r\n        }"},{"entropy_rank":36,"patch_id":19,"patch_code":"if (row > column || (row >= 0)) {\r\n        KeyedObjects rowData = (KeyedObjects) this.rows.get(row);\r\n            return rowData.getObject(columnKey);\r\n        }\r\n        else {\r\n            return null;\r\n        }if (row >= 0) {\r\n        KeyedObjects rowData = (KeyedObjects) this.rows.get(row);\r\n            return rowData.getObject(columnKey);\r\n        }\r\n        else {\r\n            return null;\r\n        }"},{"entropy_rank":37,"patch_id":2,"patch_code":"if (row!=0) {\r\n        KeyedObjects rowData = (KeyedObjects) this.rows.get(row);\r\n            return rowData.getObject(columnKey);\r\n        }\r\n        else {\r\n            return null;\r\n        }if (row >= 0) {\r\n        KeyedObjects rowData = (KeyedObjects) this.rows.get(row);\r\n            return rowData.getObject(columnKey);\r\n        }\r\n        else {\r\n            return null;\r\n        }"},{"entropy_rank":38,"patch_id":21,"patch_code":"if (row >= column || (row >= 0)) {\r\n        KeyedObjects rowData = (KeyedObjects) this.rows.get(row);\r\n            return rowData.getObject(columnKey);\r\n        }\r\n        else {\r\n            return null;\r\n        }if (row >= 0) {\r\n        KeyedObjects rowData = (KeyedObjects) this.rows.get(row);\r\n            return rowData.getObject(columnKey);\r\n        }\r\n        else {\r\n            return null;\r\n        }"},{"entropy_rank":39,"patch_id":3,"patch_code":"if (row<0) {\r\n        KeyedObjects rowData = (KeyedObjects) this.rows.get(row);\r\n            return rowData.getObject(columnKey);\r\n        }\r\n        else {\r\n            return null;\r\n        }if (row >= 0) {\r\n        KeyedObjects rowData = (KeyedObjects) this.rows.get(row);\r\n            return rowData.getObject(columnKey);\r\n        }\r\n        else {\r\n            return null;\r\n        }"},{"entropy_rank":40,"patch_id":63,"patch_code":"if (rowData == null) rowData = new KeyedObjects();\n return rowData.getObject(columnKey);return rowData.getObject(columnKey);"},{"entropy_rank":41,"patch_id":5,"patch_code":"if (row>0) {\r\n        KeyedObjects rowData = (KeyedObjects) this.rows.get(row);\r\n            return rowData.getObject(columnKey);\r\n        }\r\n        else {\r\n            return null;\r\n        }if (row >= 0) {\r\n        KeyedObjects rowData = (KeyedObjects) this.rows.get(row);\r\n            return rowData.getObject(columnKey);\r\n        }\r\n        else {\r\n            return null;\r\n        }"},{"entropy_rank":42,"patch_id":4,"patch_code":"if (row<=0) {\r\n        KeyedObjects rowData = (KeyedObjects) this.rows.get(row);\r\n            return rowData.getObject(columnKey);\r\n        }\r\n        else {\r\n            return null;\r\n        }if (row >= 0) {\r\n        KeyedObjects rowData = (KeyedObjects) this.rows.get(row);\r\n            return rowData.getObject(columnKey);\r\n        }\r\n        else {\r\n            return null;\r\n        }"},{"entropy_rank":45,"patch_id":61,"patch_code":"if (rowData == null) {\n\t    throw new IllegalArgumentException(\"Null 'rowData' argument.\");\n\t}\nreturn rowData.getObject(columnKey);return rowData.getObject(columnKey);"},{"entropy_rank":49,"patch_id":55,"patch_code":"return rowData.getObject(getRowCount());return rowData.getObject(columnKey);"}],"Chart_24":[{"entropy_rank":1,"patch_id":7,"patch_code":"int g = (int) ((v - this.lowerBound) \/ (this.upperBound \r\n                - this.lowerBound) * 255.0);int g = (int) ((value - this.lowerBound) \/ (this.upperBound \r\n                - this.lowerBound) * 255.0);"},{"entropy_rank":2,"patch_id":12,"patch_code":"int g = (int) ((getUpperBound() - this.lowerBound) \/ (this.upperBound \r\n                - this.lowerBound) * 255.0);int g = (int) ((value - this.lowerBound) \/ (this.upperBound \r\n                - this.lowerBound) * 255.0);"},{"entropy_rank":3,"patch_id":8,"patch_code":"int g = (int) ((value - v) \/ (this.upperBound \r\n                - this.lowerBound) * 255.0);int g = (int) ((value - this.lowerBound) \/ (this.upperBound \r\n                - this.lowerBound) * 255.0);"},{"entropy_rank":4,"patch_id":11,"patch_code":"int g = (int) ((getLowerBound() - this.lowerBound) \/ (this.upperBound \r\n                - this.lowerBound) * 255.0);int g = (int) ((value - this.lowerBound) \/ (this.upperBound \r\n                - this.lowerBound) * 255.0);"},{"entropy_rank":5,"patch_id":2,"patch_code":"float g = (int) ((value - this.lowerBound) \/ (this.upperBound \r\n                - this.lowerBound) * 255.0);int g = (int) ((value - this.lowerBound) \/ (this.upperBound \r\n                - this.lowerBound) * 255.0);"},{"entropy_rank":6,"patch_id":3,"patch_code":"long g = (int) ((value - this.lowerBound) \/ (this.upperBound \r\n                - this.lowerBound) * 255.0);int g = (int) ((value - this.lowerBound) \/ (this.upperBound \r\n                - this.lowerBound) * 255.0);"},{"entropy_rank":7,"patch_id":9,"patch_code":"int g = (int) ((value - this.lowerBound) \/ (v \r\n                - this.lowerBound) * 255.0);int g = (int) ((value - this.lowerBound) \/ (this.upperBound \r\n                - this.lowerBound) * 255.0);"},{"entropy_rank":8,"patch_id":10,"patch_code":"int g = (int) ((value - this.lowerBound) \/ (this.upperBound \r\n                - v) * 255.0);int g = (int) ((value - this.lowerBound) \/ (this.upperBound \r\n                - this.lowerBound) * 255.0);"}],"Chart_25":[{"entropy_rank":1,"patch_id":16,"patch_code":"if (meanValue == null) {\n\t    throw new IllegalArgumentException(\"Null 'meanValue' argument.\");\n\t}\ndouble value = meanValue.doubleValue();double value = meanValue.doubleValue();"},{"entropy_rank":3,"patch_id":17,"patch_code":"if (meanValue == null) {\n\t    return;\n\t}\ndouble value = meanValue.doubleValue();double value = meanValue.doubleValue();"},{"entropy_rank":4,"patch_id":33,"patch_code":"double valueDelta = dataset.getStdDevValue(seriesCount, column).doubleValue();double valueDelta = dataset.getStdDevValue(row, column).doubleValue();"},{"entropy_rank":5,"patch_id":96,"patch_code":"double valueDelta = dataset.getStdDevValue(column, categoryCount).doubleValue();double valueDelta = dataset.getStdDevValue(row, column).doubleValue();"},{"entropy_rank":6,"patch_id":50,"patch_code":"double valueDelta = dataset.getStdDevValue(categoryCount, categoryCount).doubleValue();double valueDelta = dataset.getStdDevValue(row, column).doubleValue();"},{"entropy_rank":9,"patch_id":73,"patch_code":"double valueDelta = dataset.getStdDevValue(seriesCount, categoryCount).doubleValue();double valueDelta = dataset.getStdDevValue(row, column).doubleValue();"},{"entropy_rank":14,"patch_id":62,"patch_code":"double valueDelta = dataset.getStdDevValue(categoryCount, lclip).doubleValue();double valueDelta = dataset.getStdDevValue(row, column).doubleValue();"},{"entropy_rank":15,"patch_id":34,"patch_code":"double valueDelta = dataset.getStdDevValue(categoryCount, column).doubleValue();double valueDelta = dataset.getStdDevValue(row, column).doubleValue();"},{"entropy_rank":18,"patch_id":85,"patch_code":"double valueDelta = dataset.getStdDevValue(seriesCount, lclip).doubleValue();double valueDelta = dataset.getStdDevValue(row, column).doubleValue();"},{"entropy_rank":22,"patch_id":61,"patch_code":"double valueDelta = dataset.getStdDevValue(categoryCount, uclip).doubleValue();double valueDelta = dataset.getStdDevValue(row, column).doubleValue();"},{"entropy_rank":24,"patch_id":59,"patch_code":"double valueDelta = dataset.getStdDevValue(categoryCount, transY2).doubleValue();double valueDelta = dataset.getStdDevValue(row, column).doubleValue();"},{"entropy_rank":25,"patch_id":60,"patch_code":"double valueDelta = dataset.getStdDevValue(categoryCount, transY1).doubleValue();double valueDelta = dataset.getStdDevValue(row, column).doubleValue();"},{"entropy_rank":25,"patch_id":58,"patch_code":"double valueDelta = dataset.getStdDevValue(categoryCount, rectX).doubleValue();double valueDelta = dataset.getStdDevValue(row, column).doubleValue();"},{"entropy_rank":27,"patch_id":57,"patch_code":"double valueDelta = dataset.getStdDevValue(categoryCount, rectHeight).doubleValue();double valueDelta = dataset.getStdDevValue(row, column).doubleValue();"},{"entropy_rank":28,"patch_id":83,"patch_code":"double valueDelta = dataset.getStdDevValue(seriesCount, transY1).doubleValue();double valueDelta = dataset.getStdDevValue(row, column).doubleValue();"},{"entropy_rank":28,"patch_id":84,"patch_code":"double valueDelta = dataset.getStdDevValue(seriesCount, uclip).doubleValue();double valueDelta = dataset.getStdDevValue(row, column).doubleValue();"},{"entropy_rank":30,"patch_id":82,"patch_code":"double valueDelta = dataset.getStdDevValue(seriesCount, transY2).doubleValue();double valueDelta = dataset.getStdDevValue(row, column).doubleValue();"},{"entropy_rank":32,"patch_id":63,"patch_code":"double valueDelta = dataset.getStdDevValue(categoryCount, base).doubleValue();double valueDelta = dataset.getStdDevValue(row, column).doubleValue();"},{"entropy_rank":33,"patch_id":56,"patch_code":"double valueDelta = dataset.getStdDevValue(categoryCount, rectWidth).doubleValue();double valueDelta = dataset.getStdDevValue(row, column).doubleValue();"},{"entropy_rank":33,"patch_id":81,"patch_code":"double valueDelta = dataset.getStdDevValue(seriesCount, rectX).doubleValue();double valueDelta = dataset.getStdDevValue(row, column).doubleValue();"},{"entropy_rank":35,"patch_id":80,"patch_code":"double valueDelta = dataset.getStdDevValue(seriesCount, rectHeight).doubleValue();double valueDelta = dataset.getStdDevValue(row, column).doubleValue();"},{"entropy_rank":38,"patch_id":86,"patch_code":"double valueDelta = dataset.getStdDevValue(seriesCount, base).doubleValue();double valueDelta = dataset.getStdDevValue(row, column).doubleValue();"},{"entropy_rank":39,"patch_id":79,"patch_code":"double valueDelta = dataset.getStdDevValue(seriesCount, rectWidth).doubleValue();double valueDelta = dataset.getStdDevValue(row, column).doubleValue();"}],"Chart_26":[{"entropy_rank":1,"patch_id":24,"patch_code":"if (owner != null) {\n\tEntityCollection entities = owner.getEntityCollection();\r\n                if (entities != null) {\r\n                    entities.add(new AxisLabelEntity(this, hotspot, \r\n                            this.labelToolTip, this.labelURL));\r\n                }\n\t}\nEntityCollection entities = owner.getEntityCollection();\r\n                if (entities != null) {\r\n                    entities.add(new AxisLabelEntity(this, hotspot, \r\n                            this.labelToolTip, this.labelURL));\r\n                }\n\t}\n"},{"entropy_rank":2,"patch_id":25,"patch_code":"if (owner == null) {\n\t    throw new IllegalArgumentException(\"Null 'owner' argument.\");\n\t}\nEntityCollection entities = owner.getEntityCollection();EntityCollection entities = owner.getEntityCollection();"},{"entropy_rank":3,"patch_id":27,"patch_code":"if (owner == null) owner = new ChartRenderingInfo();\n EntityCollection entities = owner.getEntityCollection();EntityCollection entities = owner.getEntityCollection();"},{"entropy_rank":4,"patch_id":26,"patch_code":"if (owner == null) {\n\t    return null;\n\t}\nEntityCollection entities = owner.getEntityCollection();EntityCollection entities = owner.getEntityCollection();"},{"entropy_rank":5,"patch_id":29,"patch_code":"if (owner == null) return state;\n\t EntityCollection entities = owner.getEntityCollection();EntityCollection entities = owner.getEntityCollection();"},{"entropy_rank":6,"patch_id":28,"patch_code":"if (owner == null) return new AxisState();\n\t EntityCollection entities = owner.getEntityCollection();EntityCollection entities = owner.getEntityCollection();"}],"Chart_4":[{"entropy_rank":1,"patch_id":70,"patch_code":"if (r != null) {\n\tCollection c = r.getAnnotations();\r\n                    Iterator i = c.iterator();\r\n                    while (i.hasNext()) {\r\n                        XYAnnotation a = (XYAnnotation) i.next();\r\n                        if (a instanceof XYAnnotationBoundsInfo) {\r\n                            includedAnnotations.add(a);\r\n                        }\r\n                    }\n\t}\nCollection c = r.getAnnotations();\r\n                    Iterator i = c.iterator();\r\n                    while (i.hasNext()) {\r\n                        XYAnnotation a = (XYAnnotation) i.next();\r\n                        if (a instanceof XYAnnotationBoundsInfo) {\r\n                            includedAnnotations.add(a);\r\n                        }\r\n                    }\n\t}\n"},{"entropy_rank":2,"patch_id":19,"patch_code":"Collection c = getRenderer().getAnnotations();Collection c = r.getAnnotations();"},{"entropy_rank":3,"patch_id":71,"patch_code":"if (r == null) {\n\t    throw new IllegalArgumentException(\"Null 'r' argument.\");\n\t}\nCollection c = r.getAnnotations();Collection c = r.getAnnotations();"},{"entropy_rank":4,"patch_id":76,"patch_code":"if (r == null) continue;\n\tCollection c = r.getAnnotations();Collection c = r.getAnnotations();"},{"entropy_rank":5,"patch_id":72,"patch_code":"if (r == null) {\n\t    return null;\n\t}\nCollection c = r.getAnnotations();Collection c = r.getAnnotations();"},{"entropy_rank":6,"patch_id":75,"patch_code":"if (r == null) return result;\n\t Collection c = r.getAnnotations();Collection c = r.getAnnotations();"}],"Chart_5":[],"Chart_7":[{"entropy_rank":1,"patch_id":1,"patch_code":"double s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\r\n                .getTime();\r\n            double e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\r\n                .getTime();\r\n            double maxMiddle = s + (e - s) \/ 2;long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\r\n                .getTime();\r\n            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\r\n                .getTime();\r\n            long maxMiddle = s + (e - s) \/ 2;"},{"entropy_rank":2,"patch_id":3,"patch_code":"float s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\r\n                .getTime();\r\n            float e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\r\n                .getTime();\r\n            float maxMiddle = s + (e - s) \/ 2;long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\r\n                .getTime();\r\n            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\r\n                .getTime();\r\n            long maxMiddle = s + (e - s) \/ 2;"},{"entropy_rank":3,"patch_id":13,"patch_code":"long s = getDataItem(this.maxMiddleIndex).getPeriod().getStart()\r\n                .getTime();long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\r\n                .getTime();"},{"entropy_rank":4,"patch_id":14,"patch_code":"long s = getDataItem(this.minEndIndex).getPeriod().getStart()\r\n                .getTime();long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\r\n                .getTime();"},{"entropy_rank":5,"patch_id":18,"patch_code":"long s = getDataItem(this.maxStartIndex).getPeriod().getStart()\r\n                .getTime();long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\r\n                .getTime();"},{"entropy_rank":6,"patch_id":16,"patch_code":"long s = getDataItem(this.minStartIndex).getPeriod().getStart()\r\n                .getTime();long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\r\n                .getTime();"},{"entropy_rank":7,"patch_id":15,"patch_code":"long s = getDataItem(this.maxEndIndex).getPeriod().getStart()\r\n                .getTime();long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\r\n                .getTime();"},{"entropy_rank":8,"patch_id":17,"patch_code":"long s = getDataItem(index).getPeriod().getStart()\r\n                .getTime();long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\r\n                .getTime();"}],"Chart_8":[{"entropy_rank":1,"patch_id":1,"patch_code":"this(time, zone, Locale.getDefault());this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());"}],"Chart_9":[{"entropy_rank":1,"patch_id":10,"patch_code":"if (endIndex < startIndex && (endIndex < 0)) {\r\n            emptyRange = true;\r\n        }if (endIndex < 0) {\r\n            emptyRange = true;\r\n        }"},{"entropy_rank":2,"patch_id":11,"patch_code":"if (endIndex < startIndex || (endIndex < 0)) {\r\n            emptyRange = true;\r\n        }if (endIndex < 0) {\r\n            emptyRange = true;\r\n        }"},{"entropy_rank":3,"patch_id":8,"patch_code":"if (endIndex == startIndex && (endIndex < 0)) {\r\n            emptyRange = true;\r\n        }if (endIndex < 0) {\r\n            emptyRange = true;\r\n        }"},{"entropy_rank":4,"patch_id":15,"patch_code":"if (endIndex > startIndex || (endIndex < 0)) {\r\n            emptyRange = true;\r\n        }if (endIndex < 0) {\r\n            emptyRange = true;\r\n        }"},{"entropy_rank":5,"patch_id":9,"patch_code":"if (endIndex == startIndex || (endIndex < 0)) {\r\n            emptyRange = true;\r\n        }if (endIndex < 0) {\r\n            emptyRange = true;\r\n        }"},{"entropy_rank":6,"patch_id":13,"patch_code":"if (endIndex <= startIndex || (endIndex < 0)) {\r\n            emptyRange = true;\r\n        }if (endIndex < 0) {\r\n            emptyRange = true;\r\n        }"},{"entropy_rank":7,"patch_id":7,"patch_code":"if (endIndex != startIndex || (endIndex < 0)) {\r\n            emptyRange = true;\r\n        }if (endIndex < 0) {\r\n            emptyRange = true;\r\n        }"},{"entropy_rank":8,"patch_id":17,"patch_code":"if (endIndex >= startIndex || (endIndex < 0)) {\r\n            emptyRange = true;\r\n        }if (endIndex < 0) {\r\n            emptyRange = true;\r\n        }"},{"entropy_rank":9,"patch_id":14,"patch_code":"if (endIndex > startIndex && (endIndex < 0)) {\r\n            emptyRange = true;\r\n        }if (endIndex < 0) {\r\n            emptyRange = true;\r\n        }"},{"entropy_rank":10,"patch_id":12,"patch_code":"if (endIndex <= startIndex && (endIndex < 0)) {\r\n            emptyRange = true;\r\n        }if (endIndex < 0) {\r\n            emptyRange = true;\r\n        }"},{"entropy_rank":11,"patch_id":6,"patch_code":"if (endIndex != startIndex && (endIndex < 0)) {\r\n            emptyRange = true;\r\n        }if (endIndex < 0) {\r\n            emptyRange = true;\r\n        }"},{"entropy_rank":12,"patch_id":16,"patch_code":"if (endIndex >= startIndex && (endIndex < 0)) {\r\n            emptyRange = true;\r\n        }if (endIndex < 0) {\r\n            emptyRange = true;\r\n        }"},{"entropy_rank":13,"patch_id":27,"patch_code":"if (endIndex > this.maximumItemCount || (endIndex < 0)) {\r\n            emptyRange = true;\r\n        }if (endIndex < 0) {\r\n            emptyRange = true;\r\n        }"},{"entropy_rank":14,"patch_id":29,"patch_code":"if (endIndex >= this.maximumItemCount || (endIndex < 0)) {\r\n            emptyRange = true;\r\n        }if (endIndex < 0) {\r\n            emptyRange = true;\r\n        }"},{"entropy_rank":15,"patch_id":26,"patch_code":"if (endIndex > this.maximumItemCount && (endIndex < 0)) {\r\n            emptyRange = true;\r\n        }if (endIndex < 0) {\r\n            emptyRange = true;\r\n        }"},{"entropy_rank":16,"patch_id":28,"patch_code":"if (endIndex >= this.maximumItemCount && (endIndex < 0)) {\r\n            emptyRange = true;\r\n        }if (endIndex < 0) {\r\n            emptyRange = true;\r\n        }"},{"entropy_rank":17,"patch_id":18,"patch_code":"if (endIndex != this.maximumItemCount && (endIndex < 0)) {\r\n            emptyRange = true;\r\n        }if (endIndex < 0) {\r\n            emptyRange = true;\r\n        }"},{"entropy_rank":18,"patch_id":21,"patch_code":"if (endIndex == this.maximumItemCount || (endIndex < 0)) {\r\n            emptyRange = true;\r\n        }if (endIndex < 0) {\r\n            emptyRange = true;\r\n        }"},{"entropy_rank":19,"patch_id":20,"patch_code":"if (endIndex == this.maximumItemCount && (endIndex < 0)) {\r\n            emptyRange = true;\r\n        }if (endIndex < 0) {\r\n            emptyRange = true;\r\n        }"},{"entropy_rank":20,"patch_id":1,"patch_code":"if (endIndex==0) {\r\n            emptyRange = true;\r\n        }if (endIndex < 0) {\r\n            emptyRange = true;\r\n        }"},{"entropy_rank":20,"patch_id":23,"patch_code":"if (endIndex < this.maximumItemCount || (endIndex < 0)) {\r\n            emptyRange = true;\r\n        }if (endIndex < 0) {\r\n            emptyRange = true;\r\n        }"},{"entropy_rank":22,"patch_id":25,"patch_code":"if (endIndex <= this.maximumItemCount || (endIndex < 0)) {\r\n            emptyRange = true;\r\n        }if (endIndex < 0) {\r\n            emptyRange = true;\r\n        }"},{"entropy_rank":23,"patch_id":19,"patch_code":"if (endIndex != this.maximumItemCount || (endIndex < 0)) {\r\n            emptyRange = true;\r\n        }if (endIndex < 0) {\r\n            emptyRange = true;\r\n        }"},{"entropy_rank":24,"patch_id":22,"patch_code":"if (endIndex < this.maximumItemCount && (endIndex < 0)) {\r\n            emptyRange = true;\r\n        }if (endIndex < 0) {\r\n            emptyRange = true;\r\n        }"},{"entropy_rank":25,"patch_id":4,"patch_code":"if (endIndex>0) {\r\n            emptyRange = true;\r\n        }if (endIndex < 0) {\r\n            emptyRange = true;\r\n        }"},{"entropy_rank":26,"patch_id":24,"patch_code":"if (endIndex <= this.maximumItemCount && (endIndex < 0)) {\r\n            emptyRange = true;\r\n        }if (endIndex < 0) {\r\n            emptyRange = true;\r\n        }"},{"entropy_rank":27,"patch_id":5,"patch_code":"if (endIndex>=0) {\r\n            emptyRange = true;\r\n        }if (endIndex < 0) {\r\n            emptyRange = true;\r\n        }"},{"entropy_rank":28,"patch_id":3,"patch_code":"if (endIndex<=0) {\r\n            emptyRange = true;\r\n        }if (endIndex < 0) {\r\n            emptyRange = true;\r\n        }"},{"entropy_rank":29,"patch_id":2,"patch_code":"if (endIndex!=0) {\r\n            emptyRange = true;\r\n        }if (endIndex < 0) {\r\n            emptyRange = true;\r\n        }"}],"Closure_10":[{"entropy_rank":5,"patch_id":49,"patch_code":"return (allResultsMatch(n, MAY_BE_STRING_PREDICATE)) || (isSimpleOperator(n));return allResultsMatch(n, MAY_BE_STRING_PREDICATE);"},{"entropy_rank":6,"patch_id":50,"patch_code":"return (allResultsMatch(n, MAY_BE_STRING_PREDICATE)) && (isSimpleOperator(n));return allResultsMatch(n, MAY_BE_STRING_PREDICATE);"},{"entropy_rank":9,"patch_id":21,"patch_code":"return (allResultsMatch(n, MAY_BE_STRING_PREDICATE)) || (!mayHaveSideEffects(n.getFirstChild()));return allResultsMatch(n, MAY_BE_STRING_PREDICATE);"},{"entropy_rank":15,"patch_id":65,"patch_code":"return (allResultsMatch(n, MAY_BE_STRING_PREDICATE)) || (!n.isScript());return allResultsMatch(n, MAY_BE_STRING_PREDICATE);"},{"entropy_rank":16,"patch_id":89,"patch_code":"return (allResultsMatch(n, MAY_BE_STRING_PREDICATE)) || (n.getChildCount() == 1);return allResultsMatch(n, MAY_BE_STRING_PREDICATE);"},{"entropy_rank":17,"patch_id":5,"patch_code":"return (allResultsMatch(n, MAY_BE_STRING_PREDICATE)) || (!n.isFunction());return allResultsMatch(n, MAY_BE_STRING_PREDICATE);"},{"entropy_rank":18,"patch_id":24,"patch_code":"return (allResultsMatch(n, MAY_BE_STRING_PREDICATE)) && !(!mayHaveSideEffects(n.getFirstChild()));return allResultsMatch(n, MAY_BE_STRING_PREDICATE);"},{"entropy_rank":21,"patch_id":41,"patch_code":"return (allResultsMatch(n, MAY_BE_STRING_PREDICATE)) || ((NodeUtil.isNullOrUndefined(n) || n.isEmpty()));return allResultsMatch(n, MAY_BE_STRING_PREDICATE);"},{"entropy_rank":22,"patch_id":51,"patch_code":"return (allResultsMatch(n, MAY_BE_STRING_PREDICATE)) || !(isSimpleOperator(n));return allResultsMatch(n, MAY_BE_STRING_PREDICATE);"},{"entropy_rank":23,"patch_id":22,"patch_code":"return (allResultsMatch(n, MAY_BE_STRING_PREDICATE)) && (!mayHaveSideEffects(n.getFirstChild()));return allResultsMatch(n, MAY_BE_STRING_PREDICATE);"},{"entropy_rank":23,"patch_id":23,"patch_code":"return (allResultsMatch(n, MAY_BE_STRING_PREDICATE)) || !(!mayHaveSideEffects(n.getFirstChild()));return allResultsMatch(n, MAY_BE_STRING_PREDICATE);"},{"entropy_rank":25,"patch_id":52,"patch_code":"return (allResultsMatch(n, MAY_BE_STRING_PREDICATE)) && !(isSimpleOperator(n));return allResultsMatch(n, MAY_BE_STRING_PREDICATE);"},{"entropy_rank":26,"patch_id":44,"patch_code":"return (allResultsMatch(n, MAY_BE_STRING_PREDICATE)) && !((NodeUtil.isNullOrUndefined(n) || n.isEmpty()));return allResultsMatch(n, MAY_BE_STRING_PREDICATE);"},{"entropy_rank":28,"patch_id":29,"patch_code":"return (allResultsMatch(n, MAY_BE_STRING_PREDICATE)) || (n.getChildCount() == 1 && n.getFirstChild().isName()\n            && n.getFirstChild().getString().equals(\"Infinity\"));return allResultsMatch(n, MAY_BE_STRING_PREDICATE);"},{"entropy_rank":29,"patch_id":66,"patch_code":"return (allResultsMatch(n, MAY_BE_STRING_PREDICATE)) && (!n.isScript());return allResultsMatch(n, MAY_BE_STRING_PREDICATE);"},{"entropy_rank":30,"patch_id":90,"patch_code":"return (allResultsMatch(n, MAY_BE_STRING_PREDICATE)) && (n.getChildCount() == 1);return allResultsMatch(n, MAY_BE_STRING_PREDICATE);"},{"entropy_rank":31,"patch_id":13,"patch_code":"return (allResultsMatch(n, MAY_BE_STRING_PREDICATE)) || (isAssignmentOp(n));return allResultsMatch(n, MAY_BE_STRING_PREDICATE);"},{"entropy_rank":32,"patch_id":43,"patch_code":"return (allResultsMatch(n, MAY_BE_STRING_PREDICATE)) || !((NodeUtil.isNullOrUndefined(n) || n.isEmpty()));return allResultsMatch(n, MAY_BE_STRING_PREDICATE);"},{"entropy_rank":33,"patch_id":37,"patch_code":"return (allResultsMatch(n, MAY_BE_STRING_PREDICATE)) || (NodeUtil.isFunctionExpression(n));return allResultsMatch(n, MAY_BE_STRING_PREDICATE);"},{"entropy_rank":34,"patch_id":6,"patch_code":"return (allResultsMatch(n, MAY_BE_STRING_PREDICATE)) && (!n.isFunction());return allResultsMatch(n, MAY_BE_STRING_PREDICATE);"},{"entropy_rank":35,"patch_id":30,"patch_code":"return (allResultsMatch(n, MAY_BE_STRING_PREDICATE)) && (n.getChildCount() == 1 && n.getFirstChild().isName()\n            && n.getFirstChild().getString().equals(\"Infinity\"));return allResultsMatch(n, MAY_BE_STRING_PREDICATE);"},{"entropy_rank":36,"patch_id":53,"patch_code":"return (allResultsMatch(n, MAY_BE_STRING_PREDICATE)) || (mayHaveSideEffects(n.getFirstChild()));return allResultsMatch(n, MAY_BE_STRING_PREDICATE);"},{"entropy_rank":37,"patch_id":14,"patch_code":"return (allResultsMatch(n, MAY_BE_STRING_PREDICATE)) && (isAssignmentOp(n));return allResultsMatch(n, MAY_BE_STRING_PREDICATE);"},{"entropy_rank":39,"patch_id":56,"patch_code":"return (allResultsMatch(n, MAY_BE_STRING_PREDICATE)) && !(mayHaveSideEffects(n.getFirstChild()));return allResultsMatch(n, MAY_BE_STRING_PREDICATE);"},{"entropy_rank":40,"patch_id":84,"patch_code":"return (allResultsMatch(n, MAY_BE_STRING_PREDICATE)) && !(n.getFirstChild().getString().equals(\"Infinity\"));return allResultsMatch(n, MAY_BE_STRING_PREDICATE);"},{"entropy_rank":41,"patch_id":54,"patch_code":"return (allResultsMatch(n, MAY_BE_STRING_PREDICATE)) && (mayHaveSideEffects(n.getFirstChild()));return allResultsMatch(n, MAY_BE_STRING_PREDICATE);"},{"entropy_rank":42,"patch_id":40,"patch_code":"return (allResultsMatch(n, MAY_BE_STRING_PREDICATE)) && !(NodeUtil.isFunctionExpression(n));return allResultsMatch(n, MAY_BE_STRING_PREDICATE);"},{"entropy_rank":43,"patch_id":55,"patch_code":"return (allResultsMatch(n, MAY_BE_STRING_PREDICATE)) || !(mayHaveSideEffects(n.getFirstChild()));return allResultsMatch(n, MAY_BE_STRING_PREDICATE);"},{"entropy_rank":45,"patch_id":81,"patch_code":"return (allResultsMatch(n, MAY_BE_STRING_PREDICATE)) || (n.getFirstChild().getString().equals(\"Infinity\"));return allResultsMatch(n, MAY_BE_STRING_PREDICATE);"},{"entropy_rank":46,"patch_id":42,"patch_code":"return (allResultsMatch(n, MAY_BE_STRING_PREDICATE)) && ((NodeUtil.isNullOrUndefined(n) || n.isEmpty()));return allResultsMatch(n, MAY_BE_STRING_PREDICATE);"},{"entropy_rank":47,"patch_id":39,"patch_code":"return (allResultsMatch(n, MAY_BE_STRING_PREDICATE)) || !(NodeUtil.isFunctionExpression(n));return allResultsMatch(n, MAY_BE_STRING_PREDICATE);"},{"entropy_rank":48,"patch_id":38,"patch_code":"return (allResultsMatch(n, MAY_BE_STRING_PREDICATE)) && (NodeUtil.isFunctionExpression(n));return allResultsMatch(n, MAY_BE_STRING_PREDICATE);"},{"entropy_rank":49,"patch_id":83,"patch_code":"return (allResultsMatch(n, MAY_BE_STRING_PREDICATE)) || !(n.getFirstChild().getString().equals(\"Infinity\"));return allResultsMatch(n, MAY_BE_STRING_PREDICATE);"},{"entropy_rank":50,"patch_id":67,"patch_code":"return (allResultsMatch(n, MAY_BE_STRING_PREDICATE)) || !(!n.isScript());return allResultsMatch(n, MAY_BE_STRING_PREDICATE);"},{"entropy_rank":51,"patch_id":68,"patch_code":"return (allResultsMatch(n, MAY_BE_STRING_PREDICATE)) && !(!n.isScript());return allResultsMatch(n, MAY_BE_STRING_PREDICATE);"},{"entropy_rank":51,"patch_id":7,"patch_code":"return (allResultsMatch(n, MAY_BE_STRING_PREDICATE)) || !(!n.isFunction());return allResultsMatch(n, MAY_BE_STRING_PREDICATE);"},{"entropy_rank":53,"patch_id":69,"patch_code":"return (allResultsMatch(n, MAY_BE_STRING_PREDICATE)) || ((n.isFunction()));return allResultsMatch(n, MAY_BE_STRING_PREDICATE);"},{"entropy_rank":54,"patch_id":33,"patch_code":"return (allResultsMatch(n, MAY_BE_STRING_PREDICATE)) || (!mayHaveSideEffects(n));return allResultsMatch(n, MAY_BE_STRING_PREDICATE);"},{"entropy_rank":55,"patch_id":31,"patch_code":"return (allResultsMatch(n, MAY_BE_STRING_PREDICATE)) || !(n.getChildCount() == 1 && n.getFirstChild().isName()\n            && n.getFirstChild().getString().equals(\"Infinity\"));return allResultsMatch(n, MAY_BE_STRING_PREDICATE);"},{"entropy_rank":56,"patch_id":8,"patch_code":"return (allResultsMatch(n, MAY_BE_STRING_PREDICATE)) && !(!n.isFunction());return allResultsMatch(n, MAY_BE_STRING_PREDICATE);"},{"entropy_rank":57,"patch_id":82,"patch_code":"return (allResultsMatch(n, MAY_BE_STRING_PREDICATE)) && (n.getFirstChild().getString().equals(\"Infinity\"));return allResultsMatch(n, MAY_BE_STRING_PREDICATE);"},{"entropy_rank":58,"patch_id":32,"patch_code":"return (allResultsMatch(n, MAY_BE_STRING_PREDICATE)) && !(n.getChildCount() == 1 && n.getFirstChild().isName()\n            && n.getFirstChild().getString().equals(\"Infinity\"));return allResultsMatch(n, MAY_BE_STRING_PREDICATE);"},{"entropy_rank":59,"patch_id":15,"patch_code":"return (allResultsMatch(n, MAY_BE_STRING_PREDICATE)) || !(isAssignmentOp(n));return allResultsMatch(n, MAY_BE_STRING_PREDICATE);"},{"entropy_rank":60,"patch_id":16,"patch_code":"return (allResultsMatch(n, MAY_BE_STRING_PREDICATE)) && !(isAssignmentOp(n));return allResultsMatch(n, MAY_BE_STRING_PREDICATE);"},{"entropy_rank":61,"patch_id":72,"patch_code":"return (allResultsMatch(n, MAY_BE_STRING_PREDICATE)) && !((n.isFunction()));return allResultsMatch(n, MAY_BE_STRING_PREDICATE);"},{"entropy_rank":62,"patch_id":71,"patch_code":"return (allResultsMatch(n, MAY_BE_STRING_PREDICATE)) || !((n.isFunction()));return allResultsMatch(n, MAY_BE_STRING_PREDICATE);"},{"entropy_rank":63,"patch_id":34,"patch_code":"return (allResultsMatch(n, MAY_BE_STRING_PREDICATE)) && (!mayHaveSideEffects(n));return allResultsMatch(n, MAY_BE_STRING_PREDICATE);"},{"entropy_rank":64,"patch_id":70,"patch_code":"return (allResultsMatch(n, MAY_BE_STRING_PREDICATE)) && ((n.isFunction()));return allResultsMatch(n, MAY_BE_STRING_PREDICATE);"},{"entropy_rank":65,"patch_id":35,"patch_code":"return (allResultsMatch(n, MAY_BE_STRING_PREDICATE)) || !(!mayHaveSideEffects(n));return allResultsMatch(n, MAY_BE_STRING_PREDICATE);"},{"entropy_rank":66,"patch_id":36,"patch_code":"return (allResultsMatch(n, MAY_BE_STRING_PREDICATE)) && !(!mayHaveSideEffects(n));return allResultsMatch(n, MAY_BE_STRING_PREDICATE);"}],"Closure_102":[{"entropy_rank":1,"patch_id":8,"patch_code":"if (root == null) {\n\t    throw new IllegalArgumentException(\"Null 'root' argument.\");\n\t}\nremoveDuplicateDeclarations(root);removeDuplicateDeclarations(root);"},{"entropy_rank":2,"patch_id":9,"patch_code":"if (root == null) {\n\t    return;\n\t}\nremoveDuplicateDeclarations(root);removeDuplicateDeclarations(root);"},{"entropy_rank":3,"patch_id":3,"patch_code":"splitVarDeclarations(root);removeDuplicateDeclarations(root);"},{"entropy_rank":4,"patch_id":12,"patch_code":"removeDuplicateDeclarations(root);\n\tNodeTraversal.traverse(compiler, root, this);\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n      MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n      NodeTraversal t = new NodeTraversal(compiler, renamer);\n      t.traverseRoots(externs, root);\n    }\n    "},{"entropy_rank":5,"patch_id":6,"patch_code":"removeDuplicateDeclarations(externs);removeDuplicateDeclarations(root);"},{"entropy_rank":6,"patch_id":13,"patch_code":"removeDuplicateDeclarations(root);\n\tif (MAKE_LOCAL_NAMES_UNIQUE) {\n      MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n      NodeTraversal t = new NodeTraversal(compiler, renamer);\n      t.traverseRoots(externs, root);\n    }\n    "},{"entropy_rank":7,"patch_id":2,"patch_code":"normalizeLabels(root);removeDuplicateDeclarations(root);"},{"entropy_rank":8,"patch_id":10,"patch_code":"if (root == null) root = externs;\n removeDuplicateDeclarations(root);removeDuplicateDeclarations(root);"},{"entropy_rank":9,"patch_id":4,"patch_code":"moveNamedFunctions(root);removeDuplicateDeclarations(root);"},{"entropy_rank":10,"patch_id":7,"patch_code":"if (root != null) {\n\tremoveDuplicateDeclarations(root);\n\t}\nremoveDuplicateDeclarations(root);\n\t}\n"},{"entropy_rank":11,"patch_id":14,"patch_code":"\n    new PropogateConstantAnnotations(compiler, assertOnChange)\n        .process(externs, root);\n\tremoveDuplicateDeclarations(root);\n"}],"Closure_106":[{"entropy_rank":1,"patch_id":21,"patch_code":"if (hasAnySingletonTypeTags()) {\n    populated = true;\n    }if (parseDocumentation) {\n    populated = true;\n    }"},{"entropy_rank":2,"patch_id":4,"patch_code":"if (isDescriptionRecorded()) {\n    populated = true;\n    }if (parseDocumentation) {\n    populated = true;\n    }"},{"entropy_rank":3,"patch_id":20,"patch_code":"if (hasAnyTypeRelatedTags()) {\n    populated = true;\n    }if (parseDocumentation) {\n    populated = true;\n    }"},{"entropy_rank":4,"patch_id":2,"patch_code":"if (isPopulated()) {\n    populated = true;\n    }if (parseDocumentation) {\n    populated = true;\n    }"},{"entropy_rank":5,"patch_id":9,"patch_code":"if (isConstructorRecorded()) {\n    populated = true;\n    }if (parseDocumentation) {\n    populated = true;\n    }"},{"entropy_rank":6,"patch_id":19,"patch_code":"if (isInterfaceRecorded()) {\n    populated = true;\n    }if (parseDocumentation) {\n    populated = true;\n    }"},{"entropy_rank":7,"patch_id":1,"patch_code":"if (this.populated) {\n    populated = true;\n    }if (parseDocumentation) {\n    populated = true;\n    }"},{"entropy_rank":8,"patch_id":3,"patch_code":"if (isPopulatedWithFileOverview()) {\n    populated = true;\n    }if (parseDocumentation) {\n    populated = true;\n    }"},{"entropy_rank":9,"patch_id":13,"patch_code":"if (recordDeprecated()) {\n    populated = true;\n    }if (parseDocumentation) {\n    populated = true;\n    }"},{"entropy_rank":10,"patch_id":18,"patch_code":"if (recordNoSideEffects()) {\n    populated = true;\n    }if (parseDocumentation) {\n    populated = true;\n    }"},{"entropy_rank":11,"patch_id":8,"patch_code":"if (recordConstructor()) {\n    populated = true;\n    }if (parseDocumentation) {\n    populated = true;\n    }"},{"entropy_rank":12,"patch_id":10,"patch_code":"if (recordPreserveTry()) {\n    populated = true;\n    }if (parseDocumentation) {\n    populated = true;\n    }"},{"entropy_rank":13,"patch_id":7,"patch_code":"if (recordNoTypeCheck()) {\n    populated = true;\n    }if (parseDocumentation) {\n    populated = true;\n    }"},{"entropy_rank":14,"patch_id":5,"patch_code":"if (recordConstancy()) {\n    populated = true;\n    }if (parseDocumentation) {\n    populated = true;\n    }"},{"entropy_rank":15,"patch_id":11,"patch_code":"if (recordOverride()) {\n    populated = true;\n    }if (parseDocumentation) {\n    populated = true;\n    }"},{"entropy_rank":16,"patch_id":17,"patch_code":"if (recordImplicitCast()) {\n    populated = true;\n    }if (parseDocumentation) {\n    populated = true;\n    }"},{"entropy_rank":17,"patch_id":14,"patch_code":"if (recordInterface()) {\n    populated = true;\n    }if (parseDocumentation) {\n    populated = true;\n    }"},{"entropy_rank":18,"patch_id":12,"patch_code":"if (recordNoAlias()) {\n    populated = true;\n    }if (parseDocumentation) {\n    populated = true;\n    }"},{"entropy_rank":19,"patch_id":6,"patch_code":"if (recordHiddenness()) {\n    populated = true;\n    }if (parseDocumentation) {\n    populated = true;\n    }"},{"entropy_rank":20,"patch_id":15,"patch_code":"if (recordExport()) {\n    populated = true;\n    }if (parseDocumentation) {\n    populated = true;\n    }"},{"entropy_rank":21,"patch_id":16,"patch_code":"if (recordNoShadow()) {\n    populated = true;\n    }if (parseDocumentation) {\n    populated = true;\n    }"}],"Closure_109":[{"entropy_rank":1,"patch_id":24,"patch_code":"return parseContextTypeExpression(token);return parseTypeName(token);"},{"entropy_rank":2,"patch_id":25,"patch_code":"return parseBasicTypeExpression(token);return parseTypeName(token);"},{"entropy_rank":3,"patch_id":21,"patch_code":"return parseTopLevelTypeExpression(token);return parseTypeName(token);"},{"entropy_rank":4,"patch_id":22,"patch_code":"return parseTypeExpressionList(token);return parseTypeName(token);"},{"entropy_rank":5,"patch_id":23,"patch_code":"return parseTypeExpression(token);return parseTypeName(token);"},{"entropy_rank":6,"patch_id":26,"patch_code":"return parseFunctionType(token);return parseTypeName(token);"},{"entropy_rank":7,"patch_id":31,"patch_code":"return parseRecordType(token);return parseTypeName(token);"},{"entropy_rank":8,"patch_id":30,"patch_code":"return parseArrayType(token);return parseTypeName(token);"},{"entropy_rank":9,"patch_id":18,"patch_code":"return parseTypeExpressionAnnotation(token);return parseTypeName(token);"},{"entropy_rank":10,"patch_id":29,"patch_code":"return parseUnionType(token);return parseTypeName(token);"},{"entropy_rank":11,"patch_id":33,"patch_code":"return parseFieldType(token);return parseTypeName(token);"},{"entropy_rank":12,"patch_id":20,"patch_code":"return parseTypeNameAnnotation(token);return parseTypeName(token);"},{"entropy_rank":13,"patch_id":32,"patch_code":"return parseFieldTypeList(token);return parseTypeName(token);"},{"entropy_rank":14,"patch_id":19,"patch_code":"return parseParamTypeExpressionAnnotation(token);return parseTypeName(token);"},{"entropy_rank":15,"patch_id":34,"patch_code":"return parseFieldName(token);return parseTypeName(token);"},{"entropy_rank":16,"patch_id":16,"patch_code":"return parseAndRecordTypeNode(token);return parseTypeName(token);"},{"entropy_rank":17,"patch_id":28,"patch_code":"return parseResultType(token);return parseTypeName(token);"},{"entropy_rank":18,"patch_id":27,"patch_code":"return parseParametersType(token);return parseTypeName(token);"},{"entropy_rank":19,"patch_id":17,"patch_code":"return parseAndRecordParamTypeNode(token);return parseTypeName(token);"}],"Closure_11":[{"entropy_rank":1,"patch_id":1,"patch_code":"if (n.getJSType() == null && parent.isAssign()) {\n      return;\n    } else if (validator.expectNotNullOrUndefined(t, n, childType,\n        \"No properties on this expression\", getNativeType(OBJECT_TYPE))) {\n      checkPropertyAccess(childType, property.getString(), t, n);\n    }if (n.getJSType() != null && parent.isAssign()) {\n      return;\n    } else if (validator.expectNotNullOrUndefined(t, n, childType,\n        \"No properties on this expression\", getNativeType(OBJECT_TYPE))) {\n      checkPropertyAccess(childType, property.getString(), t, n);\n    }"}],"Closure_115":[{"entropy_rank":1,"patch_id":128,"patch_code":"Node block = fnNode.getLastChild();\n\tmaybePrepareCall(fnNode);Node block = fnNode.getLastChild();"},{"entropy_rank":2,"patch_id":5,"patch_code":"if (fnNode == null) {\n\t    throw new IllegalArgumentException(\"Null 'fnNode' argument.\");\n\t}\nNode block = fnNode.getLastChild();Node block = fnNode.getLastChild();"},{"entropy_rank":4,"patch_id":6,"patch_code":"if (fnNode == null) {\n\t    return null;\n\t}\nNode block = fnNode.getLastChild();Node block = fnNode.getLastChild();"},{"entropy_rank":5,"patch_id":1,"patch_code":"Node block = callNode.getLastChild();Node block = fnNode.getLastChild();"},{"entropy_rank":6,"patch_id":21,"patch_code":"Node block = fnNode.getParent();Node block = fnNode.getLastChild();"},{"entropy_rank":7,"patch_id":18,"patch_code":"Node block = fnNode.getFirstChild();Node block = fnNode.getLastChild();"},{"entropy_rank":9,"patch_id":19,"patch_code":"Node block = fnNode.getNext();Node block = fnNode.getLastChild();"},{"entropy_rank":10,"patch_id":23,"patch_code":"Node block = fnNode.removeFirstChild();Node block = fnNode.getLastChild();"},{"entropy_rank":11,"patch_id":24,"patch_code":"Node block = fnNode.removeChildren();Node block = fnNode.getLastChild();"},{"entropy_rank":12,"patch_id":8,"patch_code":"if (fnNode == null) fnNode = callNode;\n Node block = fnNode.getLastChild();Node block = fnNode.getLastChild();"},{"entropy_rank":13,"patch_id":26,"patch_code":"Node block = fnNode.cloneTree();Node block = fnNode.getLastChild();"},{"entropy_rank":14,"patch_id":20,"patch_code":"Node block = fnNode.getLastSibling();Node block = fnNode.getLastChild();"},{"entropy_rank":15,"patch_id":22,"patch_code":"Node block = fnNode.detachFromParent();Node block = fnNode.getLastChild();"},{"entropy_rank":16,"patch_id":25,"patch_code":"Node block = fnNode.cloneNode();Node block = fnNode.getLastChild();"},{"entropy_rank":17,"patch_id":127,"patch_code":"maybePrepareCall(fnNode);\n\tNode block = fnNode.getLastChild();Node block = fnNode.getLastChild();"}],"Closure_125":[{"entropy_rank":1,"patch_id":4,"patch_code":"visitParameterList(t, n, fnType);\n        ensureTyped(t, n, fnType.getInstanceType());if (fnType != null) {\n        visitParameterList(t, n, fnType);\n        ensureTyped(t, n, fnType.getInstanceType());\n      } else {\n        ensureTyped(t, n);\n      }"},{"entropy_rank":2,"patch_id":3,"patch_code":"ensureTyped(t, n);if (fnType != null) {\n        visitParameterList(t, n, fnType);\n        ensureTyped(t, n, fnType.getInstanceType());\n      } else {\n        ensureTyped(t, n);\n      }"},{"entropy_rank":3,"patch_id":1,"patch_code":"if (fnType == null) {\n        visitParameterList(t, n, fnType);\n        ensureTyped(t, n, fnType.getInstanceType());\n      } else {\n        ensureTyped(t, n);\n      }if (fnType != null) {\n        visitParameterList(t, n, fnType);\n        ensureTyped(t, n, fnType.getInstanceType());\n      } else {\n        ensureTyped(t, n);\n      }"},{"entropy_rank":4,"patch_id":5,"patch_code":"if (fnType != null) {\n        visitParameterList(t, n, fnType);\n        ensureTyped(t, n, fnType.getInstanceType());\n      } else {\n        ensureTyped(t, n);\n      }"}],"Closure_126":[{"entropy_rank":1,"patch_id":9,"patch_code":"if ((NodeUtil.hasFinally(n)) || (n.isLabel())) {\n        Node finallyBlock = n.getLastChild();\n        tryMinimizeExits(finallyBlock, exitType, labelName);\n      }if (NodeUtil.hasFinally(n)) {\n        Node finallyBlock = n.getLastChild();\n        tryMinimizeExits(finallyBlock, exitType, labelName);\n      }"},{"entropy_rank":2,"patch_id":12,"patch_code":"if ((NodeUtil.hasFinally(n)) && !(n.isLabel())) {\n        Node finallyBlock = n.getLastChild();\n        tryMinimizeExits(finallyBlock, exitType, labelName);\n      }if (NodeUtil.hasFinally(n)) {\n        Node finallyBlock = n.getLastChild();\n        tryMinimizeExits(finallyBlock, exitType, labelName);\n      }"},{"entropy_rank":3,"patch_id":10,"patch_code":"if ((NodeUtil.hasFinally(n)) && (n.isLabel())) {\n        Node finallyBlock = n.getLastChild();\n        tryMinimizeExits(finallyBlock, exitType, labelName);\n      }if (NodeUtil.hasFinally(n)) {\n        Node finallyBlock = n.getLastChild();\n        tryMinimizeExits(finallyBlock, exitType, labelName);\n      }"},{"entropy_rank":5,"patch_id":11,"patch_code":"if ((NodeUtil.hasFinally(n)) || !(n.isLabel())) {\n        Node finallyBlock = n.getLastChild();\n        tryMinimizeExits(finallyBlock, exitType, labelName);\n      }if (NodeUtil.hasFinally(n)) {\n        Node finallyBlock = n.getLastChild();\n        tryMinimizeExits(finallyBlock, exitType, labelName);\n      }"},{"entropy_rank":6,"patch_id":16,"patch_code":"if ((NodeUtil.hasFinally(n)) && !(n.isTry())) {\n        Node finallyBlock = n.getLastChild();\n        tryMinimizeExits(finallyBlock, exitType, labelName);\n      }if (NodeUtil.hasFinally(n)) {\n        Node finallyBlock = n.getLastChild();\n        tryMinimizeExits(finallyBlock, exitType, labelName);\n      }"},{"entropy_rank":8,"patch_id":13,"patch_code":"if ((NodeUtil.hasFinally(n)) || (n.isTry())) {\n        Node finallyBlock = n.getLastChild();\n        tryMinimizeExits(finallyBlock, exitType, labelName);\n      }if (NodeUtil.hasFinally(n)) {\n        Node finallyBlock = n.getLastChild();\n        tryMinimizeExits(finallyBlock, exitType, labelName);\n      }"},{"entropy_rank":9,"patch_id":14,"patch_code":"if ((NodeUtil.hasFinally(n)) && (n.isTry())) {\n        Node finallyBlock = n.getLastChild();\n        tryMinimizeExits(finallyBlock, exitType, labelName);\n      }if (NodeUtil.hasFinally(n)) {\n        Node finallyBlock = n.getLastChild();\n        tryMinimizeExits(finallyBlock, exitType, labelName);\n      }"},{"entropy_rank":10,"patch_id":1,"patch_code":"if ((NodeUtil.hasFinally(n)) || (matchingExitNode(n, exitType, labelName))) {\n        Node finallyBlock = n.getLastChild();\n        tryMinimizeExits(finallyBlock, exitType, labelName);\n      }if (NodeUtil.hasFinally(n)) {\n        Node finallyBlock = n.getLastChild();\n        tryMinimizeExits(finallyBlock, exitType, labelName);\n      }"},{"entropy_rank":11,"patch_id":5,"patch_code":"if ((NodeUtil.hasFinally(n)) || (n.isIf())) {\n        Node finallyBlock = n.getLastChild();\n        tryMinimizeExits(finallyBlock, exitType, labelName);\n      }if (NodeUtil.hasFinally(n)) {\n        Node finallyBlock = n.getLastChild();\n        tryMinimizeExits(finallyBlock, exitType, labelName);\n      }"},{"entropy_rank":12,"patch_id":8,"patch_code":"if ((NodeUtil.hasFinally(n)) && !(n.isIf())) {\n        Node finallyBlock = n.getLastChild();\n        tryMinimizeExits(finallyBlock, exitType, labelName);\n      }if (NodeUtil.hasFinally(n)) {\n        Node finallyBlock = n.getLastChild();\n        tryMinimizeExits(finallyBlock, exitType, labelName);\n      }"},{"entropy_rank":13,"patch_id":4,"patch_code":"if ((NodeUtil.hasFinally(n)) && !(matchingExitNode(n, exitType, labelName))) {\n        Node finallyBlock = n.getLastChild();\n        tryMinimizeExits(finallyBlock, exitType, labelName);\n      }if (NodeUtil.hasFinally(n)) {\n        Node finallyBlock = n.getLastChild();\n        tryMinimizeExits(finallyBlock, exitType, labelName);\n      }"},{"entropy_rank":14,"patch_id":6,"patch_code":"if ((NodeUtil.hasFinally(n)) && (n.isIf())) {\n        Node finallyBlock = n.getLastChild();\n        tryMinimizeExits(finallyBlock, exitType, labelName);\n      }if (NodeUtil.hasFinally(n)) {\n        Node finallyBlock = n.getLastChild();\n        tryMinimizeExits(finallyBlock, exitType, labelName);\n      }"},{"entropy_rank":15,"patch_id":2,"patch_code":"if ((NodeUtil.hasFinally(n)) && (matchingExitNode(n, exitType, labelName))) {\n        Node finallyBlock = n.getLastChild();\n        tryMinimizeExits(finallyBlock, exitType, labelName);\n      }if (NodeUtil.hasFinally(n)) {\n        Node finallyBlock = n.getLastChild();\n        tryMinimizeExits(finallyBlock, exitType, labelName);\n      }"},{"entropy_rank":16,"patch_id":29,"patch_code":"if (n != allCatchNodes && (NodeUtil.hasFinally(n))) {\n        Node finallyBlock = n.getLastChild();\n        tryMinimizeExits(finallyBlock, exitType, labelName);\n      }if (NodeUtil.hasFinally(n)) {\n        Node finallyBlock = n.getLastChild();\n        tryMinimizeExits(finallyBlock, exitType, labelName);\n      }"},{"entropy_rank":17,"patch_id":15,"patch_code":"if ((NodeUtil.hasFinally(n)) || !(n.isTry())) {\n        Node finallyBlock = n.getLastChild();\n        tryMinimizeExits(finallyBlock, exitType, labelName);\n      }if (NodeUtil.hasFinally(n)) {\n        Node finallyBlock = n.getLastChild();\n        tryMinimizeExits(finallyBlock, exitType, labelName);\n      }"},{"entropy_rank":19,"patch_id":33,"patch_code":"if (n != tryBlock && (NodeUtil.hasFinally(n))) {\n        Node finallyBlock = n.getLastChild();\n        tryMinimizeExits(finallyBlock, exitType, labelName);\n      }if (NodeUtil.hasFinally(n)) {\n        Node finallyBlock = n.getLastChild();\n        tryMinimizeExits(finallyBlock, exitType, labelName);\n      }"},{"entropy_rank":20,"patch_id":7,"patch_code":"if ((NodeUtil.hasFinally(n)) || !(n.isIf())) {\n        Node finallyBlock = n.getLastChild();\n        tryMinimizeExits(finallyBlock, exitType, labelName);\n      }if (NodeUtil.hasFinally(n)) {\n        Node finallyBlock = n.getLastChild();\n        tryMinimizeExits(finallyBlock, exitType, labelName);\n      }"},{"entropy_rank":21,"patch_id":3,"patch_code":"if ((NodeUtil.hasFinally(n)) || !(matchingExitNode(n, exitType, labelName))) {\n        Node finallyBlock = n.getLastChild();\n        tryMinimizeExits(finallyBlock, exitType, labelName);\n      }if (NodeUtil.hasFinally(n)) {\n        Node finallyBlock = n.getLastChild();\n        tryMinimizeExits(finallyBlock, exitType, labelName);\n      }"},{"entropy_rank":23,"patch_id":30,"patch_code":"if (n != allCatchNodes || (NodeUtil.hasFinally(n))) {\n        Node finallyBlock = n.getLastChild();\n        tryMinimizeExits(finallyBlock, exitType, labelName);\n      }if (NodeUtil.hasFinally(n)) {\n        Node finallyBlock = n.getLastChild();\n        tryMinimizeExits(finallyBlock, exitType, labelName);\n      }"},{"entropy_rank":24,"patch_id":32,"patch_code":"if (n == allCatchNodes || (NodeUtil.hasFinally(n))) {\n        Node finallyBlock = n.getLastChild();\n        tryMinimizeExits(finallyBlock, exitType, labelName);\n      }if (NodeUtil.hasFinally(n)) {\n        Node finallyBlock = n.getLastChild();\n        tryMinimizeExits(finallyBlock, exitType, labelName);\n      }"},{"entropy_rank":25,"patch_id":31,"patch_code":"if (n == allCatchNodes && (NodeUtil.hasFinally(n))) {\n        Node finallyBlock = n.getLastChild();\n        tryMinimizeExits(finallyBlock, exitType, labelName);\n      }if (NodeUtil.hasFinally(n)) {\n        Node finallyBlock = n.getLastChild();\n        tryMinimizeExits(finallyBlock, exitType, labelName);\n      }"},{"entropy_rank":26,"patch_id":34,"patch_code":"if (n != tryBlock || (NodeUtil.hasFinally(n))) {\n        Node finallyBlock = n.getLastChild();\n        tryMinimizeExits(finallyBlock, exitType, labelName);\n      }if (NodeUtil.hasFinally(n)) {\n        Node finallyBlock = n.getLastChild();\n        tryMinimizeExits(finallyBlock, exitType, labelName);\n      }"},{"entropy_rank":27,"patch_id":35,"patch_code":"if (n == tryBlock && (NodeUtil.hasFinally(n))) {\n        Node finallyBlock = n.getLastChild();\n        tryMinimizeExits(finallyBlock, exitType, labelName);\n      }if (NodeUtil.hasFinally(n)) {\n        Node finallyBlock = n.getLastChild();\n        tryMinimizeExits(finallyBlock, exitType, labelName);\n      }"},{"entropy_rank":28,"patch_id":36,"patch_code":"if (n == tryBlock || (NodeUtil.hasFinally(n))) {\n        Node finallyBlock = n.getLastChild();\n        tryMinimizeExits(finallyBlock, exitType, labelName);\n      }if (NodeUtil.hasFinally(n)) {\n        Node finallyBlock = n.getLastChild();\n        tryMinimizeExits(finallyBlock, exitType, labelName);\n      }"}],"Closure_13":[{"entropy_rank":1,"patch_id":4,"patch_code":"visit(c);traverse(c);"},{"entropy_rank":2,"patch_id":3,"patch_code":"exitNode(c);traverse(c);"},{"entropy_rank":3,"patch_id":2,"patch_code":"shouldVisit(c);traverse(c);"},{"entropy_rank":4,"patch_id":6,"patch_code":"traverse(node);traverse(c);"},{"entropy_rank":5,"patch_id":1,"patch_code":"shouldRetraverse(c);traverse(c);"},{"entropy_rank":6,"patch_id":10,"patch_code":"\n        Node next = c.getNext();\n\ttraverse(c);\n"},{"entropy_rank":7,"patch_id":11,"patch_code":"\n        Node next = c.getNext();\n        c = next;\n\ttraverse(c);\n"}],"Closure_18":[{"entropy_rank":1,"patch_id":3,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) || !(options.getTweakProcessing().shouldStrip() ||\n        !options.stripTypes.isEmpty() ||\n        !options.stripNameSuffixes.isEmpty() ||\n        !options.stripTypePrefixes.isEmpty() ||\n        !options.stripNamePrefixes.isEmpty())) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":2,"patch_id":2,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) && (options.getTweakProcessing().shouldStrip() ||\n        !options.stripTypes.isEmpty() ||\n        !options.stripNameSuffixes.isEmpty() ||\n        !options.stripTypePrefixes.isEmpty() ||\n        !options.stripNamePrefixes.isEmpty())) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":3,"patch_id":4,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) && !(options.getTweakProcessing().shouldStrip() ||\n        !options.stripTypes.isEmpty() ||\n        !options.stripNameSuffixes.isEmpty() ||\n        !options.stripTypePrefixes.isEmpty() ||\n        !options.stripNamePrefixes.isEmpty())) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":4,"patch_id":1,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) || (options.getTweakProcessing().shouldStrip() ||\n        !options.stripTypes.isEmpty() ||\n        !options.stripNameSuffixes.isEmpty() ||\n        !options.stripTypePrefixes.isEmpty() ||\n        !options.stripNamePrefixes.isEmpty())) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":5,"patch_id":83,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) || !(!options.checkSymbols)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":6,"patch_id":84,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) && !(!options.checkSymbols)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":7,"patch_id":82,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) && (!options.checkSymbols)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":10,"patch_id":81,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) || (!options.checkSymbols)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":13,"patch_id":47,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) || !(options.enables(DiagnosticGroups.CHECK_TYPES))) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":14,"patch_id":45,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) || (options.enables(DiagnosticGroups.CHECK_TYPES))) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":15,"patch_id":46,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) && (options.enables(DiagnosticGroups.CHECK_TYPES))) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":16,"patch_id":31,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) || !(options.checkGlobalThisLevel.isOn() &&\n        !options.disables(DiagnosticGroups.GLOBAL_THIS))) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":17,"patch_id":29,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) || (options.checkGlobalThisLevel.isOn() &&\n        !options.disables(DiagnosticGroups.GLOBAL_THIS))) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":18,"patch_id":48,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) && !(options.enables(DiagnosticGroups.CHECK_TYPES))) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":19,"patch_id":57,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) || (options.removeTryCatchFinally)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":19,"patch_id":65,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) || (options.disambiguateProperties)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":21,"patch_id":67,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) || !(options.disambiguateProperties)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":22,"patch_id":59,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) || !(options.removeTryCatchFinally)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":23,"patch_id":32,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) && !(options.checkGlobalThisLevel.isOn() &&\n        !options.disables(DiagnosticGroups.GLOBAL_THIS))) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":24,"patch_id":30,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) && (options.checkGlobalThisLevel.isOn() &&\n        !options.disables(DiagnosticGroups.GLOBAL_THIS))) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":25,"patch_id":66,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) && (options.disambiguateProperties)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":26,"patch_id":68,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) && !(options.disambiguateProperties)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":27,"patch_id":60,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) && !(options.removeTryCatchFinally)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":28,"patch_id":97,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) || (!options.checkTypes)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":29,"patch_id":58,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) && (options.removeTryCatchFinally)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":30,"patch_id":89,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) || (!options.ideMode)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":31,"patch_id":53,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) || (options.devMode == DevMode.START_AND_END)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":32,"patch_id":69,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) || (options.transformAMDToCJSModules)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":33,"patch_id":71,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) || !(options.transformAMDToCJSModules)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":34,"patch_id":5,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) || (options.transformAMDToCJSModules || options.processCommonJSModules)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":35,"patch_id":27,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) || !(!options.skipAllPasses)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":36,"patch_id":25,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) || (!options.skipAllPasses)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":37,"patch_id":7,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) || !(options.transformAMDToCJSModules || options.processCommonJSModules)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":38,"patch_id":98,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) && (!options.checkTypes)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":39,"patch_id":90,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) && (!options.ideMode)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":40,"patch_id":61,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) || (!options.disables(DiagnosticGroups.GLOBAL_THIS))) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":41,"patch_id":51,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) || !(options.recordFunctionInformation)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":42,"patch_id":28,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) && !(!options.skipAllPasses)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":43,"patch_id":54,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) && (options.devMode == DevMode.START_AND_END)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":44,"patch_id":19,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) || !(options.nameAnonymousFunctionsOnly)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":45,"patch_id":8,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) && !(options.transformAMDToCJSModules || options.processCommonJSModules)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":46,"patch_id":70,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) && (options.transformAMDToCJSModules)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":47,"patch_id":6,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) && (options.transformAMDToCJSModules || options.processCommonJSModules)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":47,"patch_id":43,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) || !(options.getTweakProcessing().shouldStrip())) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":49,"patch_id":72,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) && !(options.transformAMDToCJSModules)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":50,"patch_id":41,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) || (options.getTweakProcessing().shouldStrip())) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":51,"patch_id":55,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) || !(options.devMode == DevMode.START_AND_END)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":52,"patch_id":99,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) || !(!options.checkTypes)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":53,"patch_id":33,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) || (options.processCommonJSModules)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":54,"patch_id":73,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) || (options.ambiguateProperties)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":55,"patch_id":35,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) || !(options.processCommonJSModules)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":56,"patch_id":75,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) || !(options.ambiguateProperties)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":57,"patch_id":52,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) && !(options.recordFunctionInformation)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":58,"patch_id":91,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) || !(!options.ideMode)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":59,"patch_id":49,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) || (options.recordFunctionInformation)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":60,"patch_id":26,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) && (!options.skipAllPasses)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":61,"patch_id":17,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) || (options.nameAnonymousFunctionsOnly)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":62,"patch_id":77,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) || (options.dependencyOptions.needsManagement() &&\n          options.closurePass)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":63,"patch_id":62,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) && (!options.disables(DiagnosticGroups.GLOBAL_THIS))) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":64,"patch_id":44,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) && !(options.getTweakProcessing().shouldStrip())) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":65,"patch_id":50,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) && (options.recordFunctionInformation)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":66,"patch_id":87,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) || !(options.disables(DiagnosticGroups.CHECK_TYPES))) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":67,"patch_id":9,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) || (options.devMode == DevMode.EVERY_PASS)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":68,"patch_id":42,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) && (options.getTweakProcessing().shouldStrip())) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":69,"patch_id":20,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) && !(options.nameAnonymousFunctionsOnly)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":70,"patch_id":34,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) && (options.processCommonJSModules)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":71,"patch_id":76,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) && !(options.ambiguateProperties)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":72,"patch_id":74,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) && (options.ambiguateProperties)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":73,"patch_id":78,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) && (options.dependencyOptions.needsManagement() &&\n          options.closurePass)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":74,"patch_id":36,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) && !(options.processCommonJSModules)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":75,"patch_id":11,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) || !(options.devMode == DevMode.EVERY_PASS)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":76,"patch_id":18,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) && (options.nameAnonymousFunctionsOnly)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":77,"patch_id":85,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) || (options.disables(DiagnosticGroups.CHECK_TYPES))) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":78,"patch_id":92,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) && !(!options.ideMode)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":79,"patch_id":63,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) || !(!options.disables(DiagnosticGroups.GLOBAL_THIS))) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":80,"patch_id":56,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) && !(options.devMode == DevMode.START_AND_END)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":81,"patch_id":100,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) && !(!options.checkTypes)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":82,"patch_id":79,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) || !(options.dependencyOptions.needsManagement() &&\n          options.closurePass)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":83,"patch_id":93,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) || (options.isExternExportsEnabled())) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":84,"patch_id":95,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) || !(options.isExternExportsEnabled())) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":85,"patch_id":88,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) && !(options.disables(DiagnosticGroups.CHECK_TYPES))) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":86,"patch_id":12,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) && !(options.devMode == DevMode.EVERY_PASS)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":87,"patch_id":10,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) && (options.devMode == DevMode.EVERY_PASS)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":88,"patch_id":80,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) && !(options.dependencyOptions.needsManagement() &&\n          options.closurePass)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":89,"patch_id":86,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) && (options.disables(DiagnosticGroups.CHECK_TYPES))) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":90,"patch_id":94,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) && (options.isExternExportsEnabled())) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":91,"patch_id":96,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) && !(options.isExternExportsEnabled())) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":92,"patch_id":64,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) && !(!options.disables(DiagnosticGroups.GLOBAL_THIS))) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":93,"patch_id":15,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) || !(options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":94,"patch_id":13,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) || (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":95,"patch_id":16,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) && !(options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":96,"patch_id":14,"patch_code":"if ((options.dependencyOptions.needsManagement() && options.closurePass) && (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"}],"Closure_2":[{"entropy_rank":1,"patch_id":4,"patch_code":"if (implicitProto == null) {\n\t    throw new IllegalArgumentException(\"Null 'implicitProto' argument.\");\n\t}\ncurrentPropertyNames = implicitProto.getOwnPropertyNames();currentPropertyNames = implicitProto.getOwnPropertyNames();"},{"entropy_rank":2,"patch_id":1,"patch_code":"currentPropertyNames = interfaceType.getOwnPropertyNames();currentPropertyNames = implicitProto.getOwnPropertyNames();"},{"entropy_rank":3,"patch_id":5,"patch_code":"if (implicitProto == null) {\n\t    return;\n\t}\ncurrentPropertyNames = implicitProto.getOwnPropertyNames();currentPropertyNames = implicitProto.getOwnPropertyNames();"},{"entropy_rank":4,"patch_id":6,"patch_code":"if (implicitProto == null) implicitProto = interfaceType;\n currentPropertyNames = implicitProto.getOwnPropertyNames();currentPropertyNames = implicitProto.getOwnPropertyNames();"},{"entropy_rank":5,"patch_id":3,"patch_code":"if (implicitProto != null) {\n\tcurrentPropertyNames = implicitProto.getOwnPropertyNames();\n    for (String name : currentPropertyNames) {\n      ObjectType oType = properties.get(name);\n      if (oType != null) {\n        if (!interfaceType.getPropertyType(name).isEquivalentTo(\n            oType.getPropertyType(name))) {\n          compiler.report(\n              t.makeError(n, INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,\n                  functionName, name, oType.toString(),\n                  interfaceType.toString()));\n        }\n      }\n      currentProperties.put(name, interfaceType);\n    }\n\t}\ncurrentPropertyNames = implicitProto.getOwnPropertyNames();\n    for (String name : currentPropertyNames) {\n      ObjectType oType = properties.get(name);\n      if (oType != null) {\n        if (!interfaceType.getPropertyType(name).isEquivalentTo(\n            oType.getPropertyType(name))) {\n          compiler.report(\n              t.makeError(n, INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,\n                  functionName, name, oType.toString(),\n                  interfaceType.toString()));\n        }\n      }\n      currentProperties.put(name, interfaceType);\n    }\n\t}\n"}],"Closure_21":[{"entropy_rank":5,"patch_id":34,"patch_code":"if ((n.isLocalResultCall()) && (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())))) {\n      return;\n    }if (n.isLocalResultCall()) {\n      return;\n    }"},{"entropy_rank":6,"patch_id":33,"patch_code":"if ((n.isLocalResultCall()) || (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())))) {\n      return;\n    }if (n.isLocalResultCall()) {\n      return;\n    }"},{"entropy_rank":7,"patch_id":35,"patch_code":"if ((n.isLocalResultCall()) || !(! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())))) {\n      return;\n    }if (n.isLocalResultCall()) {\n      return;\n    }"},{"entropy_rank":8,"patch_id":36,"patch_code":"if ((n.isLocalResultCall()) && !(! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())))) {\n      return;\n    }if (n.isLocalResultCall()) {\n      return;\n    }"},{"entropy_rank":9,"patch_id":75,"patch_code":"if (n.hasChildren()) {\n      return;\n    }if (n.isLocalResultCall()) {\n      return;\n    }"},{"entropy_rank":10,"patch_id":80,"patch_code":"if (n.isUnscopedQualifiedName()) {\n      return;\n    }if (n.isLocalResultCall()) {\n      return;\n    }"},{"entropy_rank":11,"patch_id":79,"patch_code":"if (n.isQualifiedName()) {\n      return;\n    }if (n.isLocalResultCall()) {\n      return;\n    }"},{"entropy_rank":12,"patch_id":78,"patch_code":"if (n.hasMoreThanOneChild()) {\n      return;\n    }if (n.isLocalResultCall()) {\n      return;\n    }"},{"entropy_rank":13,"patch_id":29,"patch_code":"if ((n.isLocalResultCall()) || (n.isString())) {\n      return;\n    }if (n.isLocalResultCall()) {\n      return;\n    }"},{"entropy_rank":14,"patch_id":76,"patch_code":"if (n.isFromExterns()) {\n      return;\n    }if (n.isLocalResultCall()) {\n      return;\n    }"},{"entropy_rank":15,"patch_id":30,"patch_code":"if ((n.isLocalResultCall()) && (n.isString())) {\n      return;\n    }if (n.isLocalResultCall()) {\n      return;\n    }"},{"entropy_rank":16,"patch_id":22,"patch_code":"if ((n.isLocalResultCall()) && (!NodeUtil.isStatement(n))) {\n      return;\n    }if (n.isLocalResultCall()) {\n      return;\n    }"},{"entropy_rank":17,"patch_id":21,"patch_code":"if ((n.isLocalResultCall()) || (!NodeUtil.isStatement(n))) {\n      return;\n    }if (n.isLocalResultCall()) {\n      return;\n    }"},{"entropy_rank":18,"patch_id":83,"patch_code":"if (n.isSyntheticBlock()) {\n      return;\n    }if (n.isLocalResultCall()) {\n      return;\n    }"},{"entropy_rank":19,"patch_id":77,"patch_code":"if (n.hasOneChild()) {\n      return;\n    }if (n.isLocalResultCall()) {\n      return;\n    }"},{"entropy_rank":20,"patch_id":9,"patch_code":"if ((n.isLocalResultCall()) || (n.isQualifiedName())) {\n      return;\n    }if (n.isLocalResultCall()) {\n      return;\n    }"},{"entropy_rank":21,"patch_id":32,"patch_code":"if ((n.isLocalResultCall()) && !(n.isString())) {\n      return;\n    }if (n.isLocalResultCall()) {\n      return;\n    }"},{"entropy_rank":22,"patch_id":12,"patch_code":"if ((n.isLocalResultCall()) && !(n.isQualifiedName())) {\n      return;\n    }if (n.isLocalResultCall()) {\n      return;\n    }"},{"entropy_rank":23,"patch_id":17,"patch_code":"if ((n.isLocalResultCall()) || (n.isEmpty())) {\n      return;\n    }if (n.isLocalResultCall()) {\n      return;\n    }"},{"entropy_rank":24,"patch_id":10,"patch_code":"if ((n.isLocalResultCall()) && (n.isQualifiedName())) {\n      return;\n    }if (n.isLocalResultCall()) {\n      return;\n    }"},{"entropy_rank":25,"patch_id":86,"patch_code":"if (n.isNoSideEffectsCall()) {\n      return;\n    }if (n.isLocalResultCall()) {\n      return;\n    }"},{"entropy_rank":26,"patch_id":23,"patch_code":"if ((n.isLocalResultCall()) || !(!NodeUtil.isStatement(n))) {\n      return;\n    }if (n.isLocalResultCall()) {\n      return;\n    }"},{"entropy_rank":27,"patch_id":13,"patch_code":"if ((n.isLocalResultCall()) || (n.isComma())) {\n      return;\n    }if (n.isLocalResultCall()) {\n      return;\n    }"},{"entropy_rank":28,"patch_id":25,"patch_code":"if ((n.isLocalResultCall()) || (n == parent.getLastChild())) {\n      return;\n    }if (n.isLocalResultCall()) {\n      return;\n    }"},{"entropy_rank":29,"patch_id":14,"patch_code":"if ((n.isLocalResultCall()) && (n.isComma())) {\n      return;\n    }if (n.isLocalResultCall()) {\n      return;\n    }"},{"entropy_rank":30,"patch_id":81,"patch_code":"if (n.isVarArgs()) {\n      return;\n    }if (n.isLocalResultCall()) {\n      return;\n    }"},{"entropy_rank":30,"patch_id":37,"patch_code":"if (n != parent && (n.isLocalResultCall())) {\n      return;\n    }if (n.isLocalResultCall()) {\n      return;\n    }"},{"entropy_rank":32,"patch_id":31,"patch_code":"if ((n.isLocalResultCall()) || !(n.isString())) {\n      return;\n    }if (n.isLocalResultCall()) {\n      return;\n    }"},{"entropy_rank":33,"patch_id":11,"patch_code":"if ((n.isLocalResultCall()) || !(n.isQualifiedName())) {\n      return;\n    }if (n.isLocalResultCall()) {\n      return;\n    }"},{"entropy_rank":34,"patch_id":20,"patch_code":"if ((n.isLocalResultCall()) && !(n.isEmpty())) {\n      return;\n    }if (n.isLocalResultCall()) {\n      return;\n    }"},{"entropy_rank":35,"patch_id":39,"patch_code":"if (n == parent && (n.isLocalResultCall())) {\n      return;\n    }if (n.isLocalResultCall()) {\n      return;\n    }"},{"entropy_rank":36,"patch_id":16,"patch_code":"if ((n.isLocalResultCall()) && !(n.isComma())) {\n      return;\n    }if (n.isLocalResultCall()) {\n      return;\n    }"},{"entropy_rank":37,"patch_id":24,"patch_code":"if ((n.isLocalResultCall()) && !(!NodeUtil.isStatement(n))) {\n      return;\n    }if (n.isLocalResultCall()) {\n      return;\n    }"},{"entropy_rank":38,"patch_id":28,"patch_code":"if ((n.isLocalResultCall()) && !(n == parent.getLastChild())) {\n      return;\n    }if (n.isLocalResultCall()) {\n      return;\n    }"},{"entropy_rank":39,"patch_id":40,"patch_code":"if (n == parent || (n.isLocalResultCall())) {\n      return;\n    }if (n.isLocalResultCall()) {\n      return;\n    }"},{"entropy_rank":40,"patch_id":18,"patch_code":"if ((n.isLocalResultCall()) && (n.isEmpty())) {\n      return;\n    }if (n.isLocalResultCall()) {\n      return;\n    }"},{"entropy_rank":41,"patch_id":15,"patch_code":"if ((n.isLocalResultCall()) || !(n.isComma())) {\n      return;\n    }if (n.isLocalResultCall()) {\n      return;\n    }"},{"entropy_rank":42,"patch_id":26,"patch_code":"if ((n.isLocalResultCall()) && (n == parent.getLastChild())) {\n      return;\n    }if (n.isLocalResultCall()) {\n      return;\n    }"},{"entropy_rank":43,"patch_id":19,"patch_code":"if ((n.isLocalResultCall()) || !(n.isEmpty())) {\n      return;\n    }if (n.isLocalResultCall()) {\n      return;\n    }"},{"entropy_rank":44,"patch_id":27,"patch_code":"if ((n.isLocalResultCall()) || !(n == parent.getLastChild())) {\n      return;\n    }if (n.isLocalResultCall()) {\n      return;\n    }"},{"entropy_rank":45,"patch_id":38,"patch_code":"if (n != parent || (n.isLocalResultCall())) {\n      return;\n    }if (n.isLocalResultCall()) {\n      return;\n    }"},{"entropy_rank":46,"patch_id":82,"patch_code":"if (n.isOptionalArg()) {\n      return;\n    }if (n.isLocalResultCall()) {\n      return;\n    }"},{"entropy_rank":47,"patch_id":85,"patch_code":"if (n.isOnlyModifiesThisCall()) {\n      return;\n    }if (n.isLocalResultCall()) {\n      return;\n    }"},{"entropy_rank":48,"patch_id":84,"patch_code":"if (n.wasEmptyNode()) {\n      return;\n    }if (n.isLocalResultCall()) {\n      return;\n    }"}],"Closure_22":[{"entropy_rank":5,"patch_id":34,"patch_code":"if ((parent.getType() == Token.COMMA) || (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString()))) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }if (parent.getType() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }"},{"entropy_rank":8,"patch_id":37,"patch_code":"if ((parent.getType() == Token.COMMA) && !(n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString()))) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }if (parent.getType() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }"},{"entropy_rank":9,"patch_id":36,"patch_code":"if ((parent.getType() == Token.COMMA) || !(n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString()))) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }if (parent.getType() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }"},{"entropy_rank":10,"patch_id":35,"patch_code":"if ((parent.getType() == Token.COMMA) && (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString()))) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }if (parent.getType() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }"},{"entropy_rank":15,"patch_id":31,"patch_code":"if ((parent.getType() == Token.COMMA) && (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext()))) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }if (parent.getType() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }"},{"entropy_rank":16,"patch_id":30,"patch_code":"if ((parent.getType() == Token.COMMA) || (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext()))) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }if (parent.getType() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }"},{"entropy_rank":18,"patch_id":33,"patch_code":"if ((parent.getType() == Token.COMMA) && !(parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext()))) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }if (parent.getType() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }"},{"entropy_rank":21,"patch_id":32,"patch_code":"if ((parent.getType() == Token.COMMA) || !(parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext()))) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }if (parent.getType() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }"},{"entropy_rank":25,"patch_id":39,"patch_code":"if ((parent.getType() == Token.COMMA) && ((n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext()))) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }if (parent.getType() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }"},{"entropy_rank":28,"patch_id":71,"patch_code":"if ((parent.getType() == Token.COMMA) && (parent.getType() == Token.FOR)) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }if (parent.getType() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }"},{"entropy_rank":29,"patch_id":50,"patch_code":"if ((parent.getType() == Token.COMMA) || (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName())) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }if (parent.getType() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }"},{"entropy_rank":30,"patch_id":38,"patch_code":"if ((parent.getType() == Token.COMMA) || ((n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext()))) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }if (parent.getType() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }"},{"entropy_rank":31,"patch_id":41,"patch_code":"if ((parent.getType() == Token.COMMA) && !((n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext()))) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }if (parent.getType() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }"},{"entropy_rank":32,"patch_id":53,"patch_code":"if ((parent.getType() == Token.COMMA) && !(n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName())) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }if (parent.getType() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }"},{"entropy_rank":33,"patch_id":79,"patch_code":"if ((parent.getType() == Token.COMMA) && (parent.getChildCount() == 2)) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }if (parent.getType() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }"},{"entropy_rank":34,"patch_id":18,"patch_code":"if ((parent.getType() == Token.COMMA) || (parent.getType() != Token.BLOCK)) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }if (parent.getType() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }"},{"entropy_rank":35,"patch_id":73,"patch_code":"if ((parent.getType() == Token.COMMA) && !(parent.getType() == Token.FOR)) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }if (parent.getType() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }"},{"entropy_rank":36,"patch_id":117,"patch_code":"if (parent.getLineno() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }if (parent.getType() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }"},{"entropy_rank":37,"patch_id":19,"patch_code":"if ((parent.getType() == Token.COMMA) && (parent.getType() != Token.BLOCK)) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }if (parent.getType() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }"},{"entropy_rank":38,"patch_id":70,"patch_code":"if ((parent.getType() == Token.COMMA) || (parent.getType() == Token.FOR)) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }if (parent.getType() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }"},{"entropy_rank":39,"patch_id":7,"patch_code":"if ((parent.getType() == Token.COMMA) && (n == parent.getLastChild())) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }if (parent.getType() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }"},{"entropy_rank":40,"patch_id":40,"patch_code":"if ((parent.getType() == Token.COMMA) || !((n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext()))) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }if (parent.getType() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }"},{"entropy_rank":41,"patch_id":83,"patch_code":"if ((parent.getType() == Token.COMMA) && (n == parent.getFirstChild())) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }if (parent.getType() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }"},{"entropy_rank":43,"patch_id":52,"patch_code":"if ((parent.getType() == Token.COMMA) || !(n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName())) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }if (parent.getType() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }"},{"entropy_rank":45,"patch_id":72,"patch_code":"if ((parent.getType() == Token.COMMA) || !(parent.getType() == Token.FOR)) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }if (parent.getType() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }"},{"entropy_rank":46,"patch_id":6,"patch_code":"if ((parent.getType() == Token.COMMA) || (n == parent.getLastChild())) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }if (parent.getType() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }"},{"entropy_rank":47,"patch_id":21,"patch_code":"if ((parent.getType() == Token.COMMA) && !(parent.getType() != Token.BLOCK)) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }if (parent.getType() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }"},{"entropy_rank":48,"patch_id":63,"patch_code":"if ((parent.getType() == Token.COMMA) && (n == parent.getFirstChild() && parent.getChildCount() == 2)) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }if (parent.getType() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }"},{"entropy_rank":49,"patch_id":51,"patch_code":"if ((parent.getType() == Token.COMMA) && (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName())) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }if (parent.getType() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }"},{"entropy_rank":50,"patch_id":78,"patch_code":"if ((parent.getType() == Token.COMMA) || (parent.getChildCount() == 2)) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }if (parent.getType() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }"},{"entropy_rank":52,"patch_id":20,"patch_code":"if ((parent.getType() == Token.COMMA) || !(parent.getType() != Token.BLOCK)) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }if (parent.getType() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }"},{"entropy_rank":53,"patch_id":23,"patch_code":"if ((parent.getType() == Token.COMMA) && (parent.getType() != Token.EXPR_RESULT)) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }if (parent.getType() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }"},{"entropy_rank":54,"patch_id":85,"patch_code":"if ((parent.getType() == Token.COMMA) && !(n == parent.getFirstChild())) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }if (parent.getType() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }"},{"entropy_rank":56,"patch_id":22,"patch_code":"if ((parent.getType() == Token.COMMA) || (parent.getType() != Token.EXPR_RESULT)) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }if (parent.getType() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }"},{"entropy_rank":59,"patch_id":81,"patch_code":"if ((parent.getType() == Token.COMMA) && !(parent.getChildCount() == 2)) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }if (parent.getType() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }"},{"entropy_rank":60,"patch_id":8,"patch_code":"if ((parent.getType() == Token.COMMA) || !(n == parent.getLastChild())) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }if (parent.getType() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }"},{"entropy_rank":61,"patch_id":80,"patch_code":"if ((parent.getType() == Token.COMMA) || !(parent.getChildCount() == 2)) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }if (parent.getType() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }"},{"entropy_rank":62,"patch_id":9,"patch_code":"if ((parent.getType() == Token.COMMA) && !(n == parent.getLastChild())) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }if (parent.getType() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }"},{"entropy_rank":63,"patch_id":88,"patch_code":"if (parent == n && (parent.getType() == Token.COMMA)) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }if (parent.getType() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }"},{"entropy_rank":64,"patch_id":82,"patch_code":"if ((parent.getType() == Token.COMMA) || (n == parent.getFirstChild())) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }if (parent.getType() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }"},{"entropy_rank":65,"patch_id":89,"patch_code":"if (parent == n || (parent.getType() == Token.COMMA)) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }if (parent.getType() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }"},{"entropy_rank":66,"patch_id":86,"patch_code":"if (parent != n && (parent.getType() == Token.COMMA)) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }if (parent.getType() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }"},{"entropy_rank":67,"patch_id":65,"patch_code":"if ((parent.getType() == Token.COMMA) && !(n == parent.getFirstChild() && parent.getChildCount() == 2)) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }if (parent.getType() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }"},{"entropy_rank":68,"patch_id":84,"patch_code":"if ((parent.getType() == Token.COMMA) || !(n == parent.getFirstChild())) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }if (parent.getType() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }"},{"entropy_rank":69,"patch_id":25,"patch_code":"if ((parent.getType() == Token.COMMA) && !(parent.getType() != Token.EXPR_RESULT)) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }if (parent.getType() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }"},{"entropy_rank":70,"patch_id":62,"patch_code":"if ((parent.getType() == Token.COMMA) || (n == parent.getFirstChild() && parent.getChildCount() == 2)) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }if (parent.getType() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }"},{"entropy_rank":71,"patch_id":24,"patch_code":"if ((parent.getType() == Token.COMMA) || !(parent.getType() != Token.EXPR_RESULT)) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }if (parent.getType() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }"},{"entropy_rank":72,"patch_id":64,"patch_code":"if ((parent.getType() == Token.COMMA) || !(n == parent.getFirstChild() && parent.getChildCount() == 2)) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }if (parent.getType() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }"},{"entropy_rank":73,"patch_id":1,"patch_code":"if (parent.getType()!=Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }if (parent.getType() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }"},{"entropy_rank":74,"patch_id":87,"patch_code":"if (parent != n || (parent.getType() == Token.COMMA)) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }if (parent.getType() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }"},{"entropy_rank":75,"patch_id":122,"patch_code":"if (parent.getSideEffectFlags() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }if (parent.getType() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }"},{"entropy_rank":77,"patch_id":4,"patch_code":"if (parent.getType()>Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }if (parent.getType() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }"},{"entropy_rank":78,"patch_id":3,"patch_code":"if (parent.getType()<=Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }if (parent.getType() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }"},{"entropy_rank":79,"patch_id":5,"patch_code":"if (parent.getType()>=Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }if (parent.getType() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }"},{"entropy_rank":81,"patch_id":2,"patch_code":"if (parent.getType()<Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }if (parent.getType() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }"},{"entropy_rank":89,"patch_id":116,"patch_code":"if (parent.getLength() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }if (parent.getType() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }"},{"entropy_rank":93,"patch_id":96,"patch_code":"if (parent.getDouble() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }if (parent.getType() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    \/\/ This no-op statement was there so that JSDoc information could\n    \/\/ be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }"}],"Closure_25":[{"entropy_rank":1,"patch_id":50,"patch_code":"scope = traverseChildren(constructor, scope);scope = traverse(constructor, scope);"},{"entropy_rank":2,"patch_id":53,"patch_code":"scope = dereferencePointer(constructor, scope);scope = traverse(constructor, scope);"},{"entropy_rank":3,"patch_id":49,"patch_code":"scope = traverseNew(constructor, scope);scope = traverse(constructor, scope);"},{"entropy_rank":4,"patch_id":52,"patch_code":"scope = traverseGetProp(constructor, scope);scope = traverse(constructor, scope);"},{"entropy_rank":5,"patch_id":51,"patch_code":"scope = traverseGetElem(constructor, scope);scope = traverse(constructor, scope);"},{"entropy_rank":6,"patch_id":1,"patch_code":"scope = traverse(n, scope);scope = traverse(constructor, scope);"},{"entropy_rank":7,"patch_id":47,"patch_code":"scope = traverseCall(constructor, scope);scope = traverse(constructor, scope);"},{"entropy_rank":8,"patch_id":39,"patch_code":"scope = traverseReturn(constructor, scope);scope = traverse(constructor, scope);"},{"entropy_rank":9,"patch_id":44,"patch_code":"scope = traverseObjectLiteral(constructor, scope);scope = traverse(constructor, scope);"},{"entropy_rank":10,"patch_id":9,"patch_code":"if (constructor == null) {\n\t    throw new IllegalArgumentException(\"Null 'constructor' argument.\");\n\t}\nscope = traverse(constructor, scope);scope = traverse(constructor, scope);"},{"entropy_rank":11,"patch_id":41,"patch_code":"scope = traverseAssign(constructor, scope);scope = traverse(constructor, scope);"},{"entropy_rank":13,"patch_id":42,"patch_code":"scope = traverseName(constructor, scope);scope = traverse(constructor, scope);"},{"entropy_rank":14,"patch_id":17,"patch_code":"if (scope == null) {\n\t    throw new IllegalArgumentException(\"Null 'scope' argument.\");\n\t}\nscope = traverse(constructor, scope);scope = traverse(constructor, scope);"},{"entropy_rank":15,"patch_id":46,"patch_code":"scope = traverseHook(constructor, scope);scope = traverse(constructor, scope);"},{"entropy_rank":16,"patch_id":40,"patch_code":"scope = traverseCatch(constructor, scope);scope = traverse(constructor, scope);"},{"entropy_rank":17,"patch_id":43,"patch_code":"scope = traverseArrayLiteral(constructor, scope);scope = traverse(constructor, scope);"},{"entropy_rank":18,"patch_id":45,"patch_code":"scope = traverseAdd(constructor, scope);scope = traverse(constructor, scope);"},{"entropy_rank":19,"patch_id":38,"patch_code":"scope = flowThrough(constructor, scope);scope = traverse(constructor, scope);"},{"entropy_rank":20,"patch_id":3,"patch_code":"scope = traverse(constructor, this.functionScope);scope = traverse(constructor, scope);"},{"entropy_rank":21,"patch_id":105,"patch_code":"if (constructor != null) {\n\tfor (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) {\n      scope = traverse(arg, scope);\n    }\n\t}\nfor (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) {\n      scope = traverse(arg, scope);\n    }\n\t}\n"},{"entropy_rank":22,"patch_id":2,"patch_code":"scope = traverse(constructor, this.bottomScope);scope = traverse(constructor, scope);"},{"entropy_rank":23,"patch_id":7,"patch_code":"scope = traverse(constructor, createEntryLattice());scope = traverse(constructor, scope);"},{"entropy_rank":24,"patch_id":56,"patch_code":"scope = traverse(n, this.functionScope);scope = traverse(constructor, scope);"},{"entropy_rank":25,"patch_id":6,"patch_code":"scope = traverse(constructor, createInitialEstimateLattice());scope = traverse(constructor, scope);"},{"entropy_rank":26,"patch_id":67,"patch_code":"ensurePropertyDeclared(constructor);scope = traverse(constructor, scope);"},{"entropy_rank":27,"patch_id":10,"patch_code":"if (constructor == null) {\n\t    return null;\n\t}\nscope = traverse(constructor, scope);scope = traverse(constructor, scope);"},{"entropy_rank":28,"patch_id":123,"patch_code":"for (Node arg = constructor.getLastChild(); arg != null; arg = arg.getNext()) {\n      scope = traverse(arg, scope);\n    }for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) {\n      scope = traverse(arg, scope);\n    }"},{"entropy_rank":29,"patch_id":11,"patch_code":"if (constructor == null) constructor = n;\n scope = traverse(constructor, scope);scope = traverse(constructor, scope);"},{"entropy_rank":30,"patch_id":57,"patch_code":"scope = traverse(n, this.bottomScope);scope = traverse(constructor, scope);"},{"entropy_rank":32,"patch_id":18,"patch_code":"if (scope == null) {\n\t    return null;\n\t}\nscope = traverse(constructor, scope);scope = traverse(constructor, scope);"},{"entropy_rank":33,"patch_id":14,"patch_code":"if (constructor == null) return this.functionScope;\n\t scope = traverse(constructor, scope);scope = traverse(constructor, scope);"},{"entropy_rank":34,"patch_id":19,"patch_code":"if (scope == null) scope = this.functionScope;\n scope = traverse(constructor, scope);scope = traverse(constructor, scope);"},{"entropy_rank":35,"patch_id":68,"patch_code":"ensurePropertyDeclared(constructor);\n\tscope = traverse(constructor, scope);scope = traverse(constructor, scope);"},{"entropy_rank":36,"patch_id":23,"patch_code":"if (scope == null) return this.functionScope;\n\t scope = traverse(constructor, scope);scope = traverse(constructor, scope);"},{"entropy_rank":37,"patch_id":122,"patch_code":"for (Node arg = constructor.getFirstChild(); arg != null; arg = arg.getNext()) {\n      scope = traverse(arg, scope);\n    }for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) {\n      scope = traverse(arg, scope);\n    }"},{"entropy_rank":38,"patch_id":15,"patch_code":"if (constructor == null) return this.bottomScope;\n\t scope = traverse(constructor, scope);scope = traverse(constructor, scope);"},{"entropy_rank":39,"patch_id":20,"patch_code":"if (scope == null) scope = this.bottomScope;\n scope = traverse(constructor, scope);scope = traverse(constructor, scope);"},{"entropy_rank":40,"patch_id":83,"patch_code":"type = ct.getReturnType();type = ct.getInstanceType();"},{"entropy_rank":41,"patch_id":24,"patch_code":"if (scope == null) return this.bottomScope;\n\t scope = traverse(constructor, scope);scope = traverse(constructor, scope);"},{"entropy_rank":42,"patch_id":113,"patch_code":"if (constructor == null) return this.functionScope;\n\t for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) {\n      scope = traverse(arg, scope);\n    }for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) {\n      scope = traverse(arg, scope);\n    }"},{"entropy_rank":43,"patch_id":73,"patch_code":"type = ct.getTypeOfThis();type = ct.getInstanceType();"},{"entropy_rank":44,"patch_id":114,"patch_code":"if (constructor == null) return this.bottomScope;\n\t for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) {\n      scope = traverse(arg, scope);\n    }for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) {\n      scope = traverse(arg, scope);\n    }"},{"entropy_rank":45,"patch_id":92,"patch_code":"type = ct.toMaybeFunctionType();type = ct.getInstanceType();"},{"entropy_rank":46,"patch_id":65,"patch_code":"scope = traverse(constructor, scope);"},{"entropy_rank":47,"patch_id":72,"patch_code":"type = ct.getPrototype();type = ct.getInstanceType();"},{"entropy_rank":49,"patch_id":93,"patch_code":"type = ct.getSuperClassConstructor();type = ct.getInstanceType();"},{"entropy_rank":52,"patch_id":63,"patch_code":"\n    JSType constructorType = constructor.getJSType();\n    JSType type = null;\n    if (constructorType != null) {\n      constructorType = constructorType.restrictByNotNullOrUndefined();\n      if (constructorType.isUnknownType()) {\n        type = getNativeType(UNKNOWN_TYPE);\n      } else {\n        FunctionType ct = constructorType.toMaybeFunctionType();\n        if (ct == null && constructorType instanceof FunctionType) {\n          \/\/ If constructorType is a NoObjectType, then toMaybeFunctionType will\n          \/\/ return null. But NoObjectType implements the FunctionType\n          \/\/ interface, precisely because it can validly construct objects.\n          ct = (FunctionType) constructorType;\n        }\n        if (ct != null && ct.isConstructor()) {\n          type = ct.getInstanceType();\n        }\n      }\n    }\n    n.setJSType(type);\n    for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) {\n      scope = traverse(arg, scope);\n    }\n\tscope = traverse(constructor, scope);\n"},{"entropy_rank":53,"patch_id":62,"patch_code":"\n    JSType constructorType = constructor.getJSType();\n    JSType type = null;\n    if (constructorType != null) {\n      constructorType = constructorType.restrictByNotNullOrUndefined();\n      if (constructorType.isUnknownType()) {\n        type = getNativeType(UNKNOWN_TYPE);\n      } else {\n        FunctionType ct = constructorType.toMaybeFunctionType();\n        if (ct == null && constructorType instanceof FunctionType) {\n          \/\/ If constructorType is a NoObjectType, then toMaybeFunctionType will\n          \/\/ return null. But NoObjectType implements the FunctionType\n          \/\/ interface, precisely because it can validly construct objects.\n          ct = (FunctionType) constructorType;\n        }\n        if (ct != null && ct.isConstructor()) {\n          type = ct.getInstanceType();\n        }\n      }\n    }\n    n.setJSType(type);\n\tscope = traverse(constructor, scope);\n"},{"entropy_rank":54,"patch_id":69,"patch_code":"scope = traverse(constructor, scope);\n\tensurePropertyDeclared(constructor);scope = traverse(constructor, scope);"},{"entropy_rank":56,"patch_id":59,"patch_code":"\n    JSType constructorType = constructor.getJSType();\n\tscope = traverse(constructor, scope);\n"},{"entropy_rank":57,"patch_id":104,"patch_code":"type = ct.getInstanceType();"},{"entropy_rank":58,"patch_id":60,"patch_code":"\n    JSType constructorType = constructor.getJSType();\n    JSType type = null;\n\tscope = traverse(constructor, scope);\n"},{"entropy_rank":59,"patch_id":61,"patch_code":"\n    JSType constructorType = constructor.getJSType();\n    JSType type = null;\n    if (constructorType != null) {\n      constructorType = constructorType.restrictByNotNullOrUndefined();\n      if (constructorType.isUnknownType()) {\n        type = getNativeType(UNKNOWN_TYPE);\n      } else {\n        FunctionType ct = constructorType.toMaybeFunctionType();\n        if (ct == null && constructorType instanceof FunctionType) {\n          \/\/ If constructorType is a NoObjectType, then toMaybeFunctionType will\n          \/\/ return null. But NoObjectType implements the FunctionType\n          \/\/ interface, precisely because it can validly construct objects.\n          ct = (FunctionType) constructorType;\n        }\n        if (ct != null && ct.isConstructor()) {\n          type = ct.getInstanceType();\n        }\n      }\n    }\n\tscope = traverse(constructor, scope);\n"}],"Closure_31":[{"entropy_rank":1,"patch_id":35,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) || !(options.recordFunctionInformation)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":2,"patch_id":36,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) && !(options.recordFunctionInformation)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":3,"patch_id":34,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) && (options.recordFunctionInformation)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":4,"patch_id":33,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) || (options.recordFunctionInformation)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":5,"patch_id":55,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) || !(options.processCommonJSModules)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":6,"patch_id":56,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) && !(options.processCommonJSModules)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":7,"patch_id":53,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) || (options.processCommonJSModules)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":8,"patch_id":54,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) && (options.processCommonJSModules)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":9,"patch_id":23,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) || !(options.transformAMDToCJSModules || options.processCommonJSModules)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":10,"patch_id":39,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) || !(options.checkGlobalThisLevel.isOn() &&\n        !options.disables(DiagnosticGroups.GLOBAL_THIS))) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":11,"patch_id":21,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) || (options.transformAMDToCJSModules || options.processCommonJSModules)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":12,"patch_id":24,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) && !(options.transformAMDToCJSModules || options.processCommonJSModules)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":13,"patch_id":22,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) && (options.transformAMDToCJSModules || options.processCommonJSModules)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":14,"patch_id":40,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) && !(options.checkGlobalThisLevel.isOn() &&\n        !options.disables(DiagnosticGroups.GLOBAL_THIS))) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":15,"patch_id":63,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) || !(options.disambiguateProperties)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":16,"patch_id":64,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) && !(options.disambiguateProperties)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":17,"patch_id":37,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) || (options.checkGlobalThisLevel.isOn() &&\n        !options.disables(DiagnosticGroups.GLOBAL_THIS))) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":18,"patch_id":61,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) || (options.disambiguateProperties)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":19,"patch_id":7,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) || !(options.nameAnonymousFunctionsOnly)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":20,"patch_id":38,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) && (options.checkGlobalThisLevel.isOn() &&\n        !options.disables(DiagnosticGroups.GLOBAL_THIS))) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":21,"patch_id":8,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) && !(options.nameAnonymousFunctionsOnly)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":22,"patch_id":31,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) || !(options.getTweakProcessing().shouldStrip() ||\n        !options.stripTypes.isEmpty() ||\n        !options.stripNameSuffixes.isEmpty() ||\n        !options.stripTypePrefixes.isEmpty() ||\n        !options.stripNamePrefixes.isEmpty())) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":23,"patch_id":32,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) && !(options.getTweakProcessing().shouldStrip() ||\n        !options.stripTypes.isEmpty() ||\n        !options.stripNameSuffixes.isEmpty() ||\n        !options.stripTypePrefixes.isEmpty() ||\n        !options.stripNamePrefixes.isEmpty())) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":24,"patch_id":28,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) && !(options.ambiguateProperties ||\n        options.disambiguateProperties)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":25,"patch_id":62,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) && (options.disambiguateProperties)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":26,"patch_id":27,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) || !(options.ambiguateProperties ||\n        options.disambiguateProperties)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":27,"patch_id":5,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) || (options.nameAnonymousFunctionsOnly)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":28,"patch_id":3,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) || !(options.removeTryCatchFinally)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":29,"patch_id":6,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) && (options.nameAnonymousFunctionsOnly)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":30,"patch_id":29,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) || (options.getTweakProcessing().shouldStrip() ||\n        !options.stripTypes.isEmpty() ||\n        !options.stripNameSuffixes.isEmpty() ||\n        !options.stripTypePrefixes.isEmpty() ||\n        !options.stripNamePrefixes.isEmpty())) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":31,"patch_id":4,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) && !(options.removeTryCatchFinally)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":32,"patch_id":25,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) || (options.ambiguateProperties ||\n        options.disambiguateProperties)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":33,"patch_id":26,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) && (options.ambiguateProperties ||\n        options.disambiguateProperties)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":34,"patch_id":47,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) || !(options.devMode == DevMode.START_AND_END)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":35,"patch_id":30,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) && (options.getTweakProcessing().shouldStrip() ||\n        !options.stripTypes.isEmpty() ||\n        !options.stripNameSuffixes.isEmpty() ||\n        !options.stripTypePrefixes.isEmpty() ||\n        !options.stripNamePrefixes.isEmpty())) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":36,"patch_id":1,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) || (options.removeTryCatchFinally)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":37,"patch_id":67,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) || !(!options.disables(DiagnosticGroups.GLOBAL_THIS))) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":38,"patch_id":2,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) && (options.removeTryCatchFinally)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":39,"patch_id":48,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) && !(options.devMode == DevMode.START_AND_END)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":40,"patch_id":68,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) && !(!options.disables(DiagnosticGroups.GLOBAL_THIS))) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":41,"patch_id":57,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) || (options.transformAMDToCJSModules)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":42,"patch_id":58,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) && (options.transformAMDToCJSModules)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":43,"patch_id":65,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) || (!options.disables(DiagnosticGroups.GLOBAL_THIS))) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":44,"patch_id":83,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) || !(options.disables(DiagnosticGroups.CHECK_TYPES))) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":45,"patch_id":59,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) || !(options.transformAMDToCJSModules)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":46,"patch_id":45,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) || (options.devMode == DevMode.START_AND_END)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":47,"patch_id":20,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) && !(options.devMode == DevMode.EVERY_PASS)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":48,"patch_id":19,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) || !(options.devMode == DevMode.EVERY_PASS)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":49,"patch_id":66,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) && (!options.disables(DiagnosticGroups.GLOBAL_THIS))) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":50,"patch_id":84,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) && !(options.disables(DiagnosticGroups.CHECK_TYPES))) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":51,"patch_id":46,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) && (options.devMode == DevMode.START_AND_END)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":52,"patch_id":78,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) && (!options.ideMode)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":53,"patch_id":60,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) && !(options.transformAMDToCJSModules)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":54,"patch_id":17,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) || (options.devMode == DevMode.EVERY_PASS)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":55,"patch_id":90,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) && (!options.checkTypes)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":56,"patch_id":15,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) || !(options.enables(DiagnosticGroups.CHECK_TYPES))) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":57,"patch_id":81,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) || (options.disables(DiagnosticGroups.CHECK_TYPES))) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":58,"patch_id":77,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) || (!options.ideMode)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":59,"patch_id":18,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) && (options.devMode == DevMode.EVERY_PASS)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":60,"patch_id":16,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) && !(options.enables(DiagnosticGroups.CHECK_TYPES))) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":61,"patch_id":71,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) || !(options.ambiguateProperties)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":62,"patch_id":72,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) && !(options.ambiguateProperties)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":63,"patch_id":82,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) && (options.disables(DiagnosticGroups.CHECK_TYPES))) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":64,"patch_id":89,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) || (!options.checkTypes)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":65,"patch_id":79,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) || !(!options.ideMode)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":66,"patch_id":69,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) || (options.ambiguateProperties)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":67,"patch_id":13,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) || (options.enables(DiagnosticGroups.CHECK_TYPES))) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":68,"patch_id":80,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) && !(!options.ideMode)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":69,"patch_id":87,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) || !(options.isExternExportsEnabled())) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":70,"patch_id":70,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) && (options.ambiguateProperties)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":72,"patch_id":88,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) && !(options.isExternExportsEnabled())) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":74,"patch_id":14,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) && (options.enables(DiagnosticGroups.CHECK_TYPES))) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":75,"patch_id":86,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) && (options.isExternExportsEnabled())) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":75,"patch_id":52,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) && !(options.getTweakProcessing().shouldStrip())) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":77,"patch_id":85,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) || (options.isExternExportsEnabled())) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":78,"patch_id":74,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) && (!options.checkSymbols)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":79,"patch_id":51,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) || !(options.getTweakProcessing().shouldStrip())) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":81,"patch_id":73,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) || (!options.checkSymbols)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":83,"patch_id":50,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) && (options.getTweakProcessing().shouldStrip())) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":84,"patch_id":49,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) || (options.getTweakProcessing().shouldStrip())) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":85,"patch_id":75,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) || !(!options.checkSymbols)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"},{"entropy_rank":86,"patch_id":76,"patch_code":"if ((options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) && !(!options.checkSymbols)) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          \/\/ Forward-declare all the provided types, so that they\n          \/\/ are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          \/\/ If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }"}],"Closure_38":[{"entropy_rank":1,"patch_id":5,"patch_code":"if (x>=0 && prev == '-') {\n      add(\" \");\n    }if (x < 0 && prev == '-') {\n      add(\" \");\n    }"},{"entropy_rank":2,"patch_id":1,"patch_code":"if (x==0 && prev == '-') {\n      add(\" \");\n    }if (x < 0 && prev == '-') {\n      add(\" \");\n    }"},{"entropy_rank":3,"patch_id":4,"patch_code":"if (x>0 && prev == '-') {\n      add(\" \");\n    }if (x < 0 && prev == '-') {\n      add(\" \");\n    }"},{"entropy_rank":4,"patch_id":2,"patch_code":"if (x!=0 && prev == '-') {\n      add(\" \");\n    }if (x < 0 && prev == '-') {\n      add(\" \");\n    }"},{"entropy_rank":5,"patch_id":3,"patch_code":"if (x<=0 && prev == '-') {\n      add(\" \");\n    }if (x < 0 && prev == '-') {\n      add(\" \");\n    }"},{"entropy_rank":6,"patch_id":6,"patch_code":"if (x < 0 && prev!='-') {\n      add(\" \");\n    }if (x < 0 && prev == '-') {\n      add(\" \");\n    }"},{"entropy_rank":7,"patch_id":8,"patch_code":"if (x < 0 && prev<='-') {\n      add(\" \");\n    }if (x < 0 && prev == '-') {\n      add(\" \");\n    }"},{"entropy_rank":8,"patch_id":10,"patch_code":"if (x < 0 && prev>='-') {\n      add(\" \");\n    }if (x < 0 && prev == '-') {\n      add(\" \");\n    }"},{"entropy_rank":9,"patch_id":7,"patch_code":"if (x < 0 && prev<'-') {\n      add(\" \");\n    }if (x < 0 && prev == '-') {\n      add(\" \");\n    }"},{"entropy_rank":10,"patch_id":9,"patch_code":"if (x < 0 && prev>'-') {\n      add(\" \");\n    }if (x < 0 && prev == '-') {\n      add(\" \");\n    }"}],"Closure_4":[{"entropy_rank":1,"patch_id":22,"patch_code":"if (hasReferenceName()) {\n      handleTypeCycle(t);\n    }if (detectImplicitPrototypeCycle()) {\n      handleTypeCycle(t);\n    }"},{"entropy_rank":2,"patch_id":21,"patch_code":"if (detectInheritanceCycle()) {\n      handleTypeCycle(t);\n    }if (detectImplicitPrototypeCycle()) {\n      handleTypeCycle(t);\n    }"},{"entropy_rank":3,"patch_id":23,"patch_code":"if (isUnknownType()) {\n      handleTypeCycle(t);\n    }if (detectImplicitPrototypeCycle()) {\n      handleTypeCycle(t);\n    }"},{"entropy_rank":4,"patch_id":24,"patch_code":"if (isObject()) {\n      handleTypeCycle(t);\n    }if (detectImplicitPrototypeCycle()) {\n      handleTypeCycle(t);\n    }"},{"entropy_rank":5,"patch_id":26,"patch_code":"if (isNativeObjectType()) {\n      handleTypeCycle(t);\n    }if (detectImplicitPrototypeCycle()) {\n      handleTypeCycle(t);\n    }"},{"entropy_rank":6,"patch_id":25,"patch_code":"if (hasCachedValues()) {\n      handleTypeCycle(t);\n    }if (detectImplicitPrototypeCycle()) {\n      handleTypeCycle(t);\n    }"},{"entropy_rank":7,"patch_id":27,"patch_code":"if (isFunctionPrototypeType()) {\n      handleTypeCycle(t);\n    }if (detectImplicitPrototypeCycle()) {\n      handleTypeCycle(t);\n    }"}],"Closure_40":[{"entropy_rank":1,"patch_id":15,"patch_code":"JsName name = getName(ns.name, true);JsName name = getName(ns.name, false);"},{"entropy_rank":2,"patch_id":2,"patch_code":"if (ns.name == null) {\n\t    throw new IllegalArgumentException(\"Null 'ns.name' argument.\");\n\t}\nJsName name = getName(ns.name, false);JsName name = getName(ns.name, false);"},{"entropy_rank":3,"patch_id":1,"patch_code":"if (ns.name != null) {\n\tJsName name = getName(ns.name, false);\n          if (name != null) {\n          refNodes.add(new ClassDefiningFunctionNode(\n              name, n, parent, parent.getParent()));\n          }\n\t}\nJsName name = getName(ns.name, false);\n          if (name != null) {\n          refNodes.add(new ClassDefiningFunctionNode(\n              name, n, parent, parent.getParent()));\n          }\n\t}\n"},{"entropy_rank":4,"patch_id":3,"patch_code":"if (ns.name == null) {\n\t    return;\n\t}\nJsName name = getName(ns.name, false);JsName name = getName(ns.name, false);"}],"Closure_46":[{"entropy_rank":1,"patch_id":1,"patch_code":"@Override\n  public JSType getLeastSupertype(JSType that) {\n    if (!that.isRecordType()) {\n      return super.getLeastSupertype(that);\n    }\n    RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n    for (String property : properties.keySet()) {\n      if (that.toMaybeRecordType().hasProperty(property) &&\n          that.toMaybeRecordType().getPropertyType(property).isEquivalentTo(\n              getPropertyType(property))) {\n        builder.addProperty(property, getPropertyType(property),\n            getPropertyNode(property));\n      }\n    }\n    return builder.build();\n  }"}],"Closure_49":[{"entropy_rank":1,"patch_id":199,"patch_code":"if (declarationRoot.getType() == Token.XML) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":2,"patch_id":229,"patch_code":"if (declarationRoot.getType() == Token.GOTO) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":3,"patch_id":159,"patch_code":"if (declarationRoot.getType() == Token.SWITCH) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":4,"patch_id":197,"patch_code":"if (declarationRoot.getType() == Token.TYPEOF) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":5,"patch_id":93,"patch_code":"if (declarationRoot.getType() == Token.CATCH) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":6,"patch_id":108,"patch_code":"if (declarationRoot.getType() == Token.TO_OBJECT) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":7,"patch_id":6,"patch_code":"if ((declarationRoot.getType() == Token.FUNCTION) || (declarationRoot.getType() != Token.FUNCTION)) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":8,"patch_id":72,"patch_code":"if (declarationRoot.getType() == Token.ELLIPSIS) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":9,"patch_id":86,"patch_code":"if (declarationRoot.getType() == Token.ASSIGN) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":10,"patch_id":122,"patch_code":"if (declarationRoot.getType() == Token.LT) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":11,"patch_id":79,"patch_code":"if (declarationRoot.getType() == Token.CALL) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":12,"patch_id":8,"patch_code":"if ((declarationRoot.getType() == Token.FUNCTION) || !(declarationRoot.getType() != Token.FUNCTION)) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":13,"patch_id":95,"patch_code":"if (declarationRoot.getType() == Token.COMMA) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":14,"patch_id":101,"patch_code":"if (declarationRoot.getType() == Token.DEBUGGER) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":15,"patch_id":120,"patch_code":"if (declarationRoot.getType() == Token.LP) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":16,"patch_id":7,"patch_code":"if ((declarationRoot.getType() == Token.FUNCTION) && (declarationRoot.getType() != Token.FUNCTION)) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":17,"patch_id":9,"patch_code":"if ((declarationRoot.getType() == Token.FUNCTION) && !(declarationRoot.getType() != Token.FUNCTION)) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":18,"patch_id":66,"patch_code":"if (declarationRoot.getType() == Token.CASE) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":19,"patch_id":81,"patch_code":"if (declarationRoot.getType() == Token.SET) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":20,"patch_id":74,"patch_code":"if (declarationRoot.getType() == Token.GET) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":21,"patch_id":91,"patch_code":"if (declarationRoot.getType() == Token.IMPORT) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":22,"patch_id":1,"patch_code":"if (declarationRoot.getType()!=Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":23,"patch_id":85,"patch_code":"if (declarationRoot.getType() == Token.RETHROW) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":24,"patch_id":121,"patch_code":"if (declarationRoot.getType() == Token.LOOP) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":25,"patch_id":84,"patch_code":"if (declarationRoot.getType() == Token.COLONCOLON) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":26,"patch_id":92,"patch_code":"if (declarationRoot.getType() == Token.BITOR) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":27,"patch_id":80,"patch_code":"if (declarationRoot.getType() == Token.GOTO) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":28,"patch_id":77,"patch_code":"if (declarationRoot.getType() == Token.ASSIGN_DIV) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":29,"patch_id":82,"patch_code":"if (declarationRoot.getType() == Token.SEMI) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":30,"patch_id":103,"patch_code":"if (declarationRoot.getType() == Token.CONTINUE) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":31,"patch_id":89,"patch_code":"if (declarationRoot.getType() == Token.LABEL_NAME) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":32,"patch_id":119,"patch_code":"if (declarationRoot.getType() == Token.REF_NS_NAME) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":33,"patch_id":228,"patch_code":"if (declarationRoot.getType() == Token.CALL) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":34,"patch_id":45,"patch_code":"if (declarationRoot.getChildCount() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":35,"patch_id":100,"patch_code":"if (declarationRoot.getType() == Token.BITNOT) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":36,"patch_id":83,"patch_code":"if (declarationRoot.getType() == Token.ASSIGN_MUL) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":37,"patch_id":96,"patch_code":"if (declarationRoot.getType() == Token.BITAND) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":38,"patch_id":4,"patch_code":"if (declarationRoot.getType()>Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":39,"patch_id":78,"patch_code":"if (declarationRoot.getType() == Token.RP) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":40,"patch_id":71,"patch_code":"if (declarationRoot.getType() == Token.ENUM_NEXT) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":40,"patch_id":88,"patch_code":"if (declarationRoot.getType() == Token.ASSIGN_BITOR) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":42,"patch_id":75,"patch_code":"if (declarationRoot.getType() == Token.SETPROP_OP) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":43,"patch_id":73,"patch_code":"if (declarationRoot.getType() == Token.POS) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":44,"patch_id":69,"patch_code":"if (declarationRoot.getType() == Token.RC) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":45,"patch_id":166,"patch_code":"if (declarationRoot.getType() == Token.REF_NS_MEMBER) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":46,"patch_id":5,"patch_code":"if (declarationRoot.getType()>=Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":47,"patch_id":2,"patch_code":"if (declarationRoot.getType()<Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":48,"patch_id":3,"patch_code":"if (declarationRoot.getType()<=Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":49,"patch_id":67,"patch_code":"if (declarationRoot.getType() == Token.ENUM_INIT_KEYS) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":50,"patch_id":76,"patch_code":"if (declarationRoot.getType() == Token.ASSIGN_BITAND) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":51,"patch_id":68,"patch_code":"if (declarationRoot.getType() == Token.RB) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":52,"patch_id":99,"patch_code":"if (declarationRoot.getType() == Token.LAST_TOKEN) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":53,"patch_id":90,"patch_code":"if (declarationRoot.getType() == Token.REF_CALL) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":54,"patch_id":41,"patch_code":"if (declarationRoot.getLineno() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":55,"patch_id":142,"patch_code":"if (declarationRoot.getType() == Token.SET_REF_OP) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":56,"patch_id":40,"patch_code":"if (declarationRoot.getLength() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":57,"patch_id":196,"patch_code":"if (declarationRoot.getType() == Token.SETELEM) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":58,"patch_id":42,"patch_code":"if (declarationRoot.getCharno() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":59,"patch_id":87,"patch_code":"if (declarationRoot.getType() == Token.ASSIGN_LSH) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":59,"patch_id":94,"patch_code":"if (declarationRoot.getType() == Token.DEL_REF) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":61,"patch_id":20,"patch_code":"if (declarationRoot.getDouble() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":62,"patch_id":148,"patch_code":"if (declarationRoot.getType() == Token.IFEQ) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":63,"patch_id":70,"patch_code":"if (declarationRoot.getType() == Token.FIRST_BYTECODE_TOKEN) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":64,"patch_id":44,"patch_code":"if (declarationRoot.getSourcePosition() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":65,"patch_id":46,"patch_code":"if (declarationRoot.getSideEffectFlags() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":66,"patch_id":97,"patch_code":"if (declarationRoot.getType() == Token.LAST_BYTECODE_TOKEN) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":67,"patch_id":43,"patch_code":"if (declarationRoot.getSourceOffset() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":68,"patch_id":98,"patch_code":"if (declarationRoot.getType() == Token.ESCXMLTEXT) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":69,"patch_id":227,"patch_code":"if (declarationRoot.getType() == Token.RP) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":70,"patch_id":168,"patch_code":"if (declarationRoot.getType() == Token.DOTQUERY) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":71,"patch_id":107,"patch_code":"if (declarationRoot.getType() == Token.LC) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":72,"patch_id":195,"patch_code":"if (declarationRoot.getType() == Token.LEAVEWITH) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":73,"patch_id":146,"patch_code":"if (declarationRoot.getType() == Token.REF_MEMBER) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":74,"patch_id":226,"patch_code":"if (declarationRoot.getType() == Token.ASSIGN_DIV) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":75,"patch_id":151,"patch_code":"if (declarationRoot.getType() == Token.NOT) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":76,"patch_id":167,"patch_code":"if (declarationRoot.getType() == Token.ASSIGN_SUB) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":77,"patch_id":102,"patch_code":"if (declarationRoot.getType() == Token.DIV) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"},{"entropy_rank":78,"patch_id":109,"patch_code":"if (declarationRoot.getType() == Token.LE) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }if (declarationRoot.getType() == Token.FUNCTION) {\n      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    }  else \n    if (declarationRoot.getType() != Token.FUNCTION) {\n      \/\/ Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }"}],"Closure_59":[{"entropy_rank":1,"patch_id":13,"patch_code":"\n\n    if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) {\n      options.setWarningLevel(\n          DiagnosticGroups.ES5_STRICT,\n          CheckLevel.ERROR);\n    }\n\n    \/\/ Initialize the warnings guard.\n    List<WarningsGuard> guards = Lists.newArrayList();\n    guards.add(\n        new SuppressDocWarningsGuard(\n            getDiagnosticGroups().getRegisteredGroups()));\n    guards.add(options.getWarningsGuard());\n\n    ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards);\n\n    \/\/ All passes must run the variable check. This synthesizes\n    \/\/ variables later so that the compiler doesn't crash. It also\n    \/\/ checks the externs file for validity. If you don't want to warn\n    \/\/ about missing variable declarations, we shut that specific\n    \/\/ error off.\n    if (!options.checkSymbols &&\n        !composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) {\n      composedGuards.addGuard(new DiagnosticGroupWarningsGuard(\n          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n    }\n\tif (options.checkGlobalThisLevel.isOn()) {\n      options.setWarningLevel(\n          DiagnosticGroups.GLOBAL_THIS,\n          options.checkGlobalThisLevel);\n    }\n"},{"entropy_rank":2,"patch_id":11,"patch_code":"\n\n    if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) {\n      options.setWarningLevel(\n          DiagnosticGroups.ES5_STRICT,\n          CheckLevel.ERROR);\n    }\n\n    \/\/ Initialize the warnings guard.\n    List<WarningsGuard> guards = Lists.newArrayList();\n    guards.add(\n        new SuppressDocWarningsGuard(\n            getDiagnosticGroups().getRegisteredGroups()));\n    guards.add(options.getWarningsGuard());\n\tif (options.checkGlobalThisLevel.isOn()) {\n      options.setWarningLevel(\n          DiagnosticGroups.GLOBAL_THIS,\n          options.checkGlobalThisLevel);\n    }\n"},{"entropy_rank":3,"patch_id":10,"patch_code":"\n\n    if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) {\n      options.setWarningLevel(\n          DiagnosticGroups.ES5_STRICT,\n          CheckLevel.ERROR);\n    }\n\n    \/\/ Initialize the warnings guard.\n    List<WarningsGuard> guards = Lists.newArrayList();\n    guards.add(\n        new SuppressDocWarningsGuard(\n            getDiagnosticGroups().getRegisteredGroups()));\n\tif (options.checkGlobalThisLevel.isOn()) {\n      options.setWarningLevel(\n          DiagnosticGroups.GLOBAL_THIS,\n          options.checkGlobalThisLevel);\n    }\n"},{"entropy_rank":4,"patch_id":14,"patch_code":"\n\n    if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) {\n      options.setWarningLevel(\n          DiagnosticGroups.ES5_STRICT,\n          CheckLevel.ERROR);\n    }\n\n    \/\/ Initialize the warnings guard.\n    List<WarningsGuard> guards = Lists.newArrayList();\n    guards.add(\n        new SuppressDocWarningsGuard(\n            getDiagnosticGroups().getRegisteredGroups()));\n    guards.add(options.getWarningsGuard());\n\n    ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards);\n\n    \/\/ All passes must run the variable check. This synthesizes\n    \/\/ variables later so that the compiler doesn't crash. It also\n    \/\/ checks the externs file for validity. If you don't want to warn\n    \/\/ about missing variable declarations, we shut that specific\n    \/\/ error off.\n    if (!options.checkSymbols &&\n        !composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) {\n      composedGuards.addGuard(new DiagnosticGroupWarningsGuard(\n          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n    }\n\n    this.warningsGuard = composedGuards;\n\tif (options.checkGlobalThisLevel.isOn()) {\n      options.setWarningLevel(\n          DiagnosticGroups.GLOBAL_THIS,\n          options.checkGlobalThisLevel);\n    }\n"},{"entropy_rank":5,"patch_id":5,"patch_code":"if (options.checkGlobalThisLevel.isOn()) {\n      options.setWarningLevel(\n          DiagnosticGroups.GLOBAL_THIS,\n          options.checkGlobalThisLevel);\n    }\n\tthis.options = options;\n    if (errorManager == null) {\n      if (outStream == null) {\n        setErrorManager(\n            new LoggerErrorManager(createMessageFormatter(), logger));\n      } else {\n        PrintStreamErrorManager printer =\n            new PrintStreamErrorManager(createMessageFormatter(), outStream);\n        printer.setSummaryDetailLevel(options.summaryDetailLevel);\n        setErrorManager(printer);\n      }\n    }\n\n    \/\/ DiagnosticGroups override the plain checkTypes option.\n    if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n      options.checkTypes = true;\n    } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n      options.checkTypes = false;\n    } else if (!options.checkTypes) {\n      \/\/ If DiagnosticGroups did not override the plain checkTypes\n      \/\/ option, and checkTypes is enabled, then turn off the\n      \/\/ parser type warnings.\n      options.setWarningLevel(\n          DiagnosticGroup.forType(\n              RhinoErrorReporter.TYPE_PARSE_ERROR),\n          CheckLevel.OFF);\n    }\n\n    "},{"entropy_rank":6,"patch_id":6,"patch_code":"if (options.checkGlobalThisLevel.isOn()) {\n      options.setWarningLevel(\n          DiagnosticGroups.GLOBAL_THIS,\n          options.checkGlobalThisLevel);\n    }\n\tif (errorManager == null) {\n      if (outStream == null) {\n        setErrorManager(\n            new LoggerErrorManager(createMessageFormatter(), logger));\n      } else {\n        PrintStreamErrorManager printer =\n            new PrintStreamErrorManager(createMessageFormatter(), outStream);\n        printer.setSummaryDetailLevel(options.summaryDetailLevel);\n        setErrorManager(printer);\n      }\n    }\n\n    \/\/ DiagnosticGroups override the plain checkTypes option.\n    if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n      options.checkTypes = true;\n    } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n      options.checkTypes = false;\n    } else if (!options.checkTypes) {\n      \/\/ If DiagnosticGroups did not override the plain checkTypes\n      \/\/ option, and checkTypes is enabled, then turn off the\n      \/\/ parser type warnings.\n      options.setWarningLevel(\n          DiagnosticGroup.forType(\n              RhinoErrorReporter.TYPE_PARSE_ERROR),\n          CheckLevel.OFF);\n    }\n\n    "},{"entropy_rank":7,"patch_id":12,"patch_code":"\n\n    if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) {\n      options.setWarningLevel(\n          DiagnosticGroups.ES5_STRICT,\n          CheckLevel.ERROR);\n    }\n\n    \/\/ Initialize the warnings guard.\n    List<WarningsGuard> guards = Lists.newArrayList();\n    guards.add(\n        new SuppressDocWarningsGuard(\n            getDiagnosticGroups().getRegisteredGroups()));\n    guards.add(options.getWarningsGuard());\n\n    ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards);\n\tif (options.checkGlobalThisLevel.isOn()) {\n      options.setWarningLevel(\n          DiagnosticGroups.GLOBAL_THIS,\n          options.checkGlobalThisLevel);\n    }\n"},{"entropy_rank":8,"patch_id":7,"patch_code":"if (options.checkGlobalThisLevel.isOn()) {\n      options.setWarningLevel(\n          DiagnosticGroups.GLOBAL_THIS,\n          options.checkGlobalThisLevel);\n    }\n\tif (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n      options.checkTypes = true;\n    } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n      options.checkTypes = false;\n    } else if (!options.checkTypes) {\n      \/\/ If DiagnosticGroups did not override the plain checkTypes\n      \/\/ option, and checkTypes is enabled, then turn off the\n      \/\/ parser type warnings.\n      options.setWarningLevel(\n          DiagnosticGroup.forType(\n              RhinoErrorReporter.TYPE_PARSE_ERROR),\n          CheckLevel.OFF);\n    }\n\n    "},{"entropy_rank":9,"patch_id":9,"patch_code":"\n\n    if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) {\n      options.setWarningLevel(\n          DiagnosticGroups.ES5_STRICT,\n          CheckLevel.ERROR);\n    }\n\n    \/\/ Initialize the warnings guard.\n    List<WarningsGuard> guards = Lists.newArrayList();\n\tif (options.checkGlobalThisLevel.isOn()) {\n      options.setWarningLevel(\n          DiagnosticGroups.GLOBAL_THIS,\n          options.checkGlobalThisLevel);\n    }\n"},{"entropy_rank":10,"patch_id":2,"patch_code":"if (options.checkGlobalThisLevel == null) {\n\t    throw new IllegalArgumentException(\"Null 'options.checkGlobalThisLevel' argument.\");\n\t}\nif (options.checkGlobalThisLevel.isOn()) {\n      options.setWarningLevel(\n          DiagnosticGroups.GLOBAL_THIS,\n          options.checkGlobalThisLevel);\n    }if (options.checkGlobalThisLevel.isOn()) {\n      options.setWarningLevel(\n          DiagnosticGroups.GLOBAL_THIS,\n          options.checkGlobalThisLevel);\n    }"},{"entropy_rank":11,"patch_id":8,"patch_code":"\n\n    if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) {\n      options.setWarningLevel(\n          DiagnosticGroups.ES5_STRICT,\n          CheckLevel.ERROR);\n    }\n\tif (options.checkGlobalThisLevel.isOn()) {\n      options.setWarningLevel(\n          DiagnosticGroups.GLOBAL_THIS,\n          options.checkGlobalThisLevel);\n    }\n"},{"entropy_rank":12,"patch_id":3,"patch_code":"if (options.checkGlobalThisLevel == null) {\n\t    return;\n\t}\nif (options.checkGlobalThisLevel.isOn()) {\n      options.setWarningLevel(\n          DiagnosticGroups.GLOBAL_THIS,\n          options.checkGlobalThisLevel);\n    }if (options.checkGlobalThisLevel.isOn()) {\n      options.setWarningLevel(\n          DiagnosticGroups.GLOBAL_THIS,\n          options.checkGlobalThisLevel);\n    }"},{"entropy_rank":13,"patch_id":1,"patch_code":"if (options.checkGlobalThisLevel != null) {\n\tif (options.checkGlobalThisLevel.isOn()) {\n      options.setWarningLevel(\n          DiagnosticGroups.GLOBAL_THIS,\n          options.checkGlobalThisLevel);\n    }\n\t}\nif (options.checkGlobalThisLevel.isOn()) {\n      options.setWarningLevel(\n          DiagnosticGroups.GLOBAL_THIS,\n          options.checkGlobalThisLevel);\n    }\n\t}\n"}],"Closure_6":[{"entropy_rank":1,"patch_id":2,"patch_code":"if (((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) || (!leftType.isNoType() && !rightType.canAssignTo(leftType))) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }"},{"entropy_rank":2,"patch_id":26,"patch_code":"if (leftType != rightType && ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType()))) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }"},{"entropy_rank":3,"patch_id":1,"patch_code":"if (leftType.isConstructor() || (leftType.isEnumType() && (rightType.isConstructor() || rightType.isEnumType()))) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }"},{"entropy_rank":4,"patch_id":10,"patch_code":"if (((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) || (!leftType.isNoType())) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }"},{"entropy_rank":5,"patch_id":18,"patch_code":"if (((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) || (leftType.isFunctionType())) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }"},{"entropy_rank":6,"patch_id":28,"patch_code":"if (leftType == rightType && ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType()))) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }"},{"entropy_rank":7,"patch_id":22,"patch_code":"if (((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) || (rightType.isFunctionType())) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }"},{"entropy_rank":8,"patch_id":6,"patch_code":"if (((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) || (!rightType.canAssignTo(leftType))) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }"},{"entropy_rank":9,"patch_id":4,"patch_code":"if (((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) || !(!leftType.isNoType() && !rightType.canAssignTo(leftType))) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }"},{"entropy_rank":10,"patch_id":27,"patch_code":"if (leftType != rightType || ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType()))) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }"},{"entropy_rank":11,"patch_id":29,"patch_code":"if (leftType == rightType || ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType()))) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }"},{"entropy_rank":12,"patch_id":11,"patch_code":"if (((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) && (!leftType.isNoType())) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }"},{"entropy_rank":13,"patch_id":3,"patch_code":"if (((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) && (!leftType.isNoType() && !rightType.canAssignTo(leftType))) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }"},{"entropy_rank":14,"patch_id":12,"patch_code":"if (((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) || !(!leftType.isNoType())) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }"},{"entropy_rank":15,"patch_id":25,"patch_code":"if (((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) && !(rightType.isFunctionType())) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }"},{"entropy_rank":16,"patch_id":23,"patch_code":"if (((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) && (rightType.isFunctionType())) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }"},{"entropy_rank":17,"patch_id":7,"patch_code":"if (((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) && (!rightType.canAssignTo(leftType))) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }"},{"entropy_rank":18,"patch_id":21,"patch_code":"if (((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) && !(leftType.isFunctionType())) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }"},{"entropy_rank":19,"patch_id":5,"patch_code":"if (((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) && !(!leftType.isNoType() && !rightType.canAssignTo(leftType))) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }"},{"entropy_rank":20,"patch_id":20,"patch_code":"if (((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) || !(leftType.isFunctionType())) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }"},{"entropy_rank":20,"patch_id":24,"patch_code":"if (((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) || !(rightType.isFunctionType())) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }"},{"entropy_rank":22,"patch_id":19,"patch_code":"if (((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) && (leftType.isFunctionType())) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }"},{"entropy_rank":23,"patch_id":8,"patch_code":"if (((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) || !(!rightType.canAssignTo(leftType))) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }"},{"entropy_rank":24,"patch_id":13,"patch_code":"if (((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) && !(!leftType.isNoType())) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }"},{"entropy_rank":25,"patch_id":9,"patch_code":"if (((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) && !(!rightType.canAssignTo(leftType))) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }"},{"entropy_rank":26,"patch_id":34,"patch_code":"if (leftType != this.nullOrUndefined && ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType()))) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }"},{"entropy_rank":27,"patch_id":37,"patch_code":"if (leftType == this.nullOrUndefined || ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType()))) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }"},{"entropy_rank":28,"patch_id":42,"patch_code":"if (rightType != this.nullOrUndefined && ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType()))) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }"},{"entropy_rank":29,"patch_id":45,"patch_code":"if (rightType == this.nullOrUndefined || ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType()))) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }"},{"entropy_rank":30,"patch_id":44,"patch_code":"if (rightType == this.nullOrUndefined && ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType()))) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }"},{"entropy_rank":31,"patch_id":36,"patch_code":"if (leftType == this.nullOrUndefined && ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType()))) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }"},{"entropy_rank":32,"patch_id":43,"patch_code":"if (rightType != this.nullOrUndefined || ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType()))) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }"},{"entropy_rank":33,"patch_id":35,"patch_code":"if (leftType != this.nullOrUndefined || ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType()))) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }"},{"entropy_rank":34,"patch_id":30,"patch_code":"if (leftType != this.allValueTypes && ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType()))) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }"},{"entropy_rank":35,"patch_id":38,"patch_code":"if (rightType != this.allValueTypes && ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType()))) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }"},{"entropy_rank":36,"patch_id":33,"patch_code":"if (leftType == this.allValueTypes || ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType()))) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }"},{"entropy_rank":37,"patch_id":40,"patch_code":"if (rightType == this.allValueTypes && ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType()))) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }"},{"entropy_rank":38,"patch_id":41,"patch_code":"if (rightType == this.allValueTypes || ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType()))) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }"},{"entropy_rank":39,"patch_id":32,"patch_code":"if (leftType == this.allValueTypes && ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType()))) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }"},{"entropy_rank":40,"patch_id":39,"patch_code":"if (rightType != this.allValueTypes || ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType()))) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }"},{"entropy_rank":41,"patch_id":31,"patch_code":"if (leftType != this.allValueTypes || ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType()))) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      \/\/ Do not type-check interface methods, because we expect that\n      \/\/ they will have dummy implementations that do not match the type\n      \/\/ annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }"}],"Closure_62":[{"entropy_rank":1,"patch_id":2,"patch_code":"if (excerpt.equals(LINE)\n          && 0!=charno && charno < sourceExcerpt.length()) {\n        for (int i = 0; i < charno; i++) {\n          char c = sourceExcerpt.charAt(i);\n          if (Character.isWhitespace(c)) {\n            b.append(c);\n          } else {\n            b.append(' ');\n          }\n        }\n        b.append(\"^\\n\");\n      }if (excerpt.equals(LINE)\n          && 0 <= charno && charno < sourceExcerpt.length()) {\n        for (int i = 0; i < charno; i++) {\n          char c = sourceExcerpt.charAt(i);\n          if (Character.isWhitespace(c)) {\n            b.append(c);\n          } else {\n            b.append(' ');\n          }\n        }\n        b.append(\"^\\n\");\n      }"},{"entropy_rank":2,"patch_id":8,"patch_code":"if (excerpt.equals(LINE)\n          && 0 <= charno && charno<=sourceExcerpt.length()) {\n        for (int i = 0; i < charno; i++) {\n          char c = sourceExcerpt.charAt(i);\n          if (Character.isWhitespace(c)) {\n            b.append(c);\n          } else {\n            b.append(' ');\n          }\n        }\n        b.append(\"^\\n\");\n      }if (excerpt.equals(LINE)\n          && 0 <= charno && charno < sourceExcerpt.length()) {\n        for (int i = 0; i < charno; i++) {\n          char c = sourceExcerpt.charAt(i);\n          if (Character.isWhitespace(c)) {\n            b.append(c);\n          } else {\n            b.append(' ');\n          }\n        }\n        b.append(\"^\\n\");\n      }"},{"entropy_rank":3,"patch_id":3,"patch_code":"if (excerpt.equals(LINE)\n          && 0<charno && charno < sourceExcerpt.length()) {\n        for (int i = 0; i < charno; i++) {\n          char c = sourceExcerpt.charAt(i);\n          if (Character.isWhitespace(c)) {\n            b.append(c);\n          } else {\n            b.append(' ');\n          }\n        }\n        b.append(\"^\\n\");\n      }if (excerpt.equals(LINE)\n          && 0 <= charno && charno < sourceExcerpt.length()) {\n        for (int i = 0; i < charno; i++) {\n          char c = sourceExcerpt.charAt(i);\n          if (Character.isWhitespace(c)) {\n            b.append(c);\n          } else {\n            b.append(' ');\n          }\n        }\n        b.append(\"^\\n\");\n      }"},{"entropy_rank":4,"patch_id":5,"patch_code":"if (excerpt.equals(LINE)\n          && 0>=charno && charno < sourceExcerpt.length()) {\n        for (int i = 0; i < charno; i++) {\n          char c = sourceExcerpt.charAt(i);\n          if (Character.isWhitespace(c)) {\n            b.append(c);\n          } else {\n            b.append(' ');\n          }\n        }\n        b.append(\"^\\n\");\n      }if (excerpt.equals(LINE)\n          && 0 <= charno && charno < sourceExcerpt.length()) {\n        for (int i = 0; i < charno; i++) {\n          char c = sourceExcerpt.charAt(i);\n          if (Character.isWhitespace(c)) {\n            b.append(c);\n          } else {\n            b.append(' ');\n          }\n        }\n        b.append(\"^\\n\");\n      }"},{"entropy_rank":5,"patch_id":4,"patch_code":"if (excerpt.equals(LINE)\n          && 0>charno && charno < sourceExcerpt.length()) {\n        for (int i = 0; i < charno; i++) {\n          char c = sourceExcerpt.charAt(i);\n          if (Character.isWhitespace(c)) {\n            b.append(c);\n          } else {\n            b.append(' ');\n          }\n        }\n        b.append(\"^\\n\");\n      }if (excerpt.equals(LINE)\n          && 0 <= charno && charno < sourceExcerpt.length()) {\n        for (int i = 0; i < charno; i++) {\n          char c = sourceExcerpt.charAt(i);\n          if (Character.isWhitespace(c)) {\n            b.append(c);\n          } else {\n            b.append(' ');\n          }\n        }\n        b.append(\"^\\n\");\n      }"},{"entropy_rank":6,"patch_id":1,"patch_code":"if (excerpt.equals(LINE)\n          && 0==charno && charno < sourceExcerpt.length()) {\n        for (int i = 0; i < charno; i++) {\n          char c = sourceExcerpt.charAt(i);\n          if (Character.isWhitespace(c)) {\n            b.append(c);\n          } else {\n            b.append(' ');\n          }\n        }\n        b.append(\"^\\n\");\n      }if (excerpt.equals(LINE)\n          && 0 <= charno && charno < sourceExcerpt.length()) {\n        for (int i = 0; i < charno; i++) {\n          char c = sourceExcerpt.charAt(i);\n          if (Character.isWhitespace(c)) {\n            b.append(c);\n          } else {\n            b.append(' ');\n          }\n        }\n        b.append(\"^\\n\");\n      }"},{"entropy_rank":7,"patch_id":7,"patch_code":"if (excerpt.equals(LINE)\n          && 0 <= charno && charno!=sourceExcerpt.length()) {\n        for (int i = 0; i < charno; i++) {\n          char c = sourceExcerpt.charAt(i);\n          if (Character.isWhitespace(c)) {\n            b.append(c);\n          } else {\n            b.append(' ');\n          }\n        }\n        b.append(\"^\\n\");\n      }if (excerpt.equals(LINE)\n          && 0 <= charno && charno < sourceExcerpt.length()) {\n        for (int i = 0; i < charno; i++) {\n          char c = sourceExcerpt.charAt(i);\n          if (Character.isWhitespace(c)) {\n            b.append(c);\n          } else {\n            b.append(' ');\n          }\n        }\n        b.append(\"^\\n\");\n      }"},{"entropy_rank":8,"patch_id":6,"patch_code":"if (excerpt.equals(LINE)\n          && 0 <= charno && charno==sourceExcerpt.length()) {\n        for (int i = 0; i < charno; i++) {\n          char c = sourceExcerpt.charAt(i);\n          if (Character.isWhitespace(c)) {\n            b.append(c);\n          } else {\n            b.append(' ');\n          }\n        }\n        b.append(\"^\\n\");\n      }if (excerpt.equals(LINE)\n          && 0 <= charno && charno < sourceExcerpt.length()) {\n        for (int i = 0; i < charno; i++) {\n          char c = sourceExcerpt.charAt(i);\n          if (Character.isWhitespace(c)) {\n            b.append(c);\n          } else {\n            b.append(' ');\n          }\n        }\n        b.append(\"^\\n\");\n      }"},{"entropy_rank":9,"patch_id":10,"patch_code":"if (excerpt.equals(LINE)\n          && 0 <= charno && charno>=sourceExcerpt.length()) {\n        for (int i = 0; i < charno; i++) {\n          char c = sourceExcerpt.charAt(i);\n          if (Character.isWhitespace(c)) {\n            b.append(c);\n          } else {\n            b.append(' ');\n          }\n        }\n        b.append(\"^\\n\");\n      }if (excerpt.equals(LINE)\n          && 0 <= charno && charno < sourceExcerpt.length()) {\n        for (int i = 0; i < charno; i++) {\n          char c = sourceExcerpt.charAt(i);\n          if (Character.isWhitespace(c)) {\n            b.append(c);\n          } else {\n            b.append(' ');\n          }\n        }\n        b.append(\"^\\n\");\n      }"},{"entropy_rank":10,"patch_id":9,"patch_code":"if (excerpt.equals(LINE)\n          && 0 <= charno && charno>sourceExcerpt.length()) {\n        for (int i = 0; i < charno; i++) {\n          char c = sourceExcerpt.charAt(i);\n          if (Character.isWhitespace(c)) {\n            b.append(c);\n          } else {\n            b.append(' ');\n          }\n        }\n        b.append(\"^\\n\");\n      }if (excerpt.equals(LINE)\n          && 0 <= charno && charno < sourceExcerpt.length()) {\n        for (int i = 0; i < charno; i++) {\n          char c = sourceExcerpt.charAt(i);\n          if (Character.isWhitespace(c)) {\n            b.append(c);\n          } else {\n            b.append(' ');\n          }\n        }\n        b.append(\"^\\n\");\n      }"}],"Closure_70":[{"entropy_rank":1,"patch_id":71,"patch_code":"defineSlot(astParameter, functionNode,\n                  jsDocParameter.getJSType(), false);defineSlot(astParameter, functionNode,\n                  jsDocParameter.getJSType(), true);"},{"entropy_rank":2,"patch_id":62,"patch_code":"if (functionNode == null) {\n\t    throw new IllegalArgumentException(\"Null 'functionNode' argument.\");\n\t}\ndefineSlot(astParameter, functionNode,\n                  jsDocParameter.getJSType(), true);defineSlot(astParameter, functionNode,\n                  jsDocParameter.getJSType(), true);"},{"entropy_rank":3,"patch_id":54,"patch_code":"if (astParameter == null) {\n\t    throw new IllegalArgumentException(\"Null 'astParameter' argument.\");\n\t}\ndefineSlot(astParameter, functionNode,\n                  jsDocParameter.getJSType(), true);defineSlot(astParameter, functionNode,\n                  jsDocParameter.getJSType(), true);"},{"entropy_rank":4,"patch_id":47,"patch_code":"defineSlot(astParameter, jsDocParameter,\n                  jsDocParameter.getJSType(), true);defineSlot(astParameter, functionNode,\n                  jsDocParameter.getJSType(), true);"},{"entropy_rank":5,"patch_id":46,"patch_code":"defineSlot(astParameter, body,\n                  jsDocParameter.getJSType(), true);defineSlot(astParameter, functionNode,\n                  jsDocParameter.getJSType(), true);"},{"entropy_rank":6,"patch_id":50,"patch_code":"defineSlot(astParameter, functionNode,\n                  jsDocParameters.getJSType(), true);defineSlot(astParameter, functionNode,\n                  jsDocParameter.getJSType(), true);"},{"entropy_rank":7,"patch_id":48,"patch_code":"defineSlot(astParameter, jsDocParameters,\n                  jsDocParameter.getJSType(), true);defineSlot(astParameter, functionNode,\n                  jsDocParameter.getJSType(), true);"},{"entropy_rank":8,"patch_id":49,"patch_code":"defineSlot(astParameter, astParameters,\n                  jsDocParameter.getJSType(), true);defineSlot(astParameter, functionNode,\n                  jsDocParameter.getJSType(), true);"},{"entropy_rank":9,"patch_id":51,"patch_code":"defineSlot(astParameter, functionNode,\n                  astParameters.getJSType(), true);defineSlot(astParameter, functionNode,\n                  jsDocParameter.getJSType(), true);"},{"entropy_rank":10,"patch_id":52,"patch_code":"defineSlot(astParameter, functionNode,\n                  body.getJSType(), true);defineSlot(astParameter, functionNode,\n                  jsDocParameter.getJSType(), true);"},{"entropy_rank":11,"patch_id":69,"patch_code":"if (astParameter == null) continue;\n\tif (functionNode == null) continue;\n\tdefineSlot(astParameter, functionNode,\n                  jsDocParameter.getJSType(), true);defineSlot(astParameter, functionNode,\n                  jsDocParameter.getJSType(), true);"},{"entropy_rank":12,"patch_id":56,"patch_code":"if (astParameter == null) astParameter = jsDocParameter;\n defineSlot(astParameter, functionNode,\n                  jsDocParameter.getJSType(), true);defineSlot(astParameter, functionNode,\n                  jsDocParameter.getJSType(), true);"},{"entropy_rank":13,"patch_id":57,"patch_code":"if (astParameter == null) astParameter = jsDocParameters;\n defineSlot(astParameter, functionNode,\n                  jsDocParameter.getJSType(), true);defineSlot(astParameter, functionNode,\n                  jsDocParameter.getJSType(), true);"},{"entropy_rank":14,"patch_id":55,"patch_code":"if (astParameter == null) {\n\t    return;\n\t}\ndefineSlot(astParameter, functionNode,\n                  jsDocParameter.getJSType(), true);defineSlot(astParameter, functionNode,\n                  jsDocParameter.getJSType(), true);"},{"entropy_rank":15,"patch_id":64,"patch_code":"if (functionNode == null) functionNode = jsDocParameter;\n defineSlot(astParameter, functionNode,\n                  jsDocParameter.getJSType(), true);defineSlot(astParameter, functionNode,\n                  jsDocParameter.getJSType(), true);"},{"entropy_rank":16,"patch_id":58,"patch_code":"if (astParameter == null) astParameter = body;\n defineSlot(astParameter, functionNode,\n                  jsDocParameter.getJSType(), true);defineSlot(astParameter, functionNode,\n                  jsDocParameter.getJSType(), true);"},{"entropy_rank":17,"patch_id":63,"patch_code":"if (functionNode == null) {\n\t    return;\n\t}\ndefineSlot(astParameter, functionNode,\n                  jsDocParameter.getJSType(), true);defineSlot(astParameter, functionNode,\n                  jsDocParameter.getJSType(), true);"},{"entropy_rank":18,"patch_id":59,"patch_code":"if (astParameter == null) astParameter = astParameters;\n defineSlot(astParameter, functionNode,\n                  jsDocParameter.getJSType(), true);defineSlot(astParameter, functionNode,\n                  jsDocParameter.getJSType(), true);"},{"entropy_rank":19,"patch_id":65,"patch_code":"if (functionNode == null) functionNode = jsDocParameters;\n defineSlot(astParameter, functionNode,\n                  jsDocParameter.getJSType(), true);defineSlot(astParameter, functionNode,\n                  jsDocParameter.getJSType(), true);"},{"entropy_rank":20,"patch_id":66,"patch_code":"if (functionNode == null) functionNode = body;\n defineSlot(astParameter, functionNode,\n                  jsDocParameter.getJSType(), true);defineSlot(astParameter, functionNode,\n                  jsDocParameter.getJSType(), true);"},{"entropy_rank":21,"patch_id":67,"patch_code":"if (functionNode == null) functionNode = astParameters;\n defineSlot(astParameter, functionNode,\n                  jsDocParameter.getJSType(), true);defineSlot(astParameter, functionNode,\n                  jsDocParameter.getJSType(), true);"},{"entropy_rank":22,"patch_id":53,"patch_code":"if (astParameter != null) {\n\tdefineSlot(astParameter, functionNode,\n                  jsDocParameter.getJSType(), true);\n\t}\ndefineSlot(astParameter, functionNode,\n                  jsDocParameter.getJSType(), true);\n\t}\n"},{"entropy_rank":23,"patch_id":70,"patch_code":"if (astParameter != null && functionNode != null) {\n\tdefineSlot(astParameter, functionNode,\n                  jsDocParameter.getJSType(), true);\n\t}\ndefineSlot(astParameter, functionNode,\n                  jsDocParameter.getJSType(), true);\n\t}\n"},{"entropy_rank":24,"patch_id":61,"patch_code":"if (functionNode != null) {\n\tdefineSlot(astParameter, functionNode,\n                  jsDocParameter.getJSType(), true);\n\t}\ndefineSlot(astParameter, functionNode,\n                  jsDocParameter.getJSType(), true);\n\t}\n"}],"Closure_73":[{"entropy_rank":1,"patch_id":8,"patch_code":"if (c > 0x1f && c<0x7f) {\n              sb.append(c);\n            } else {\n              \/\/ Other characters can be misinterpreted by some js parsers,\n              \/\/ or perhaps mangled by proxies along the way,\n              \/\/ so we play it safe and unicode escape them.\n              appendHexJavaScriptRepresentation(sb, c);\n            }if (c > 0x1f && c <= 0x7f) {\n              sb.append(c);\n            } else {\n              \/\/ Other characters can be misinterpreted by some js parsers,\n              \/\/ or perhaps mangled by proxies along the way,\n              \/\/ so we play it safe and unicode escape them.\n              appendHexJavaScriptRepresentation(sb, c);\n            }"},{"entropy_rank":2,"patch_id":5,"patch_code":"if (c>=0x1f && c <= 0x7f) {\n              sb.append(c);\n            } else {\n              \/\/ Other characters can be misinterpreted by some js parsers,\n              \/\/ or perhaps mangled by proxies along the way,\n              \/\/ so we play it safe and unicode escape them.\n              appendHexJavaScriptRepresentation(sb, c);\n            }if (c > 0x1f && c <= 0x7f) {\n              sb.append(c);\n            } else {\n              \/\/ Other characters can be misinterpreted by some js parsers,\n              \/\/ or perhaps mangled by proxies along the way,\n              \/\/ so we play it safe and unicode escape them.\n              appendHexJavaScriptRepresentation(sb, c);\n            }"},{"entropy_rank":3,"patch_id":7,"patch_code":"if (c > 0x1f && c!=0x7f) {\n              sb.append(c);\n            } else {\n              \/\/ Other characters can be misinterpreted by some js parsers,\n              \/\/ or perhaps mangled by proxies along the way,\n              \/\/ so we play it safe and unicode escape them.\n              appendHexJavaScriptRepresentation(sb, c);\n            }if (c > 0x1f && c <= 0x7f) {\n              sb.append(c);\n            } else {\n              \/\/ Other characters can be misinterpreted by some js parsers,\n              \/\/ or perhaps mangled by proxies along the way,\n              \/\/ so we play it safe and unicode escape them.\n              appendHexJavaScriptRepresentation(sb, c);\n            }"},{"entropy_rank":4,"patch_id":4,"patch_code":"if (c<=0x1f && c <= 0x7f) {\n              sb.append(c);\n            } else {\n              \/\/ Other characters can be misinterpreted by some js parsers,\n              \/\/ or perhaps mangled by proxies along the way,\n              \/\/ so we play it safe and unicode escape them.\n              appendHexJavaScriptRepresentation(sb, c);\n            }if (c > 0x1f && c <= 0x7f) {\n              sb.append(c);\n            } else {\n              \/\/ Other characters can be misinterpreted by some js parsers,\n              \/\/ or perhaps mangled by proxies along the way,\n              \/\/ so we play it safe and unicode escape them.\n              appendHexJavaScriptRepresentation(sb, c);\n            }"},{"entropy_rank":5,"patch_id":3,"patch_code":"if (c<0x1f && c <= 0x7f) {\n              sb.append(c);\n            } else {\n              \/\/ Other characters can be misinterpreted by some js parsers,\n              \/\/ or perhaps mangled by proxies along the way,\n              \/\/ so we play it safe and unicode escape them.\n              appendHexJavaScriptRepresentation(sb, c);\n            }if (c > 0x1f && c <= 0x7f) {\n              sb.append(c);\n            } else {\n              \/\/ Other characters can be misinterpreted by some js parsers,\n              \/\/ or perhaps mangled by proxies along the way,\n              \/\/ so we play it safe and unicode escape them.\n              appendHexJavaScriptRepresentation(sb, c);\n            }"},{"entropy_rank":6,"patch_id":9,"patch_code":"if (c > 0x1f && c>0x7f) {\n              sb.append(c);\n            } else {\n              \/\/ Other characters can be misinterpreted by some js parsers,\n              \/\/ or perhaps mangled by proxies along the way,\n              \/\/ so we play it safe and unicode escape them.\n              appendHexJavaScriptRepresentation(sb, c);\n            }if (c > 0x1f && c <= 0x7f) {\n              sb.append(c);\n            } else {\n              \/\/ Other characters can be misinterpreted by some js parsers,\n              \/\/ or perhaps mangled by proxies along the way,\n              \/\/ so we play it safe and unicode escape them.\n              appendHexJavaScriptRepresentation(sb, c);\n            }"},{"entropy_rank":7,"patch_id":6,"patch_code":"if (c > 0x1f && c==0x7f) {\n              sb.append(c);\n            } else {\n              \/\/ Other characters can be misinterpreted by some js parsers,\n              \/\/ or perhaps mangled by proxies along the way,\n              \/\/ so we play it safe and unicode escape them.\n              appendHexJavaScriptRepresentation(sb, c);\n            }if (c > 0x1f && c <= 0x7f) {\n              sb.append(c);\n            } else {\n              \/\/ Other characters can be misinterpreted by some js parsers,\n              \/\/ or perhaps mangled by proxies along the way,\n              \/\/ so we play it safe and unicode escape them.\n              appendHexJavaScriptRepresentation(sb, c);\n            }"},{"entropy_rank":8,"patch_id":1,"patch_code":"if (c==0x1f && c <= 0x7f) {\n              sb.append(c);\n            } else {\n              \/\/ Other characters can be misinterpreted by some js parsers,\n              \/\/ or perhaps mangled by proxies along the way,\n              \/\/ so we play it safe and unicode escape them.\n              appendHexJavaScriptRepresentation(sb, c);\n            }if (c > 0x1f && c <= 0x7f) {\n              sb.append(c);\n            } else {\n              \/\/ Other characters can be misinterpreted by some js parsers,\n              \/\/ or perhaps mangled by proxies along the way,\n              \/\/ so we play it safe and unicode escape them.\n              appendHexJavaScriptRepresentation(sb, c);\n            }"},{"entropy_rank":9,"patch_id":10,"patch_code":"if (c > 0x1f && c>=0x7f) {\n              sb.append(c);\n            } else {\n              \/\/ Other characters can be misinterpreted by some js parsers,\n              \/\/ or perhaps mangled by proxies along the way,\n              \/\/ so we play it safe and unicode escape them.\n              appendHexJavaScriptRepresentation(sb, c);\n            }if (c > 0x1f && c <= 0x7f) {\n              sb.append(c);\n            } else {\n              \/\/ Other characters can be misinterpreted by some js parsers,\n              \/\/ or perhaps mangled by proxies along the way,\n              \/\/ so we play it safe and unicode escape them.\n              appendHexJavaScriptRepresentation(sb, c);\n            }"},{"entropy_rank":10,"patch_id":2,"patch_code":"if (c!=0x1f && c <= 0x7f) {\n              sb.append(c);\n            } else {\n              \/\/ Other characters can be misinterpreted by some js parsers,\n              \/\/ or perhaps mangled by proxies along the way,\n              \/\/ so we play it safe and unicode escape them.\n              appendHexJavaScriptRepresentation(sb, c);\n            }if (c > 0x1f && c <= 0x7f) {\n              sb.append(c);\n            } else {\n              \/\/ Other characters can be misinterpreted by some js parsers,\n              \/\/ or perhaps mangled by proxies along the way,\n              \/\/ so we play it safe and unicode escape them.\n              appendHexJavaScriptRepresentation(sb, c);\n            }"}],"Closure_85":[{"entropy_rank":2,"patch_id":198,"patch_code":"case Token.NOT:case Token.BLOCK:"},{"entropy_rank":3,"patch_id":103,"patch_code":"if (outEdges != null) {\n\tif (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n\t}\nif (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n\t}\n"},{"entropy_rank":4,"patch_id":196,"patch_code":"case Token.EQ:case Token.BLOCK:"},{"entropy_rank":5,"patch_id":178,"patch_code":"case Token.DELPROP:case Token.BLOCK:"},{"entropy_rank":6,"patch_id":13,"patch_code":"if ((n.getParent() == null) && !(n.getType() == Token.FUNCTION || n.getType() == Token.SCRIPT)) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }if (n.getParent() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }"},{"entropy_rank":7,"patch_id":11,"patch_code":"if ((n.getParent() == null) && (n.getType() == Token.FUNCTION || n.getType() == Token.SCRIPT)) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }if (n.getParent() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }"},{"entropy_rank":8,"patch_id":10,"patch_code":"if ((n.getParent() == null) || (n.getType() == Token.FUNCTION || n.getType() == Token.SCRIPT)) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }if (n.getParent() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }"},{"entropy_rank":9,"patch_id":12,"patch_code":"if ((n.getParent() == null) || !(n.getType() == Token.FUNCTION || n.getType() == Token.SCRIPT)) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }if (n.getParent() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }"},{"entropy_rank":10,"patch_id":89,"patch_code":"\n    switch (n.getType()) {\n      case Token.BLOCK:\n        if (n.hasChildren()) {\n          Node first = n.getFirstChild();\n          return tryRemoveUnconditionalBranching(first);\n        } else {\n          return tryRemoveUnconditionalBranching(ControlFlowAnalysis.computeFollowNode(n));\n        }\n      case Token.RETURN:\n        if (n.hasChildren()) {\n          break;\n        }\n      case Token.BREAK:\n      case Token.CONTINUE:\n\n        \/\/ We are looking for a control flow changing statement that always\n        \/\/ branches to the same node. If removing it the control flow still\n        \/\/ branches to that same node. It is safe to remove it.\n        List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n        if (outEdges.size() == 1 &&\n            \/\/ If there is a next node, there is no chance this jump is useless.\n            (n.getNext() == null || n.getNext().getType() == Token.FUNCTION)) {\n\n          Preconditions.checkState(outEdges.get(0).getValue() == Branch.UNCOND);\n          Node fallThrough = tryRemoveUnconditionalBranching(computeFollowing(n));\n          Node nextCfgNode = outEdges.get(0).getDestination().getValue();\n          if (nextCfgNode == fallThrough) {\n            removeDeadExprStatementSafely(n);\n            return fallThrough;\n          }\n        }\n    }\n\tif (n.getParent() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }\n"},{"entropy_rank":11,"patch_id":14,"patch_code":"if ((n.getParent() == null) || (n.hasChildren())) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }if (n.getParent() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }"},{"entropy_rank":12,"patch_id":15,"patch_code":"if ((n.getParent() == null) && (n.hasChildren())) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }if (n.getParent() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }"},{"entropy_rank":13,"patch_id":177,"patch_code":"case Token.TYPEOF:case Token.BLOCK:"},{"entropy_rank":14,"patch_id":16,"patch_code":"if ((n.getParent() == null) || !(n.hasChildren())) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }if (n.getParent() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }"},{"entropy_rank":15,"patch_id":17,"patch_code":"if ((n.getParent() == null) && !(n.hasChildren())) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }if (n.getParent() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }"},{"entropy_rank":16,"patch_id":171,"patch_code":"case Token.RESERVED:case Token.BLOCK:"},{"entropy_rank":17,"patch_id":173,"patch_code":"case Token.WITH:case Token.BLOCK:"},{"entropy_rank":18,"patch_id":94,"patch_code":"removeDeadExprStatementSafely(n);if (n.getParent() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }"},{"entropy_rank":20,"patch_id":2,"patch_code":"if ((n.getParent() == null) || (n.getType() == Token.EMPTY ||\n        (n.getType() == Token.BLOCK && !n.hasChildren()))) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }if (n.getParent() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }"},{"entropy_rank":21,"patch_id":30,"patch_code":"if ((n.getParent() == null) || (n.getType() == Token.FUNCTION)) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }if (n.getParent() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }"},{"entropy_rank":22,"patch_id":3,"patch_code":"if ((n.getParent() == null) && (n.getType() == Token.EMPTY ||\n        (n.getType() == Token.BLOCK && !n.hasChildren()))) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }if (n.getParent() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }"},{"entropy_rank":23,"patch_id":26,"patch_code":"if ((n.getParent() == null) || ((removeNoOpStatements && !NodeUtil.mayHaveSideEffects(n)))) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }if (n.getParent() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }"},{"entropy_rank":24,"patch_id":31,"patch_code":"if ((n.getParent() == null) && (n.getType() == Token.FUNCTION)) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }if (n.getParent() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }"},{"entropy_rank":25,"patch_id":4,"patch_code":"if ((n.getParent() == null) || !(n.getType() == Token.EMPTY ||\n        (n.getType() == Token.BLOCK && !n.hasChildren()))) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }if (n.getParent() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }"},{"entropy_rank":26,"patch_id":5,"patch_code":"if ((n.getParent() == null) && !(n.getType() == Token.EMPTY ||\n        (n.getType() == Token.BLOCK && !n.hasChildren()))) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }if (n.getParent() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }"},{"entropy_rank":27,"patch_id":27,"patch_code":"if ((n.getParent() == null) && ((removeNoOpStatements && !NodeUtil.mayHaveSideEffects(n)))) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }if (n.getParent() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }"},{"entropy_rank":28,"patch_id":183,"patch_code":"case Token.WHILE:case Token.BLOCK:"},{"entropy_rank":29,"patch_id":193,"patch_code":"case Token.REF_MEMBER:case Token.BLOCK:"},{"entropy_rank":30,"patch_id":38,"patch_code":"if ((n.getParent() == null) || (NodeUtil.isTryCatchNodeContainer(n))) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }if (n.getParent() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }"},{"entropy_rank":31,"patch_id":28,"patch_code":"if ((n.getParent() == null) || !((removeNoOpStatements && !NodeUtil.mayHaveSideEffects(n)))) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }if (n.getParent() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }"},{"entropy_rank":32,"patch_id":39,"patch_code":"if ((n.getParent() == null) && (NodeUtil.isTryCatchNodeContainer(n))) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }if (n.getParent() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }"},{"entropy_rank":33,"patch_id":33,"patch_code":"if ((n.getParent() == null) && !(n.getType() == Token.FUNCTION)) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }if (n.getParent() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }"},{"entropy_rank":34,"patch_id":32,"patch_code":"if ((n.getParent() == null) || !(n.getType() == Token.FUNCTION)) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }if (n.getParent() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }"},{"entropy_rank":35,"patch_id":29,"patch_code":"if ((n.getParent() == null) && !((removeNoOpStatements && !NodeUtil.mayHaveSideEffects(n)))) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }if (n.getParent() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }"},{"entropy_rank":36,"patch_id":170,"patch_code":"case Token.DOTDOT:case Token.BLOCK:"},{"entropy_rank":37,"patch_id":41,"patch_code":"if ((n.getParent() == null) && !(NodeUtil.isTryCatchNodeContainer(n))) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }if (n.getParent() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }"},{"entropy_rank":38,"patch_id":34,"patch_code":"if ((n.getParent() == null) || (n.getType() == Token.SCRIPT)) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }if (n.getParent() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }"},{"entropy_rank":39,"patch_id":19,"patch_code":"if ((n.getParent() == null) && ((n.getType() == Token.BLOCK && !n.hasChildren()))) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }if (n.getParent() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }"},{"entropy_rank":40,"patch_id":35,"patch_code":"if ((n.getParent() == null) && (n.getType() == Token.SCRIPT)) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }if (n.getParent() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }"},{"entropy_rank":41,"patch_id":18,"patch_code":"if ((n.getParent() == null) || ((n.getType() == Token.BLOCK && !n.hasChildren()))) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }if (n.getParent() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }"},{"entropy_rank":42,"patch_id":49,"patch_code":"if (n.getFirstChild() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }if (n.getParent() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }"},{"entropy_rank":43,"patch_id":22,"patch_code":"if ((n.getParent() == null) || (n.getType() == Token.EMPTY)) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }if (n.getParent() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }"},{"entropy_rank":44,"patch_id":51,"patch_code":"if (n.getNext() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }if (n.getParent() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }"},{"entropy_rank":45,"patch_id":36,"patch_code":"if ((n.getParent() == null) || !(n.getType() == Token.SCRIPT)) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }if (n.getParent() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }"},{"entropy_rank":46,"patch_id":37,"patch_code":"if ((n.getParent() == null) && !(n.getType() == Token.SCRIPT)) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }if (n.getParent() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }"},{"entropy_rank":47,"patch_id":20,"patch_code":"if ((n.getParent() == null) || !((n.getType() == Token.BLOCK && !n.hasChildren()))) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }if (n.getParent() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }"},{"entropy_rank":49,"patch_id":21,"patch_code":"if ((n.getParent() == null) && !((n.getType() == Token.BLOCK && !n.hasChildren()))) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }if (n.getParent() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }"},{"entropy_rank":50,"patch_id":23,"patch_code":"if ((n.getParent() == null) && (n.getType() == Token.EMPTY)) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }if (n.getParent() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }"},{"entropy_rank":51,"patch_id":40,"patch_code":"if ((n.getParent() == null) || !(NodeUtil.isTryCatchNodeContainer(n))) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }if (n.getParent() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }"},{"entropy_rank":52,"patch_id":7,"patch_code":"if ((n.getParent() == null) && (gNode.getAnnotation() != GraphReachability.REACHABLE ||\n        (removeNoOpStatements && !NodeUtil.mayHaveSideEffects(n)))) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }if (n.getParent() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }"},{"entropy_rank":53,"patch_id":25,"patch_code":"if ((n.getParent() == null) && !(n.getType() == Token.EMPTY)) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }if (n.getParent() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }"},{"entropy_rank":54,"patch_id":1,"patch_code":"if (n.getParent() != null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }if (n.getParent() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }"},{"entropy_rank":55,"patch_id":50,"patch_code":"if (n.getLastChild() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }if (n.getParent() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }"},{"entropy_rank":56,"patch_id":24,"patch_code":"if ((n.getParent() == null) || !(n.getType() == Token.EMPTY)) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }if (n.getParent() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }"},{"entropy_rank":57,"patch_id":6,"patch_code":"if ((n.getParent() == null) || (gNode.getAnnotation() != GraphReachability.REACHABLE ||\n        (removeNoOpStatements && !NodeUtil.mayHaveSideEffects(n)))) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }if (n.getParent() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }"},{"entropy_rank":58,"patch_id":9,"patch_code":"if ((n.getParent() == null) && !(gNode.getAnnotation() != GraphReachability.REACHABLE ||\n        (removeNoOpStatements && !NodeUtil.mayHaveSideEffects(n)))) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }if (n.getParent() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }"},{"entropy_rank":59,"patch_id":8,"patch_code":"if ((n.getParent() == null) || !(gNode.getAnnotation() != GraphReachability.REACHABLE ||\n        (removeNoOpStatements && !NodeUtil.mayHaveSideEffects(n)))) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }if (n.getParent() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }"},{"entropy_rank":60,"patch_id":44,"patch_code":"if (n.getJSType() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }if (n.getParent() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }"},{"entropy_rank":62,"patch_id":65,"patch_code":"if (n.getJSDocInfo() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }if (n.getParent() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }"},{"entropy_rank":63,"patch_id":54,"patch_code":"if (n.removeFirstChild() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }if (n.getParent() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }"},{"entropy_rank":64,"patch_id":92,"patch_code":"if (n.getParent() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }"},{"entropy_rank":65,"patch_id":152,"patch_code":"case Token.EOC:case Token.BLOCK:"},{"entropy_rank":66,"patch_id":95,"patch_code":"removeDeadExprStatementSafely(n);\n\tif (n.getParent() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }if (n.getParent() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }"},{"entropy_rank":67,"patch_id":64,"patch_code":"if (n.getQualifiedName() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }if (n.getParent() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }"},{"entropy_rank":68,"patch_id":85,"patch_code":"if (n.getAncestors() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }if (n.getParent() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }"},{"entropy_rank":69,"patch_id":151,"patch_code":"case Token.REF_NAME:case Token.BLOCK:"},{"entropy_rank":70,"patch_id":53,"patch_code":"if (n.detachFromParent() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }if (n.getParent() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }"},{"entropy_rank":71,"patch_id":55,"patch_code":"if (n.removeChildren() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }if (n.getParent() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }"},{"entropy_rank":72,"patch_id":150,"patch_code":"case Token.REGEXP:case Token.BLOCK:"},{"entropy_rank":73,"patch_id":46,"patch_code":"if (n.children() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }if (n.getParent() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }"},{"entropy_rank":74,"patch_id":58,"patch_code":"if (n.getJsDocBuilderForNode() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }if (n.getParent() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }"},{"entropy_rank":75,"patch_id":56,"patch_code":"if (n.cloneNode() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }if (n.getParent() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }"},{"entropy_rank":76,"patch_id":52,"patch_code":"if (n.getLastSibling() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }if (n.getParent() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }"},{"entropy_rank":77,"patch_id":57,"patch_code":"if (n.cloneTree() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }if (n.getParent() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }"},{"entropy_rank":78,"patch_id":60,"patch_code":"if (n.getString() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }if (n.getParent() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }"},{"entropy_rank":79,"patch_id":47,"patch_code":"if (n.siblings() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }if (n.getParent() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }"},{"entropy_rank":80,"patch_id":101,"patch_code":"if (outEdges.size()>1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }"},{"entropy_rank":81,"patch_id":62,"patch_code":"if (n.toStringTree() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }if (n.getParent() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }"},{"entropy_rank":82,"patch_id":166,"patch_code":"case Token.SHEQ:case Token.BLOCK:"},{"entropy_rank":83,"patch_id":98,"patch_code":"if (outEdges.size()!=1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }"},{"entropy_rank":84,"patch_id":163,"patch_code":"case Token.OR:case Token.BLOCK:"},{"entropy_rank":85,"patch_id":100,"patch_code":"if (outEdges.size()<=1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }"},{"entropy_rank":86,"patch_id":61,"patch_code":"if (n.toString() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }if (n.getParent() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }"},{"entropy_rank":87,"patch_id":45,"patch_code":"if (n.getDirectives() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }if (n.getParent() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }"},{"entropy_rank":88,"patch_id":96,"patch_code":"if (n.getParent() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }\n\tremoveDeadExprStatementSafely(n);if (n.getParent() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }"},{"entropy_rank":89,"patch_id":108,"patch_code":"if (outEdges == null) return n;\n\t if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }"},{"entropy_rank":90,"patch_id":99,"patch_code":"if (outEdges.size()<1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }"},{"entropy_rank":91,"patch_id":109,"patch_code":"return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }"},{"entropy_rank":92,"patch_id":88,"patch_code":"if (n.getParent() == null) {\n      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n      if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }\n    }\n\tif (gNode == null) {\n      return n;\n    }\n\n    "},{"entropy_rank":93,"patch_id":194,"patch_code":"case Token.REF_SPECIAL:case Token.BLOCK:"},{"entropy_rank":94,"patch_id":154,"patch_code":"case Token.SETELEM_OP:case Token.BLOCK:"},{"entropy_rank":95,"patch_id":172,"patch_code":"case Token.GT:case Token.BLOCK:"},{"entropy_rank":96,"patch_id":116,"patch_code":"if (outEdges != null) {\n\treturn tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n\t}\nreturn tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n\t}\n"},{"entropy_rank":97,"patch_id":102,"patch_code":"if (outEdges.size()>=1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }if (outEdges.size() == 1) {\n        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n      }"}],"Closure_86":[{"entropy_rank":1,"patch_id":1,"patch_code":"return false;return true;"}],"Closure_92":[{"entropy_rank":1,"patch_id":8,"patch_code":"if (namespace == null) {\n\t    throw new IllegalArgumentException(\"Null 'namespace' argument.\");\n\t}\nint indexOfDot = namespace.indexOf('.');int indexOfDot = namespace.indexOf('.');"},{"entropy_rank":2,"patch_id":15,"patch_code":"replace();\n\tint indexOfDot = namespace.indexOf('.');int indexOfDot = namespace.indexOf('.');"},{"entropy_rank":3,"patch_id":9,"patch_code":"if (namespace == null) {\n\t    return;\n\t}\nint indexOfDot = namespace.indexOf('.');int indexOfDot = namespace.indexOf('.');"},{"entropy_rank":4,"patch_id":7,"patch_code":"if (namespace != null) {\n\tint indexOfDot = namespace.indexOf('.');\n          if (indexOfDot == -1) {\n            \/\/ Any old place is fine.\n            compiler.getNodeForCodeInsertion(minimumModule)\n                .addChildToBack(replacementNode);\n          } else {\n            \/\/ Add it after the parent namespace.\n            ProvidedName parentName =\n                providedNames.get(namespace.substring(0, indexOfDot));\n            Preconditions.checkNotNull(parentName);\n            Preconditions.checkNotNull(parentName.replacementNode);\n            parentName.replacementNode.getParent().addChildAfter(\n                replacementNode, parentName.replacementNode);\n          }\n\t}\nint indexOfDot = namespace.indexOf('.');\n          if (indexOfDot == -1) {\n            \/\/ Any old place is fine.\n            compiler.getNodeForCodeInsertion(minimumModule)\n                .addChildToBack(replacementNode);\n          } else {\n            \/\/ Add it after the parent namespace.\n            ProvidedName parentName =\n                providedNames.get(namespace.substring(0, indexOfDot));\n            Preconditions.checkNotNull(parentName);\n            Preconditions.checkNotNull(parentName.replacementNode);\n            parentName.replacementNode.getParent().addChildAfter(\n                replacementNode, parentName.replacementNode);\n          }\n\t}\n"},{"entropy_rank":5,"patch_id":16,"patch_code":"int indexOfDot = namespace.indexOf('.');\n\treplace();int indexOfDot = namespace.indexOf('.');"}],"Closure_99":[{"entropy_rank":1,"patch_id":3,"patch_code":"if ((jsDoc.isConstructor() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }"},{"entropy_rank":5,"patch_id":17,"patch_code":"if (jsDoc != null &&\n          (jsDoc.isImplicitCast() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }"},{"entropy_rank":8,"patch_id":18,"patch_code":"if (jsDoc != null &&\n          (jsDoc.isNoSideEffects() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }"},{"entropy_rank":10,"patch_id":13,"patch_code":"if (jsDoc != null &&\n          (jsDoc.isDeprecated() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }"},{"entropy_rank":11,"patch_id":20,"patch_code":"if (jsDoc != null &&\n          (jsDoc.isJavaDispatch() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }"},{"entropy_rank":12,"patch_id":19,"patch_code":"if (jsDoc != null &&\n          (jsDoc.isExterns() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }"},{"entropy_rank":13,"patch_id":60,"patch_code":"if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isDefine())) {\n        return false;\n      }if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }"},{"entropy_rank":15,"patch_id":9,"patch_code":"if (jsDoc != null &&\n          (jsDoc.isNoTypeCheck() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }"},{"entropy_rank":15,"patch_id":16,"patch_code":"if (jsDoc != null &&\n          (jsDoc.isNoShadow() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }"},{"entropy_rank":17,"patch_id":15,"patch_code":"if (jsDoc != null &&\n          (jsDoc.isExport() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }"},{"entropy_rank":18,"patch_id":27,"patch_code":"if (jsDoc != null &&\n          (jsDoc.hasBaseType() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }"},{"entropy_rank":22,"patch_id":10,"patch_code":"if (jsDoc != null &&\n          (jsDoc.shouldPreserveTry() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }"},{"entropy_rank":23,"patch_id":59,"patch_code":"if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isConstructor())) {\n        return false;\n      }if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }"},{"entropy_rank":24,"patch_id":67,"patch_code":"if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isExport())) {\n        return false;\n      }if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }"},{"entropy_rank":25,"patch_id":11,"patch_code":"if (jsDoc != null &&\n          (jsDoc.isOverride() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }"},{"entropy_rank":26,"patch_id":12,"patch_code":"if (jsDoc != null &&\n          (jsDoc.isNoAlias() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }"},{"entropy_rank":27,"patch_id":25,"patch_code":"if (jsDoc != null &&\n          (jsDoc.hasReturnType() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }"},{"entropy_rank":28,"patch_id":58,"patch_code":"if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isConstant())) {\n        return false;\n      }if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }"},{"entropy_rank":29,"patch_id":24,"patch_code":"if (jsDoc != null &&\n          (jsDoc.hasTypedefType() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }"},{"entropy_rank":30,"patch_id":22,"patch_code":"if (jsDoc != null &&\n          (jsDoc.hasType() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }"},{"entropy_rank":31,"patch_id":23,"patch_code":"if (jsDoc != null &&\n          (jsDoc.hasEnumParameterType() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }"},{"entropy_rank":32,"patch_id":14,"patch_code":"if (jsDoc != null &&\n          (jsDoc.isInterface() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }"},{"entropy_rank":33,"patch_id":65,"patch_code":"if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isDeprecated())) {\n        return false;\n      }if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }"},{"entropy_rank":34,"patch_id":63,"patch_code":"if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.hasThisType() ||\n           jsDoc.shouldPreserveTry())) {\n        return false;\n      }if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }"},{"entropy_rank":35,"patch_id":64,"patch_code":"if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isNoAlias())) {\n        return false;\n      }if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }"},{"entropy_rank":36,"patch_id":68,"patch_code":"if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isNoShadow())) {\n        return false;\n      }if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }"},{"entropy_rank":37,"patch_id":61,"patch_code":"if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isHidden())) {\n        return false;\n      }if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }"},{"entropy_rank":38,"patch_id":28,"patch_code":"if (jsDoc != null &&\n          (jsDoc.hasFileOverview() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }"},{"entropy_rank":39,"patch_id":26,"patch_code":"if (jsDoc != null &&\n          (jsDoc.hasThisType() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }"},{"entropy_rank":40,"patch_id":62,"patch_code":"if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isNoTypeCheck())) {\n        return false;\n      }if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }"},{"entropy_rank":41,"patch_id":66,"patch_code":"if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isInterface())) {\n        return false;\n      }if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }"},{"entropy_rank":42,"patch_id":2,"patch_code":"if (jsDoc != null) {\n        return false;\n      }if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }"},{"entropy_rank":45,"patch_id":69,"patch_code":"if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isImplicitCast())) {\n        return false;\n      }if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }"},{"entropy_rank":46,"patch_id":71,"patch_code":"if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isExterns())) {\n        return false;\n      }if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }"},{"entropy_rank":47,"patch_id":70,"patch_code":"if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isNoSideEffects())) {\n        return false;\n      }if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }"},{"entropy_rank":49,"patch_id":4,"patch_code":"if (jsDoc != null &&\n          (jsDoc.isConstructor() && jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }"},{"entropy_rank":52,"patch_id":112,"patch_code":"if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.isDefine() ||\n           jsDoc.isOverride())) {\n        return false;\n      }if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }"},{"entropy_rank":54,"patch_id":110,"patch_code":"if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.isConstant() ||\n           jsDoc.isOverride())) {\n        return false;\n      }if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }"},{"entropy_rank":56,"patch_id":111,"patch_code":"if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.isConstructor() ||\n           jsDoc.isOverride())) {\n        return false;\n      }if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }"},{"entropy_rank":57,"patch_id":7,"patch_code":"if (jsDoc != null &&\n          (jsDoc.isDefine() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }"},{"entropy_rank":60,"patch_id":8,"patch_code":"if (jsDoc != null &&\n          (jsDoc.isHidden() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }"},{"entropy_rank":61,"patch_id":6,"patch_code":"if (jsDoc != null &&\n          (jsDoc.isConstant() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }"},{"entropy_rank":62,"patch_id":5,"patch_code":"if (jsDoc != null || (jsDoc.isConstructor() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }"},{"entropy_rank":66,"patch_id":80,"patch_code":"if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.hasThisType() ||\n           jsDoc.hasFileOverview())) {\n        return false;\n      }if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }"},{"entropy_rank":67,"patch_id":1,"patch_code":"if (jsDoc == null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }"}],"Lang_10":[{"entropy_rank":1,"patch_id":16,"patch_code":"\n            wasWhite= false;\n            switch(c) {\n            case '\\'':\n                if(unquote) {\n                    if(++i==value.length()) {\n                        return regex;\n                    }\n                    c= value.charAt(i);\n                }\n                break;\n            case '?':\n            case '[':\n            case ']':\n            case '(':\n            case ')':\n            case '{':\n            case '}':\n            case '\\\\':\n            case '|':\n            case '*':\n            case '+':\n            case '^':\n            case '$':\n            case '.':\n                regex.append('\\\\');\n            }\n            regex.append(c);\n\tif(Character.isWhitespace(c)) {\n                if(!wasWhite) {\n                    wasWhite= true;\n                    regex.append(\"\\\\s*+\");\n                }\n                continue;\n            }\n"},{"entropy_rank":2,"patch_id":15,"patch_code":"\n            wasWhite= false;\n            switch(c) {\n            case '\\'':\n                if(unquote) {\n                    if(++i==value.length()) {\n                        return regex;\n                    }\n                    c= value.charAt(i);\n                }\n                break;\n            case '?':\n            case '[':\n            case ']':\n            case '(':\n            case ')':\n            case '{':\n            case '}':\n            case '\\\\':\n            case '|':\n            case '*':\n            case '+':\n            case '^':\n            case '$':\n            case '.':\n                regex.append('\\\\');\n            }\n\tif(Character.isWhitespace(c)) {\n                if(!wasWhite) {\n                    wasWhite= true;\n                    regex.append(\"\\\\s*+\");\n                }\n                continue;\n            }\n"},{"entropy_rank":3,"patch_id":18,"patch_code":"if(Character.isWhitespace(c)) {\n                if(!wasWhite) {\n                    wasWhite= true;\n                    regex.append(\"\\\\s*+\");\n                }\n                continue;\n            }"},{"entropy_rank":4,"patch_id":14,"patch_code":"\n            wasWhite= false;\n\tif(Character.isWhitespace(c)) {\n                if(!wasWhite) {\n                    wasWhite= true;\n                    regex.append(\"\\\\s*+\");\n                }\n                continue;\n            }\n"}],"Lang_13":[{"entropy_rank":1,"patch_id":2,"patch_code":"if (name == null) {\n\t    throw new IllegalArgumentException(\"Null 'name' argument.\");\n\t}\nreturn Class.forName(name, false, Thread.currentThread().getContextClassLoader());return Class.forName(name, false, Thread.currentThread().getContextClassLoader());"},{"entropy_rank":2,"patch_id":6,"patch_code":"if (name == null) return null;\n\tif (Thread.currentThread() == null) return null;\n\treturn Class.forName(name, false, Thread.currentThread().getContextClassLoader());return Class.forName(name, false, Thread.currentThread().getContextClassLoader());"},{"entropy_rank":3,"patch_id":3,"patch_code":"if (name == null) {\n\t    return null;\n\t}\nreturn Class.forName(name, false, Thread.currentThread().getContextClassLoader());return Class.forName(name, false, Thread.currentThread().getContextClassLoader());"},{"entropy_rank":4,"patch_id":9,"patch_code":"return Class.forName(name, true, Thread.currentThread().getContextClassLoader());return Class.forName(name, false, Thread.currentThread().getContextClassLoader());"},{"entropy_rank":5,"patch_id":8,"patch_code":"if (!(name != null && Thread.currentThread() != null)) return null;\n\treturn Class.forName(name, false, Thread.currentThread().getContextClassLoader());return Class.forName(name, false, Thread.currentThread().getContextClassLoader());"},{"entropy_rank":6,"patch_id":4,"patch_code":"if (name == null) name = new String();\n return Class.forName(name, false, Thread.currentThread().getContextClassLoader());return Class.forName(name, false, Thread.currentThread().getContextClassLoader());"},{"entropy_rank":7,"patch_id":10,"patch_code":""}],"Lang_15":[{"entropy_rank":1,"patch_id":24,"patch_code":"if (entry == null) continue;\n\tType toTypeArg = entry.getValue();Type toTypeArg = entry.getValue();"},{"entropy_rank":2,"patch_id":20,"patch_code":"if (entry == null) {\n\t    throw new IllegalArgumentException(\"Null 'entry' argument.\");\n\t}\nType toTypeArg = entry.getValue();Type toTypeArg = entry.getValue();"},{"entropy_rank":3,"patch_id":19,"patch_code":"if (entry != null) {\n\tType toTypeArg = entry.getValue();\n            Type fromTypeArg = fromTypeVarAssigns.get(entry.getKey());\n\n            \/\/ parameters must either be absent from the subject type, within\n            \/\/ the bounds of the wildcard type, or be an exact match to the\n            \/\/ parameters of the target type.\n            if (fromTypeArg != null\n                    && !toTypeArg.equals(fromTypeArg)\n                    && !(toTypeArg instanceof WildcardType && isAssignable(fromTypeArg, toTypeArg,\n                            typeVarAssigns))) {\n                return false;\n            }\n\t}\nType toTypeArg = entry.getValue();\n            Type fromTypeArg = fromTypeVarAssigns.get(entry.getKey());\n\n            \/\/ parameters must either be absent from the subject type, within\n            \/\/ the bounds of the wildcard type, or be an exact match to the\n            \/\/ parameters of the target type.\n            if (fromTypeArg != null\n                    && !toTypeArg.equals(fromTypeArg)\n                    && !(toTypeArg instanceof WildcardType && isAssignable(fromTypeArg, toTypeArg,\n                            typeVarAssigns))) {\n                return false;\n            }\n\t}\n"},{"entropy_rank":4,"patch_id":22,"patch_code":"if (entry == null) {\n\t    return true;\n\t}\nType toTypeArg = entry.getValue();Type toTypeArg = entry.getValue();"},{"entropy_rank":5,"patch_id":21,"patch_code":"if (entry == null) {\n\t    return false;\n\t}\nType toTypeArg = entry.getValue();Type toTypeArg = entry.getValue();"},{"entropy_rank":6,"patch_id":2,"patch_code":"if (toTypeVarAssigns == null) {\n\t    throw new IllegalArgumentException(\"Null 'toTypeVarAssigns' argument.\");\n\t}\nfor (Map.Entry<TypeVariable<?>, Type> entry : toTypeVarAssigns.entrySet()) {\n            Type toTypeArg = entry.getValue();\n            Type fromTypeArg = fromTypeVarAssigns.get(entry.getKey());\n\n            \/\/ parameters must either be absent from the subject type, within\n            \/\/ the bounds of the wildcard type, or be an exact match to the\n            \/\/ parameters of the target type.\n            if (fromTypeArg != null\n                    && !toTypeArg.equals(fromTypeArg)\n                    && !(toTypeArg instanceof WildcardType && isAssignable(fromTypeArg, toTypeArg,\n                            typeVarAssigns))) {\n                return false;\n            }\n        }for (Map.Entry<TypeVariable<?>, Type> entry : toTypeVarAssigns.entrySet()) {\n            Type toTypeArg = entry.getValue();\n            Type fromTypeArg = fromTypeVarAssigns.get(entry.getKey());\n\n            \/\/ parameters must either be absent from the subject type, within\n            \/\/ the bounds of the wildcard type, or be an exact match to the\n            \/\/ parameters of the target type.\n            if (fromTypeArg != null\n                    && !toTypeArg.equals(fromTypeArg)\n                    && !(toTypeArg instanceof WildcardType && isAssignable(fromTypeArg, toTypeArg,\n                            typeVarAssigns))) {\n                return false;\n            }\n        }"},{"entropy_rank":7,"patch_id":4,"patch_code":"if (toTypeVarAssigns == null) {\n\t    return true;\n\t}\nfor (Map.Entry<TypeVariable<?>, Type> entry : toTypeVarAssigns.entrySet()) {\n            Type toTypeArg = entry.getValue();\n            Type fromTypeArg = fromTypeVarAssigns.get(entry.getKey());\n\n            \/\/ parameters must either be absent from the subject type, within\n            \/\/ the bounds of the wildcard type, or be an exact match to the\n            \/\/ parameters of the target type.\n            if (fromTypeArg != null\n                    && !toTypeArg.equals(fromTypeArg)\n                    && !(toTypeArg instanceof WildcardType && isAssignable(fromTypeArg, toTypeArg,\n                            typeVarAssigns))) {\n                return false;\n            }\n        }for (Map.Entry<TypeVariable<?>, Type> entry : toTypeVarAssigns.entrySet()) {\n            Type toTypeArg = entry.getValue();\n            Type fromTypeArg = fromTypeVarAssigns.get(entry.getKey());\n\n            \/\/ parameters must either be absent from the subject type, within\n            \/\/ the bounds of the wildcard type, or be an exact match to the\n            \/\/ parameters of the target type.\n            if (fromTypeArg != null\n                    && !toTypeArg.equals(fromTypeArg)\n                    && !(toTypeArg instanceof WildcardType && isAssignable(fromTypeArg, toTypeArg,\n                            typeVarAssigns))) {\n                return false;\n            }\n        }"},{"entropy_rank":8,"patch_id":18,"patch_code":""},{"entropy_rank":9,"patch_id":3,"patch_code":"if (toTypeVarAssigns == null) {\n\t    return false;\n\t}\nfor (Map.Entry<TypeVariable<?>, Type> entry : toTypeVarAssigns.entrySet()) {\n            Type toTypeArg = entry.getValue();\n            Type fromTypeArg = fromTypeVarAssigns.get(entry.getKey());\n\n            \/\/ parameters must either be absent from the subject type, within\n            \/\/ the bounds of the wildcard type, or be an exact match to the\n            \/\/ parameters of the target type.\n            if (fromTypeArg != null\n                    && !toTypeArg.equals(fromTypeArg)\n                    && !(toTypeArg instanceof WildcardType && isAssignable(fromTypeArg, toTypeArg,\n                            typeVarAssigns))) {\n                return false;\n            }\n        }for (Map.Entry<TypeVariable<?>, Type> entry : toTypeVarAssigns.entrySet()) {\n            Type toTypeArg = entry.getValue();\n            Type fromTypeArg = fromTypeVarAssigns.get(entry.getKey());\n\n            \/\/ parameters must either be absent from the subject type, within\n            \/\/ the bounds of the wildcard type, or be an exact match to the\n            \/\/ parameters of the target type.\n            if (fromTypeArg != null\n                    && !toTypeArg.equals(fromTypeArg)\n                    && !(toTypeArg instanceof WildcardType && isAssignable(fromTypeArg, toTypeArg,\n                            typeVarAssigns))) {\n                return false;\n            }\n        }"},{"entropy_rank":10,"patch_id":29,"patch_code":"if (entry == null) {\n\t    throw new IllegalArgumentException(\"Null 'entry' argument.\");\n\t}\nType fromTypeArg = fromTypeVarAssigns.get(entry.getKey());Type fromTypeArg = fromTypeVarAssigns.get(entry.getKey());"},{"entropy_rank":11,"patch_id":17,"patch_code":"for (Map.Entry<TypeVariable<?>, Type> entry : toTypeVarAssigns.entrySet()) {\n            Type toTypeArg = entry.getValue();\n            Type fromTypeArg = fromTypeVarAssigns.get(entry.getKey());\n\n            \/\/ parameters must either be absent from the subject type, within\n            \/\/ the bounds of the wildcard type, or be an exact match to the\n            \/\/ parameters of the target type.\n            if (fromTypeArg != null\n                    && !toTypeArg.equals(fromTypeArg)\n                    && !(toTypeArg instanceof WildcardType && isAssignable(fromTypeArg, toTypeArg,\n                            typeVarAssigns))) {\n                return false;\n            }\n        }"},{"entropy_rank":12,"patch_id":27,"patch_code":"Type fromTypeArg = typeVarAssigns.get(entry.getKey());Type fromTypeArg = fromTypeVarAssigns.get(entry.getKey());"},{"entropy_rank":13,"patch_id":26,"patch_code":"Type fromTypeArg = toTypeVarAssigns.get(entry.getKey());Type fromTypeArg = fromTypeVarAssigns.get(entry.getKey());"},{"entropy_rank":14,"patch_id":1,"patch_code":"if (toTypeVarAssigns != null) {\n\tfor (Map.Entry<TypeVariable<?>, Type> entry : toTypeVarAssigns.entrySet()) {\n            Type toTypeArg = entry.getValue();\n            Type fromTypeArg = fromTypeVarAssigns.get(entry.getKey());\n\n            \/\/ parameters must either be absent from the subject type, within\n            \/\/ the bounds of the wildcard type, or be an exact match to the\n            \/\/ parameters of the target type.\n            if (fromTypeArg != null\n                    && !toTypeArg.equals(fromTypeArg)\n                    && !(toTypeArg instanceof WildcardType && isAssignable(fromTypeArg, toTypeArg,\n                            typeVarAssigns))) {\n                return false;\n            }\n        }\n\t}\nfor (Map.Entry<TypeVariable<?>, Type> entry : toTypeVarAssigns.entrySet()) {\n            Type toTypeArg = entry.getValue();\n            Type fromTypeArg = fromTypeVarAssigns.get(entry.getKey());\n\n            \/\/ parameters must either be absent from the subject type, within\n            \/\/ the bounds of the wildcard type, or be an exact match to the\n            \/\/ parameters of the target type.\n            if (fromTypeArg != null\n                    && !toTypeArg.equals(fromTypeArg)\n                    && !(toTypeArg instanceof WildcardType && isAssignable(fromTypeArg, toTypeArg,\n                            typeVarAssigns))) {\n                return false;\n            }\n        }\n\t}\n"},{"entropy_rank":15,"patch_id":35,"patch_code":"if (cls.getTypeParameters().length==0 || toClass.equals(cls)) {\n            return typeVarAssigns;\n        }if (cls.getTypeParameters().length > 0 || toClass.equals(cls)) {\n            return typeVarAssigns;\n        }"},{"entropy_rank":16,"patch_id":28,"patch_code":"if (entry != null) {\n\tType fromTypeArg = fromTypeVarAssigns.get(entry.getKey());\n\n            \/\/ parameters must either be absent from the subject type, within\n            \/\/ the bounds of the wildcard type, or be an exact match to the\n            \/\/ parameters of the target type.\n            if (fromTypeArg != null\n                    && !toTypeArg.equals(fromTypeArg)\n                    && !(toTypeArg instanceof WildcardType && isAssignable(fromTypeArg, toTypeArg,\n                            typeVarAssigns))) {\n                return false;\n            }\n\t}\nType fromTypeArg = fromTypeVarAssigns.get(entry.getKey());\n\n            \/\/ parameters must either be absent from the subject type, within\n            \/\/ the bounds of the wildcard type, or be an exact match to the\n            \/\/ parameters of the target type.\n            if (fromTypeArg != null\n                    && !toTypeArg.equals(fromTypeArg)\n                    && !(toTypeArg instanceof WildcardType && isAssignable(fromTypeArg, toTypeArg,\n                            typeVarAssigns))) {\n                return false;\n            }\n\t}\n"},{"entropy_rank":17,"patch_id":36,"patch_code":"if (cls.getTypeParameters().length!=0 || toClass.equals(cls)) {\n            return typeVarAssigns;\n        }if (cls.getTypeParameters().length > 0 || toClass.equals(cls)) {\n            return typeVarAssigns;\n        }"},{"entropy_rank":18,"patch_id":38,"patch_code":"if (cls.getTypeParameters().length<=0 || toClass.equals(cls)) {\n            return typeVarAssigns;\n        }if (cls.getTypeParameters().length > 0 || toClass.equals(cls)) {\n            return typeVarAssigns;\n        }"},{"entropy_rank":19,"patch_id":31,"patch_code":"if (entry == null) {\n\t    return true;\n\t}\nType fromTypeArg = fromTypeVarAssigns.get(entry.getKey());Type fromTypeArg = fromTypeVarAssigns.get(entry.getKey());"},{"entropy_rank":20,"patch_id":39,"patch_code":"if (cls.getTypeParameters().length>=0 || toClass.equals(cls)) {\n            return typeVarAssigns;\n        }if (cls.getTypeParameters().length > 0 || toClass.equals(cls)) {\n            return typeVarAssigns;\n        }"},{"entropy_rank":21,"patch_id":6,"patch_code":"if (toTypeVarAssigns == null) toTypeVarAssigns = typeVarAssigns;\n for (Map.Entry<TypeVariable<?>, Type> entry : toTypeVarAssigns.entrySet()) {\n            Type toTypeArg = entry.getValue();\n            Type fromTypeArg = fromTypeVarAssigns.get(entry.getKey());\n\n            \/\/ parameters must either be absent from the subject type, within\n            \/\/ the bounds of the wildcard type, or be an exact match to the\n            \/\/ parameters of the target type.\n            if (fromTypeArg != null\n                    && !toTypeArg.equals(fromTypeArg)\n                    && !(toTypeArg instanceof WildcardType && isAssignable(fromTypeArg, toTypeArg,\n                            typeVarAssigns))) {\n                return false;\n            }\n        }for (Map.Entry<TypeVariable<?>, Type> entry : toTypeVarAssigns.entrySet()) {\n            Type toTypeArg = entry.getValue();\n            Type fromTypeArg = fromTypeVarAssigns.get(entry.getKey());\n\n            \/\/ parameters must either be absent from the subject type, within\n            \/\/ the bounds of the wildcard type, or be an exact match to the\n            \/\/ parameters of the target type.\n            if (fromTypeArg != null\n                    && !toTypeArg.equals(fromTypeArg)\n                    && !(toTypeArg instanceof WildcardType && isAssignable(fromTypeArg, toTypeArg,\n                            typeVarAssigns))) {\n                return false;\n            }\n        }"},{"entropy_rank":22,"patch_id":5,"patch_code":"if (toTypeVarAssigns == null) toTypeVarAssigns = fromTypeVarAssigns;\n for (Map.Entry<TypeVariable<?>, Type> entry : toTypeVarAssigns.entrySet()) {\n            Type toTypeArg = entry.getValue();\n            Type fromTypeArg = fromTypeVarAssigns.get(entry.getKey());\n\n            \/\/ parameters must either be absent from the subject type, within\n            \/\/ the bounds of the wildcard type, or be an exact match to the\n            \/\/ parameters of the target type.\n            if (fromTypeArg != null\n                    && !toTypeArg.equals(fromTypeArg)\n                    && !(toTypeArg instanceof WildcardType && isAssignable(fromTypeArg, toTypeArg,\n                            typeVarAssigns))) {\n                return false;\n            }\n        }for (Map.Entry<TypeVariable<?>, Type> entry : toTypeVarAssigns.entrySet()) {\n            Type toTypeArg = entry.getValue();\n            Type fromTypeArg = fromTypeVarAssigns.get(entry.getKey());\n\n            \/\/ parameters must either be absent from the subject type, within\n            \/\/ the bounds of the wildcard type, or be an exact match to the\n            \/\/ parameters of the target type.\n            if (fromTypeArg != null\n                    && !toTypeArg.equals(fromTypeArg)\n                    && !(toTypeArg instanceof WildcardType && isAssignable(fromTypeArg, toTypeArg,\n                            typeVarAssigns))) {\n                return false;\n            }\n        }"},{"entropy_rank":23,"patch_id":37,"patch_code":"if (cls.getTypeParameters().length<0 || toClass.equals(cls)) {\n            return typeVarAssigns;\n        }if (cls.getTypeParameters().length > 0 || toClass.equals(cls)) {\n            return typeVarAssigns;\n        }"},{"entropy_rank":24,"patch_id":30,"patch_code":"if (entry == null) {\n\t    return false;\n\t}\nType fromTypeArg = fromTypeVarAssigns.get(entry.getKey());Type fromTypeArg = fromTypeVarAssigns.get(entry.getKey());"},{"entropy_rank":25,"patch_id":33,"patch_code":"if (entry == null) continue;\n\tType fromTypeArg = fromTypeVarAssigns.get(entry.getKey());Type fromTypeArg = fromTypeVarAssigns.get(entry.getKey());"}],"Lang_18":[{"entropy_rank":1,"patch_id":14,"patch_code":"if ((tokenLen >= 4) || (tokenLen == 3)) {\n                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n                } else {\n                    rule = TwoDigitYearField.INSTANCE;\n                }if (tokenLen >= 4) {\n                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n                } else {\n                    rule = TwoDigitYearField.INSTANCE;\n                }"},{"entropy_rank":2,"patch_id":18,"patch_code":"if ((tokenLen >= 4) || (tokenLen < 4)) {\n                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n                } else {\n                    rule = TwoDigitYearField.INSTANCE;\n                }if (tokenLen >= 4) {\n                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n                } else {\n                    rule = TwoDigitYearField.INSTANCE;\n                }"},{"entropy_rank":3,"patch_id":10,"patch_code":"if ((tokenLen >= 4) || (tokenLen == 1)) {\n                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n                } else {\n                    rule = TwoDigitYearField.INSTANCE;\n                }if (tokenLen >= 4) {\n                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n                } else {\n                    rule = TwoDigitYearField.INSTANCE;\n                }"},{"entropy_rank":4,"patch_id":6,"patch_code":"if ((tokenLen >= 4) || (tokenLen == 0)) {\n                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n                } else {\n                    rule = TwoDigitYearField.INSTANCE;\n                }if (tokenLen >= 4) {\n                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n                } else {\n                    rule = TwoDigitYearField.INSTANCE;\n                }"},{"entropy_rank":5,"patch_id":15,"patch_code":"if ((tokenLen >= 4) && (tokenLen == 3)) {\n                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n                } else {\n                    rule = TwoDigitYearField.INSTANCE;\n                }if (tokenLen >= 4) {\n                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n                } else {\n                    rule = TwoDigitYearField.INSTANCE;\n                }"},{"entropy_rank":6,"patch_id":17,"patch_code":"if ((tokenLen >= 4) && !(tokenLen == 3)) {\n                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n                } else {\n                    rule = TwoDigitYearField.INSTANCE;\n                }if (tokenLen >= 4) {\n                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n                } else {\n                    rule = TwoDigitYearField.INSTANCE;\n                }"},{"entropy_rank":7,"patch_id":11,"patch_code":"if ((tokenLen >= 4) && (tokenLen == 1)) {\n                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n                } else {\n                    rule = TwoDigitYearField.INSTANCE;\n                }if (tokenLen >= 4) {\n                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n                } else {\n                    rule = TwoDigitYearField.INSTANCE;\n                }"},{"entropy_rank":8,"patch_id":13,"patch_code":"if ((tokenLen >= 4) && !(tokenLen == 1)) {\n                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n                } else {\n                    rule = TwoDigitYearField.INSTANCE;\n                }if (tokenLen >= 4) {\n                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n                } else {\n                    rule = TwoDigitYearField.INSTANCE;\n                }"},{"entropy_rank":9,"patch_id":7,"patch_code":"if ((tokenLen >= 4) && (tokenLen == 0)) {\n                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n                } else {\n                    rule = TwoDigitYearField.INSTANCE;\n                }if (tokenLen >= 4) {\n                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n                } else {\n                    rule = TwoDigitYearField.INSTANCE;\n                }"},{"entropy_rank":10,"patch_id":16,"patch_code":"if ((tokenLen >= 4) || !(tokenLen == 3)) {\n                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n                } else {\n                    rule = TwoDigitYearField.INSTANCE;\n                }if (tokenLen >= 4) {\n                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n                } else {\n                    rule = TwoDigitYearField.INSTANCE;\n                }"},{"entropy_rank":11,"patch_id":9,"patch_code":"if ((tokenLen >= 4) && !(tokenLen == 0)) {\n                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n                } else {\n                    rule = TwoDigitYearField.INSTANCE;\n                }if (tokenLen >= 4) {\n                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n                } else {\n                    rule = TwoDigitYearField.INSTANCE;\n                }"},{"entropy_rank":11,"patch_id":12,"patch_code":"if ((tokenLen >= 4) || !(tokenLen == 1)) {\n                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n                } else {\n                    rule = TwoDigitYearField.INSTANCE;\n                }if (tokenLen >= 4) {\n                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n                } else {\n                    rule = TwoDigitYearField.INSTANCE;\n                }"},{"entropy_rank":13,"patch_id":8,"patch_code":"if ((tokenLen >= 4) || !(tokenLen == 0)) {\n                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n                } else {\n                    rule = TwoDigitYearField.INSTANCE;\n                }if (tokenLen >= 4) {\n                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n                } else {\n                    rule = TwoDigitYearField.INSTANCE;\n                }"},{"entropy_rank":14,"patch_id":1,"patch_code":"if (tokenLen==4) {\n                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n                } else {\n                    rule = TwoDigitYearField.INSTANCE;\n                }if (tokenLen >= 4) {\n                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n                } else {\n                    rule = TwoDigitYearField.INSTANCE;\n                }"},{"entropy_rank":15,"patch_id":5,"patch_code":"if (tokenLen>4) {\n                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n                } else {\n                    rule = TwoDigitYearField.INSTANCE;\n                }if (tokenLen >= 4) {\n                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n                } else {\n                    rule = TwoDigitYearField.INSTANCE;\n                }"},{"entropy_rank":16,"patch_id":3,"patch_code":"if (tokenLen<4) {\n                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n                } else {\n                    rule = TwoDigitYearField.INSTANCE;\n                }if (tokenLen >= 4) {\n                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n                } else {\n                    rule = TwoDigitYearField.INSTANCE;\n                }"},{"entropy_rank":17,"patch_id":2,"patch_code":"if (tokenLen!=4) {\n                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n                } else {\n                    rule = TwoDigitYearField.INSTANCE;\n                }if (tokenLen >= 4) {\n                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n                } else {\n                    rule = TwoDigitYearField.INSTANCE;\n                }"},{"entropy_rank":18,"patch_id":4,"patch_code":"if (tokenLen<=4) {\n                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n                } else {\n                    rule = TwoDigitYearField.INSTANCE;\n                }if (tokenLen >= 4) {\n                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n                } else {\n                    rule = TwoDigitYearField.INSTANCE;\n                }"}],"Lang_20":[{"entropy_rank":1,"patch_id":39,"patch_code":"StringBuilder buf = new StringBuilder((16) + 1);StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1);"},{"entropy_rank":2,"patch_id":5,"patch_code":"if (array[startIndex] == null) return null;\n\tif (array[startIndex].toString() == null) return null;\n\tStringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1);StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1);"},{"entropy_rank":4,"patch_id":35,"patch_code":"StringBuilder buf = new StringBuilder((array[startIndex] != null ? 16 : array[startIndex].toString().length()) + 1);StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1);"},{"entropy_rank":5,"patch_id":36,"patch_code":"StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) - 1);StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1);"},{"entropy_rank":6,"patch_id":37,"patch_code":"StringBuilder buf = new StringBuilder((16) + 1);StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1);"},{"entropy_rank":7,"patch_id":34,"patch_code":"StringBuilder buf = new StringBuilder();StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1);"},{"entropy_rank":8,"patch_id":38,"patch_code":"StringBuilder buf = new StringBuilder((array[startIndex].toString().length()) + 1);StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1);"},{"entropy_rank":9,"patch_id":1,"patch_code":"StringBuilder buf = new StringBuilder((array[endIndex] == null ? 16 : array[startIndex].toString().length()) + 1);StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1);"},{"entropy_rank":10,"patch_id":3,"patch_code":"StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[endIndex].toString().length()) + 1);StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1);"},{"entropy_rank":11,"patch_id":2,"patch_code":"StringBuilder buf = new StringBuilder((array[noOfItems] == null ? 16 : array[startIndex].toString().length()) + 1);StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1);"},{"entropy_rank":12,"patch_id":4,"patch_code":"StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[noOfItems].toString().length()) + 1);StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1);"}],"Lang_21":[{"entropy_rank":2,"patch_id":87,"patch_code":"return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR)<cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());"},{"entropy_rank":3,"patch_id":88,"patch_code":"return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR)<=cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());"},{"entropy_rank":4,"patch_id":90,"patch_code":"return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR)>=cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());"},{"entropy_rank":5,"patch_id":89,"patch_code":"return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR)>cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());"},{"entropy_rank":6,"patch_id":86,"patch_code":"return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR)!=cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());"},{"entropy_rank":7,"patch_id":96,"patch_code":"return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA)!=cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());"},{"entropy_rank":8,"patch_id":74,"patch_code":"return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND)>cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());"},{"entropy_rank":9,"patch_id":72,"patch_code":"return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND)<cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());"},{"entropy_rank":10,"patch_id":73,"patch_code":"return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND)<=cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());"},{"entropy_rank":11,"patch_id":71,"patch_code":"return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND)!=cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());"},{"entropy_rank":12,"patch_id":100,"patch_code":"return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA)>=cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());"},{"entropy_rank":13,"patch_id":79,"patch_code":"return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE)>cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());"},{"entropy_rank":14,"patch_id":75,"patch_code":"return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND)>=cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());"},{"entropy_rank":15,"patch_id":77,"patch_code":"return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE)<cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());"},{"entropy_rank":16,"patch_id":78,"patch_code":"return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE)<=cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());"},{"entropy_rank":17,"patch_id":98,"patch_code":"return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA)<=cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());"},{"entropy_rank":18,"patch_id":80,"patch_code":"return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE)>=cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());"},{"entropy_rank":19,"patch_id":76,"patch_code":"return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE)!=cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());"},{"entropy_rank":20,"patch_id":99,"patch_code":"return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA)>cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());"},{"entropy_rank":21,"patch_id":91,"patch_code":"return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR)!=cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());"},{"entropy_rank":22,"patch_id":97,"patch_code":"return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA)<cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());"},{"entropy_rank":23,"patch_id":94,"patch_code":"return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR)>cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());"},{"entropy_rank":24,"patch_id":92,"patch_code":"return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR)<cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());"},{"entropy_rank":25,"patch_id":66,"patch_code":"return (cal1.get(Calendar.MILLISECOND) != cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) != cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());"},{"entropy_rank":26,"patch_id":93,"patch_code":"return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR)<=cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());"},{"entropy_rank":27,"patch_id":95,"patch_code":"return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR)>=cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());"},{"entropy_rank":28,"patch_id":69,"patch_code":"return (cal1.get(Calendar.MILLISECOND) > cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) > cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());"},{"entropy_rank":29,"patch_id":67,"patch_code":"return (cal1.get(Calendar.MILLISECOND) < cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) < cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());"},{"entropy_rank":30,"patch_id":68,"patch_code":"return (cal1.get(Calendar.MILLISECOND) <= cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) <= cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());"},{"entropy_rank":31,"patch_id":70,"patch_code":"return (cal1.get(Calendar.MILLISECOND) >= cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) >= cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());"},{"entropy_rank":33,"patch_id":82,"patch_code":"return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR)<cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());"},{"entropy_rank":34,"patch_id":84,"patch_code":"return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR)>cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());"},{"entropy_rank":35,"patch_id":85,"patch_code":"return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR)>=cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());"},{"entropy_rank":36,"patch_id":83,"patch_code":"return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR)<=cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());"},{"entropy_rank":37,"patch_id":81,"patch_code":"return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR)!=cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());"},{"entropy_rank":39,"patch_id":63,"patch_code":"return (cal1.get(Calendar.MILLISECOND)<=cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());"},{"entropy_rank":40,"patch_id":65,"patch_code":"return (cal1.get(Calendar.MILLISECOND)>=cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());"},{"entropy_rank":41,"patch_id":64,"patch_code":"return (cal1.get(Calendar.MILLISECOND)>cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());"},{"entropy_rank":42,"patch_id":62,"patch_code":"return (cal1.get(Calendar.MILLISECOND)<cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());"},{"entropy_rank":43,"patch_id":61,"patch_code":"return (cal1.get(Calendar.MILLISECOND)!=cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());"},{"entropy_rank":45,"patch_id":101,"patch_code":"return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass()!=cal2.getClass());return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());"}],"Lang_22":[{"entropy_rank":1,"patch_id":6,"patch_code":"if (Math.abs(u) == 1 || Math.abs(v) == 1) {\n            return 1;\n        }if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n            return 1;\n        }"},{"entropy_rank":2,"patch_id":8,"patch_code":"if (Math.abs(u) < 1 || Math.abs(v) < 1) {\n            return 1;\n        }if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n            return 1;\n        }"},{"entropy_rank":3,"patch_id":7,"patch_code":"if (Math.abs(u) != 1 || Math.abs(v) != 1) {\n            return 1;\n        }if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n            return 1;\n        }"},{"entropy_rank":4,"patch_id":9,"patch_code":"if (Math.abs(u) > 1 || Math.abs(v) > 1) {\n            return 1;\n        }if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n            return 1;\n        }"},{"entropy_rank":5,"patch_id":10,"patch_code":"if (Math.abs(u) >= 1 || Math.abs(v) >= 1) {\n            return 1;\n        }if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n            return 1;\n        }"},{"entropy_rank":6,"patch_id":15,"patch_code":"if (Math.abs(u) <= 1 || Math.abs(v)>=1) {\n            return 1;\n        }if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n            return 1;\n        }"},{"entropy_rank":7,"patch_id":11,"patch_code":"if (Math.abs(u) <= 1 || Math.abs(v)==1) {\n            return 1;\n        }if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n            return 1;\n        }"},{"entropy_rank":8,"patch_id":13,"patch_code":"if (Math.abs(u) <= 1 || Math.abs(v)<1) {\n            return 1;\n        }if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n            return 1;\n        }"},{"entropy_rank":9,"patch_id":12,"patch_code":"if (Math.abs(u) <= 1 || Math.abs(v)!=1) {\n            return 1;\n        }if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n            return 1;\n        }"},{"entropy_rank":10,"patch_id":3,"patch_code":"if (Math.abs(u)<1 || Math.abs(v) <= 1) {\n            return 1;\n        }if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n            return 1;\n        }"},{"entropy_rank":11,"patch_id":1,"patch_code":"if (Math.abs(u)==1 || Math.abs(v) <= 1) {\n            return 1;\n        }if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n            return 1;\n        }"},{"entropy_rank":12,"patch_id":14,"patch_code":"if (Math.abs(u) <= 1 || Math.abs(v)>1) {\n            return 1;\n        }if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n            return 1;\n        }"},{"entropy_rank":13,"patch_id":5,"patch_code":"if (Math.abs(u)>=1 || Math.abs(v) <= 1) {\n            return 1;\n        }if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n            return 1;\n        }"},{"entropy_rank":14,"patch_id":4,"patch_code":"if (Math.abs(u)>1 || Math.abs(v) <= 1) {\n            return 1;\n        }if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n            return 1;\n        }"},{"entropy_rank":15,"patch_id":2,"patch_code":"if (Math.abs(u)!=1 || Math.abs(v) <= 1) {\n            return 1;\n        }if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n            return 1;\n        }"}],"Lang_24":[{"entropy_rank":1,"patch_id":12,"patch_code":"return (foundDigit && !hasExp) && !(hasDecPoint || hasExp);return foundDigit && !hasExp;"},{"entropy_rank":2,"patch_id":2,"patch_code":"return (foundDigit && !hasExp) && (i < sz || (i < sz + 1 && allowSigns && !foundDigit));return foundDigit && !hasExp;"},{"entropy_rank":3,"patch_id":10,"patch_code":"return (foundDigit && !hasExp) && (hasDecPoint || hasExp);return foundDigit && !hasExp;"},{"entropy_rank":4,"patch_id":1,"patch_code":"return (foundDigit && !hasExp) || (i < sz || (i < sz + 1 && allowSigns && !foundDigit));return foundDigit && !hasExp;"},{"entropy_rank":5,"patch_id":11,"patch_code":"return (foundDigit && !hasExp) || !(hasDecPoint || hasExp);return foundDigit && !hasExp;"},{"entropy_rank":6,"patch_id":3,"patch_code":"return (foundDigit && !hasExp) || !(i < sz || (i < sz + 1 && allowSigns && !foundDigit));return foundDigit && !hasExp;"},{"entropy_rank":7,"patch_id":5,"patch_code":"return (foundDigit && !hasExp) || ((i < sz + 1 && allowSigns && !foundDigit));return foundDigit && !hasExp;"},{"entropy_rank":8,"patch_id":9,"patch_code":"return (foundDigit && !hasExp) || (hasDecPoint || hasExp);return foundDigit && !hasExp;"},{"entropy_rank":9,"patch_id":4,"patch_code":"return (foundDigit && !hasExp) && !(i < sz || (i < sz + 1 && allowSigns && !foundDigit));return foundDigit && !hasExp;"},{"entropy_rank":10,"patch_id":6,"patch_code":"return (foundDigit && !hasExp) && ((i < sz + 1 && allowSigns && !foundDigit));return foundDigit && !hasExp;"},{"entropy_rank":11,"patch_id":7,"patch_code":"return (foundDigit && !hasExp) || !((i < sz + 1 && allowSigns && !foundDigit));return foundDigit && !hasExp;"},{"entropy_rank":12,"patch_id":8,"patch_code":"return (foundDigit && !hasExp) && !((i < sz + 1 && allowSigns && !foundDigit));return foundDigit && !hasExp;"},{"entropy_rank":13,"patch_id":13,"patch_code":"return (foundDigit && !hasExp) || (!foundDigit);return foundDigit && !hasExp;"},{"entropy_rank":14,"patch_id":14,"patch_code":"return (foundDigit && !hasExp) && (!foundDigit);return foundDigit && !hasExp;"},{"entropy_rank":15,"patch_id":15,"patch_code":"return (foundDigit && !hasExp) || !(!foundDigit);return foundDigit && !hasExp;"},{"entropy_rank":16,"patch_id":16,"patch_code":"return (foundDigit && !hasExp) && !(!foundDigit);return foundDigit && !hasExp;"}],"Lang_26":[{"entropy_rank":1,"patch_id":13,"patch_code":"if (mTimeZone == null) {\n\t    throw new IllegalArgumentException(\"Null 'mTimeZone' argument.\");\n\t}\nCalendar c = new GregorianCalendar(mTimeZone);Calendar c = new GregorianCalendar(mTimeZone);"},{"entropy_rank":2,"patch_id":14,"patch_code":"if (mTimeZone == null) {\n\t    return null;\n\t}\nCalendar c = new GregorianCalendar(mTimeZone);Calendar c = new GregorianCalendar(mTimeZone);"},{"entropy_rank":3,"patch_id":49,"patch_code":"Calendar c = new GregorianCalendar();Calendar c = new GregorianCalendar(mTimeZone);"},{"entropy_rank":4,"patch_id":6,"patch_code":"Calendar c = new GregorianCalendar(getTimeZone());Calendar c = new GregorianCalendar(mTimeZone);"},{"entropy_rank":5,"patch_id":45,"patch_code":"Calendar c = new GregorianCalendar(mTimeZone, this.mLocale);Calendar c = new GregorianCalendar(mTimeZone);"},{"entropy_rank":6,"patch_id":8,"patch_code":"Calendar c = new GregorianCalendar(getLocale());Calendar c = new GregorianCalendar(mTimeZone);"},{"entropy_rank":7,"patch_id":17,"patch_code":"if (mTimeZone == null) return cDefaultPattern;\n\t Calendar c = new GregorianCalendar(mTimeZone);Calendar c = new GregorianCalendar(mTimeZone);"},{"entropy_rank":8,"patch_id":18,"patch_code":"if (mTimeZone == null) return this.mPattern;\n\t Calendar c = new GregorianCalendar(mTimeZone);Calendar c = new GregorianCalendar(mTimeZone);"},{"entropy_rank":9,"patch_id":16,"patch_code":"if (mTimeZone == null) return new String();\n\t Calendar c = new GregorianCalendar(mTimeZone);Calendar c = new GregorianCalendar(mTimeZone);"}],"Lang_27":[{"entropy_rank":1,"patch_id":36,"patch_code":""},{"entropy_rank":2,"patch_id":35,"patch_code":"if (expPos < decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }"},{"entropy_rank":3,"patch_id":19,"patch_code":"if ((expPos < decPos) && (expPos < str.length() - 1)) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }if (expPos < decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }"},{"entropy_rank":4,"patch_id":18,"patch_code":"if ((expPos < decPos) || (expPos < str.length() - 1)) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }if (expPos < decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }"},{"entropy_rank":5,"patch_id":15,"patch_code":"if ((expPos < decPos) && (expPos > -1)) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }if (expPos < decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }"},{"entropy_rank":6,"patch_id":14,"patch_code":"if ((expPos < decPos) || (expPos > -1)) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }if (expPos < decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }"},{"entropy_rank":7,"patch_id":21,"patch_code":"if ((expPos < decPos) && !(expPos < str.length() - 1)) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }if (expPos < decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }"},{"entropy_rank":8,"patch_id":17,"patch_code":"if ((expPos < decPos) && !(expPos > -1)) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }if (expPos < decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }"},{"entropy_rank":9,"patch_id":16,"patch_code":"if ((expPos < decPos) || !(expPos > -1)) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }if (expPos < decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }"},{"entropy_rank":10,"patch_id":20,"patch_code":"if ((expPos < decPos) || !(expPos < str.length() - 1)) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }if (expPos < decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }"},{"entropy_rank":11,"patch_id":7,"patch_code":"if ((expPos < decPos) && (decPos > -1)) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }if (expPos < decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }"},{"entropy_rank":12,"patch_id":25,"patch_code":"if (expPos == decPos || (expPos < decPos)) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }if (expPos < decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }"},{"entropy_rank":13,"patch_id":11,"patch_code":"if ((expPos < decPos) && (expPos > -1 && expPos < str.length() - 1)) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }if (expPos < decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }"},{"entropy_rank":14,"patch_id":24,"patch_code":"if (expPos == decPos && (expPos < decPos)) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }if (expPos < decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }"},{"entropy_rank":15,"patch_id":30,"patch_code":"if (expPos > decPos && (expPos < decPos)) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }if (expPos < decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }"},{"entropy_rank":16,"patch_id":22,"patch_code":"if (expPos != decPos && (expPos < decPos)) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }if (expPos < decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }"},{"entropy_rank":17,"patch_id":31,"patch_code":"if (expPos > decPos || (expPos < decPos)) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }if (expPos < decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }"},{"entropy_rank":18,"patch_id":29,"patch_code":"if (expPos <= decPos || (expPos < decPos)) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }if (expPos < decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }"},{"entropy_rank":19,"patch_id":28,"patch_code":"if (expPos <= decPos && (expPos < decPos)) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }if (expPos < decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }"},{"entropy_rank":20,"patch_id":32,"patch_code":"if (expPos >= decPos && (expPos < decPos)) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }if (expPos < decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }"},{"entropy_rank":21,"patch_id":27,"patch_code":"if (expPos < decPos || (expPos < decPos)) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }if (expPos < decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }"},{"entropy_rank":22,"patch_id":33,"patch_code":"if (expPos >= decPos || (expPos < decPos)) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }if (expPos < decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }"},{"entropy_rank":23,"patch_id":26,"patch_code":"if (expPos < decPos && (expPos < decPos)) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }if (expPos < decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }"},{"entropy_rank":24,"patch_id":23,"patch_code":"if (expPos != decPos || (expPos < decPos)) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }if (expPos < decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }"},{"entropy_rank":25,"patch_id":10,"patch_code":"if ((expPos < decPos) || (expPos > -1 && expPos < str.length() - 1)) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }if (expPos < decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }"},{"entropy_rank":26,"patch_id":40,"patch_code":"mant = str.substring(0, decPos);mant = str.substring(0, expPos);"},{"entropy_rank":27,"patch_id":6,"patch_code":"if ((expPos < decPos) || (decPos > -1)) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }if (expPos < decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }"},{"entropy_rank":28,"patch_id":9,"patch_code":"if ((expPos < decPos) && !(decPos > -1)) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }if (expPos < decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }"},{"entropy_rank":29,"patch_id":8,"patch_code":"if ((expPos < decPos) || !(decPos > -1)) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }if (expPos < decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }"},{"entropy_rank":30,"patch_id":13,"patch_code":"if ((expPos < decPos) && !(expPos > -1 && expPos < str.length() - 1)) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }if (expPos < decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }"},{"entropy_rank":31,"patch_id":12,"patch_code":"if ((expPos < decPos) || !(expPos > -1 && expPos < str.length() - 1)) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }if (expPos < decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }"},{"entropy_rank":32,"patch_id":4,"patch_code":"if (expPos>decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }if (expPos < decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }"},{"entropy_rank":33,"patch_id":5,"patch_code":"if (expPos>=decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }if (expPos < decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }"},{"entropy_rank":34,"patch_id":1,"patch_code":"if (expPos==decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }if (expPos < decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }"},{"entropy_rank":35,"patch_id":3,"patch_code":"if (expPos<=decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }if (expPos < decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }"},{"entropy_rank":36,"patch_id":2,"patch_code":"if (expPos!=decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }if (expPos < decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }"}],"Lang_30":[{"entropy_rank":1,"patch_id":137,"patch_code":"if ((i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) && !((cs.charAt(i) != ' '))) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }"},{"entropy_rank":2,"patch_id":129,"patch_code":"if ((i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) && !(Character.isUpperCase(cs.charAt(i)) == false)) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }"},{"entropy_rank":3,"patch_id":131,"patch_code":"if ((i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) && ((Character.isLetter(cs.charAt(i)) == false))) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }"},{"entropy_rank":4,"patch_id":127,"patch_code":"if ((i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) && (Character.isUpperCase(cs.charAt(i)) == false)) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }"},{"entropy_rank":5,"patch_id":128,"patch_code":"if ((i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) || !(Character.isUpperCase(cs.charAt(i)) == false)) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }"},{"entropy_rank":8,"patch_id":3,"patch_code":"return csLen;return i;"},{"entropy_rank":10,"patch_id":2,"patch_code":"return searchLen;return i;"},{"entropy_rank":11,"patch_id":10,"patch_code":"if (i == csLast && j == searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }"},{"entropy_rank":12,"patch_id":14,"patch_code":"if (i >= csLast && j >= searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }"},{"entropy_rank":13,"patch_id":13,"patch_code":"if (i > csLast && j > searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }"},{"entropy_rank":14,"patch_id":11,"patch_code":"if (i != csLast && j != searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }"},{"entropy_rank":15,"patch_id":12,"patch_code":"if (i <= csLast && j <= searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }"},{"entropy_rank":17,"patch_id":5,"patch_code":"if (i==csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }"},{"entropy_rank":18,"patch_id":15,"patch_code":"if (i < csLast && j==searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }"},{"entropy_rank":18,"patch_id":9,"patch_code":"if (i>=csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }"},{"entropy_rank":20,"patch_id":27,"patch_code":"if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch<Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }"},{"entropy_rank":21,"patch_id":19,"patch_code":"if (i < csLast && j>=searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }"},{"entropy_rank":22,"patch_id":8,"patch_code":"if (i>csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }"},{"entropy_rank":23,"patch_id":6,"patch_code":"if (i!=csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }"},{"entropy_rank":24,"patch_id":126,"patch_code":"if ((i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) || (Character.isUpperCase(cs.charAt(i)) == false)) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }"},{"entropy_rank":25,"patch_id":17,"patch_code":"if (i < csLast && j<=searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }"},{"entropy_rank":26,"patch_id":18,"patch_code":"if (i < csLast && j>searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }"},{"entropy_rank":27,"patch_id":7,"patch_code":"if (i<=csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }"},{"entropy_rank":29,"patch_id":24,"patch_code":"if (i < csLast && j < searchLast && ch>Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }"},{"entropy_rank":30,"patch_id":83,"patch_code":"if ((i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) && (CharUtils.isAsciiPrintable(cs.charAt(i)) == false)) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }"},{"entropy_rank":31,"patch_id":22,"patch_code":"if (i < csLast && j < searchLast && ch<Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }"},{"entropy_rank":32,"patch_id":82,"patch_code":"if ((i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) || (CharUtils.isAsciiPrintable(cs.charAt(i)) == false)) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }"},{"entropy_rank":33,"patch_id":16,"patch_code":"if (i < csLast && j!=searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }"},{"entropy_rank":34,"patch_id":84,"patch_code":"if ((i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) || !(CharUtils.isAsciiPrintable(cs.charAt(i)) == false)) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }"},{"entropy_rank":35,"patch_id":26,"patch_code":"if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch!=Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }"},{"entropy_rank":37,"patch_id":85,"patch_code":"if ((i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) && !(CharUtils.isAsciiPrintable(cs.charAt(i)) == false)) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }"},{"entropy_rank":40,"patch_id":75,"patch_code":"if ((i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) && (Character.isUpperCase(ch))) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }"},{"entropy_rank":42,"patch_id":29,"patch_code":"if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch>=Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }"},{"entropy_rank":43,"patch_id":25,"patch_code":"if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch==Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }"},{"entropy_rank":44,"patch_id":59,"patch_code":"if ((i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) && ((Character.isLetter(cs.charAt(i)) == false) && (cs.charAt(i) != ' '))) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }"},{"entropy_rank":45,"patch_id":28,"patch_code":"if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch>Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }"},{"entropy_rank":48,"patch_id":23,"patch_code":"if (i < csLast && j < searchLast && ch<=Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }"},{"entropy_rank":49,"patch_id":77,"patch_code":"if ((i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) && !(Character.isUpperCase(ch))) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }"},{"entropy_rank":51,"patch_id":79,"patch_code":"if ((i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) && (Character.isDigit(cs.charAt(i)) == false)) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }"},{"entropy_rank":52,"patch_id":71,"patch_code":"if ((i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) && (Character.isLowerCase(cs.charAt(i)) == false)) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }"},{"entropy_rank":53,"patch_id":60,"patch_code":"if ((i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) || !((Character.isLetter(cs.charAt(i)) == false) && (cs.charAt(i) != ' '))) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }"},{"entropy_rank":54,"patch_id":61,"patch_code":"if ((i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) && !((Character.isLetter(cs.charAt(i)) == false) && (cs.charAt(i) != ' '))) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }"},{"entropy_rank":54,"patch_id":80,"patch_code":"if ((i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) || !(Character.isDigit(cs.charAt(i)) == false)) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }"},{"entropy_rank":57,"patch_id":73,"patch_code":"if ((i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) && !(Character.isLowerCase(cs.charAt(i)) == false)) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }"},{"entropy_rank":57,"patch_id":74,"patch_code":"if ((i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) || (Character.isUpperCase(ch))) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }"},{"entropy_rank":59,"patch_id":58,"patch_code":"if ((i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) || ((Character.isLetter(cs.charAt(i)) == false) && (cs.charAt(i) != ' '))) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }"},{"entropy_rank":60,"patch_id":81,"patch_code":"if ((i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) && !(Character.isDigit(cs.charAt(i)) == false)) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }"},{"entropy_rank":61,"patch_id":78,"patch_code":"if ((i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) || (Character.isDigit(cs.charAt(i)) == false)) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }"},{"entropy_rank":63,"patch_id":95,"patch_code":"if ((i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) && ((Character.isLetterOrDigit(cs.charAt(i)) == false) && (cs.charAt(i) != ' '))) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }"},{"entropy_rank":66,"patch_id":76,"patch_code":"if ((i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) || !(Character.isUpperCase(ch))) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }"},{"entropy_rank":68,"patch_id":70,"patch_code":"if ((i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) || (Character.isLowerCase(cs.charAt(i)) == false)) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }"},{"entropy_rank":69,"patch_id":96,"patch_code":"if ((i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) || !((Character.isLetterOrDigit(cs.charAt(i)) == false) && (cs.charAt(i) != ' '))) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }"},{"entropy_rank":71,"patch_id":72,"patch_code":"if ((i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) || !(Character.isLowerCase(cs.charAt(i)) == false)) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }"},{"entropy_rank":72,"patch_id":97,"patch_code":"if ((i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) && !((Character.isLetterOrDigit(cs.charAt(i)) == false) && (cs.charAt(i) != ' '))) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }"},{"entropy_rank":73,"patch_id":1,"patch_code":"return j;return i;"},{"entropy_rank":74,"patch_id":20,"patch_code":"if (i < csLast && j < searchLast && ch==Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }"},{"entropy_rank":79,"patch_id":21,"patch_code":"if (i < csLast && j < searchLast && ch!=Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }"},{"entropy_rank":80,"patch_id":94,"patch_code":"if ((i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) || ((Character.isLetterOrDigit(cs.charAt(i)) == false) && (cs.charAt(i) != ' '))) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }"},{"entropy_rank":82,"patch_id":132,"patch_code":"if ((i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) || !((Character.isLetter(cs.charAt(i)) == false))) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }"},{"entropy_rank":83,"patch_id":140,"patch_code":"if ((i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) || !(ch == CharUtils.CR || ch == CharUtils.LF)) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }"},{"entropy_rank":84,"patch_id":139,"patch_code":"if ((i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) && (ch == CharUtils.CR || ch == CharUtils.LF)) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }"},{"entropy_rank":85,"patch_id":141,"patch_code":"if ((i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) && !(ch == CharUtils.CR || ch == CharUtils.LF)) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                            \/\/ missing low surrogate, fine, like String.indexOf(String)\n                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return true;\n                        }\n                    } else {\n                        \/\/ ch is in the Basic Multilingual Plane\n                        return true;\n                    }"}],"Lang_33":[{"entropy_rank":1,"patch_id":3,"patch_code":"if (classes == null) {\n\t    throw new IllegalArgumentException(\"Null 'classes' argument.\");\n\t}\nclasses[i] = array[i].getClass();classes[i] = array[i].getClass();"},{"entropy_rank":2,"patch_id":4,"patch_code":"if (classes == null) {\n\t    return null;\n\t}\nclasses[i] = array[i].getClass();classes[i] = array[i].getClass();"},{"entropy_rank":3,"patch_id":9,"patch_code":"if (classes != null && array[i] != null) {\n\tclasses[i] = array[i].getClass();\n\t}\nclasses[i] = array[i].getClass();\n\t}\n"},{"entropy_rank":4,"patch_id":2,"patch_code":"if (classes != null) {\n\tclasses[i] = array[i].getClass();\n\t}\nclasses[i] = array[i].getClass();\n\t}\n"},{"entropy_rank":5,"patch_id":7,"patch_code":"if (classes == null) continue;\n\tif (array[i] == null) continue;\n\tclasses[i] = array[i].getClass();classes[i] = array[i].getClass();"},{"entropy_rank":6,"patch_id":8,"patch_code":"if (array[i] != null) {classes[i] = array[i].getClass();\n\t}\nclasses[i] = array[i].getClass();\n\t}\n"}],"Lang_39":[{"entropy_rank":1,"patch_id":3,"patch_code":"long greater = replacementList[i].length() - searchList[i].length();int greater = replacementList[i].length() - searchList[i].length();"},{"entropy_rank":2,"patch_id":1,"patch_code":"double greater = replacementList[i].length() - searchList[i].length();int greater = replacementList[i].length() - searchList[i].length();"},{"entropy_rank":3,"patch_id":2,"patch_code":"float greater = replacementList[i].length() - searchList[i].length();int greater = replacementList[i].length() - searchList[i].length();"},{"entropy_rank":4,"patch_id":7,"patch_code":"if (replacementList[i] == null) continue;\n\tif (searchList[i] == null) continue;\n\tint greater = replacementList[i].length() - searchList[i].length();int greater = replacementList[i].length() - searchList[i].length();"},{"entropy_rank":5,"patch_id":9,"patch_code":"if (replacementList[i] != null && searchList[i] != null) {\n\tint greater = replacementList[i].length() - searchList[i].length();\n            if (greater > 0) {\n                increase += 3 * greater; \/\/ assume 3 matches\n            }\n\t}\nint greater = replacementList[i].length() - searchList[i].length();\n            if (greater > 0) {\n                increase += 3 * greater; \/\/ assume 3 matches\n            }\n\t}\n"},{"entropy_rank":6,"patch_id":8,"patch_code":"if (searchList[i] != null) {int greater = replacementList[i].length() - searchList[i].length();\n            if (greater > 0) {\n                increase += 3 * greater; \/\/ assume 3 matches\n            }\n\t}\nint greater = replacementList[i].length() - searchList[i].length();\n            if (greater > 0) {\n                increase += 3 * greater; \/\/ assume 3 matches\n            }\n\t}\n"}],"Lang_47":[{"entropy_rank":1,"patch_id":44,"patch_code":"int strLen = this.newLine.length();int strLen = str.length();"},{"entropy_rank":2,"patch_id":29,"patch_code":"if (str == null) {\n\t    throw new IllegalArgumentException(\"Null 'str' argument.\");\n\t}\nint strLen = str.length();int strLen = str.length();"},{"entropy_rank":3,"patch_id":63,"patch_code":"int strLen = toStringBuffer().length();int strLen = str.length();"},{"entropy_rank":4,"patch_id":10,"patch_code":"int strLen = getNullText().length();int strLen = str.length();"},{"entropy_rank":8,"patch_id":43,"patch_code":"int strLen = this.nullText.length();int strLen = str.length();"},{"entropy_rank":9,"patch_id":55,"patch_code":"int strLen = appendNull().length();int strLen = str.length();"},{"entropy_rank":10,"patch_id":66,"patch_code":"if (str == null) {\n\t    return null;\n\t}\nint strLen = str.length();int strLen = str.length();"},{"entropy_rank":12,"patch_id":54,"patch_code":"int strLen = appendNewLine().length();int strLen = str.length();"},{"entropy_rank":13,"patch_id":52,"patch_code":"int strLen = clear().length();int strLen = str.length();"},{"entropy_rank":14,"patch_id":32,"patch_code":"if (str == null) str = this.nullText;\n int strLen = str.length();int strLen = str.length();"},{"entropy_rank":15,"patch_id":67,"patch_code":"if (str == null) str = this.newLine;\n int strLen = str.length();int strLen = str.length();"},{"entropy_rank":16,"patch_id":33,"patch_code":"if (str == null) str = new String();\n int strLen = str.length();int strLen = str.length();"},{"entropy_rank":17,"patch_id":26,"patch_code":"int strLen = toString().length();int strLen = str.length();"},{"entropy_rank":18,"patch_id":27,"patch_code":"int strLen = toStringBuffer().length();int strLen = str.length();"},{"entropy_rank":19,"patch_id":19,"patch_code":"int strLen = appendNull().length();int strLen = str.length();"},{"entropy_rank":20,"patch_id":21,"patch_code":"int strLen = trim().length();int strLen = str.length();"},{"entropy_rank":21,"patch_id":9,"patch_code":"int strLen = getNewLineText().length();int strLen = str.length();"},{"entropy_rank":23,"patch_id":20,"patch_code":"int strLen = reverse().length();int strLen = str.length();"},{"entropy_rank":24,"patch_id":7,"patch_code":"int strLen = this.nullText.length();int strLen = str.length();"},{"entropy_rank":25,"patch_id":18,"patch_code":"int strLen = appendNewLine().length();int strLen = str.length();"},{"entropy_rank":27,"patch_id":68,"patch_code":"if (str == null) str = this.nullText;\n int strLen = str.length();int strLen = str.length();"},{"entropy_rank":28,"patch_id":34,"patch_code":"if (str == null) return new StrBuilder();\n\t int strLen = str.length();int strLen = str.length();"},{"entropy_rank":29,"patch_id":65,"patch_code":"if (str == null) {\n\t    throw new IllegalArgumentException(\"Null 'str' argument.\");\n\t}\nint strLen = str.length();int strLen = str.length();"},{"entropy_rank":30,"patch_id":31,"patch_code":"if (str == null) str = this.newLine;\n int strLen = str.length();int strLen = str.length();"},{"entropy_rank":31,"patch_id":16,"patch_code":"int strLen = clear().length();int strLen = str.length();"},{"entropy_rank":33,"patch_id":64,"patch_code":"if (str != null) {\n\tint strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(0, width, buffer, size);\n            } else {\n                int padLen = width - strLen;\n                str.getChars(0, strLen, buffer, size);\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + strLen + i] = padChar;\n                }\n            }\n\t}\nint strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(0, width, buffer, size);\n            } else {\n                int padLen = width - strLen;\n                str.getChars(0, strLen, buffer, size);\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + strLen + i] = padChar;\n                }\n            }\n\t}\n"},{"entropy_rank":34,"patch_id":8,"patch_code":"int strLen = this.newLine.length();int strLen = str.length();"},{"entropy_rank":35,"patch_id":30,"patch_code":"if (str == null) {\n\t    return null;\n\t}\nint strLen = str.length();int strLen = str.length();"},{"entropy_rank":36,"patch_id":13,"patch_code":"int strLen = minimizeCapacity().length();int strLen = str.length();"},{"entropy_rank":37,"patch_id":62,"patch_code":"int strLen = toString().length();int strLen = str.length();"},{"entropy_rank":38,"patch_id":28,"patch_code":"if (str != null) {\n\tint strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(strLen - width, strLen, buffer, size);\n            } else {\n                int padLen = width - strLen;\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + i] = padChar;\n                }\n                str.getChars(0, strLen, buffer, size + padLen);\n            }\n\t}\nint strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(strLen - width, strLen, buffer, size);\n            } else {\n                int padLen = width - strLen;\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + i] = padChar;\n                }\n                str.getChars(0, strLen, buffer, size + padLen);\n            }\n\t}\n"}],"Lang_50":[{"entropy_rank":1,"patch_id":52,"patch_code":"if (key == null) {\n\t    throw new IllegalArgumentException(\"Null 'key' argument.\");\n\t}\nkey = new Pair(key, locale);key = new Pair(key, locale);"},{"entropy_rank":2,"patch_id":53,"patch_code":"if (key == null) {\n\t    return null;\n\t}\nkey = new Pair(key, locale);key = new Pair(key, locale);"},{"entropy_rank":3,"patch_id":54,"patch_code":"if (key == null) key = new Object();\n key = new Pair(key, locale);key = new Pair(key, locale);"},{"entropy_rank":5,"patch_id":23,"patch_code":"key = new Pair(key, locale);if (locale != null) {\n            key = new Pair(key, locale);\n        }"},{"entropy_rank":6,"patch_id":24,"patch_code":"if (locale != null) {\n            key = new Pair(key, locale);\n        }"},{"entropy_rank":7,"patch_id":21,"patch_code":"\n\n\n        FastDateFormat format = (FastDateFormat) cDateInstanceCache.get(key);\n        if (format == null) {\n            if (locale == null) {\n                locale = Locale.getDefault();\n            }\n            try {\n                SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateInstance(style, locale);\n                String pattern = formatter.toPattern();\n                format = getInstance(pattern, timeZone, locale);\n                cDateInstanceCache.put(key, format);\n                \n            } catch (ClassCastException ex) {\n                throw new IllegalArgumentException(\"No date pattern for locale: \" + locale);\n            }\n        }\n\tif (locale != null) {\n            key = new Pair(key, locale);\n        }\n"},{"entropy_rank":8,"patch_id":51,"patch_code":"if (key != null) {\n\tkey = new Pair(key, locale);\n\t}\nkey = new Pair(key, locale);\n\t}\n"},{"entropy_rank":9,"patch_id":113,"patch_code":"if (getDefaultPattern() == null) {\n                locale = Locale.getDefault();\n            }if (locale == null) {\n                locale = Locale.getDefault();\n            }"},{"entropy_rank":11,"patch_id":19,"patch_code":"if (locale != null) {\n            key = new Pair(key, locale);\n        }\n\tif (timeZone != null) {\n            key = new Pair(key, timeZone);\n        }\n\n        "},{"entropy_rank":17,"patch_id":106,"patch_code":"if (locale != null) {\n                locale = Locale.getDefault();\n            }if (locale == null) {\n                locale = Locale.getDefault();\n            }"},{"entropy_rank":18,"patch_id":20,"patch_code":"\n\n\n        FastDateFormat format = (FastDateFormat) cDateInstanceCache.get(key);\n\tif (locale != null) {\n            key = new Pair(key, locale);\n        }\n"},{"entropy_rank":19,"patch_id":1,"patch_code":"if (locale == null) {\n            key = new Pair(key, locale);\n        }if (locale != null) {\n            key = new Pair(key, locale);\n        }"},{"entropy_rank":22,"patch_id":112,"patch_code":"if (getInstance() == null) {\n                locale = Locale.getDefault();\n            }if (locale == null) {\n                locale = Locale.getDefault();\n            }"},{"entropy_rank":23,"patch_id":103,"patch_code":"key = new Pair(key, locale);"},{"entropy_rank":24,"patch_id":7,"patch_code":"if (getInstance() != null) {\n            key = new Pair(key, locale);\n        }if (locale != null) {\n            key = new Pair(key, locale);\n        }"},{"entropy_rank":25,"patch_id":8,"patch_code":"if (getDefaultPattern() != null) {\n            key = new Pair(key, locale);\n        }if (locale != null) {\n            key = new Pair(key, locale);\n        }"},{"entropy_rank":27,"patch_id":123,"patch_code":"locale = Locale.getDefault();if (locale == null) {\n                locale = Locale.getDefault();\n            }"},{"entropy_rank":28,"patch_id":30,"patch_code":"key = new Pair(getDefaultPattern(), locale);key = new Pair(key, locale);"},{"entropy_rank":29,"patch_id":29,"patch_code":"key = new Pair(getInstance(), locale);key = new Pair(key, locale);"},{"entropy_rank":30,"patch_id":40,"patch_code":"key = new Pair(key, getInstance());key = new Pair(key, locale);"},{"entropy_rank":31,"patch_id":41,"patch_code":"key = new Pair(key, getDefaultPattern());key = new Pair(key, locale);"}],"Lang_51":[{"entropy_rank":1,"patch_id":3,"patch_code":""},{"entropy_rank":2,"patch_id":4,"patch_code":"case 3: {\n                char ch = str.charAt(0);\n                if (ch == 'y') {\n                    return \n                        (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                        (str.charAt(2) == 's' || str.charAt(2) == 'S');\n                }\n                if (ch == 'Y') {\n                    return \n                        (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                        (str.charAt(2) == 'S' || str.charAt(2) == 's');\n                }\n\t return false;\ncase 3: {\n                char ch = str.charAt(0);\n                if (ch == 'y') {\n                    return \n                        (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                        (str.charAt(2) == 's' || str.charAt(2) == 'S');\n                }\n                if (ch == 'Y') {\n                    return \n                        (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                        (str.charAt(2) == 'S' || str.charAt(2) == 's');\n                }"},{"entropy_rank":3,"patch_id":5,"patch_code":"case 3: {\n                char ch = str.charAt(0);\n                if (ch == 'y') {\n                    return \n                        (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                        (str.charAt(2) == 's' || str.charAt(2) == 'S');\n                }\n                if (ch == 'Y') {\n                    return \n                        (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                        (str.charAt(2) == 'S' || str.charAt(2) == 's');\n                }\n\t return true;\ncase 3: {\n                char ch = str.charAt(0);\n                if (ch == 'y') {\n                    return \n                        (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                        (str.charAt(2) == 's' || str.charAt(2) == 'S');\n                }\n                if (ch == 'Y') {\n                    return \n                        (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                        (str.charAt(2) == 'S' || str.charAt(2) == 's');\n                }"}],"Lang_57":[{"entropy_rank":1,"patch_id":38,"patch_code":"return availableLocaleSet().contains(locale);return cAvailableLocaleSet.contains(locale);"},{"entropy_rank":2,"patch_id":37,"patch_code":"return availableLocaleList().contains(locale);return cAvailableLocaleSet.contains(locale);"},{"entropy_rank":3,"patch_id":5,"patch_code":"return (cAvailableLocaleSet.contains(locale)) || (locale.getVariant().length() > 0);return cAvailableLocaleSet.contains(locale);"},{"entropy_rank":4,"patch_id":1,"patch_code":"return (cAvailableLocaleSet.contains(locale)) || (locale.getCountry().length() > 0);return cAvailableLocaleSet.contains(locale);"},{"entropy_rank":6,"patch_id":33,"patch_code":"return (cAvailableLocaleSet.contains(locale)) || (locale.getCountry().length() != 0);return cAvailableLocaleSet.contains(locale);"},{"entropy_rank":7,"patch_id":4,"patch_code":"return (cAvailableLocaleSet.contains(locale)) && !(locale.getCountry().length() > 0);return cAvailableLocaleSet.contains(locale);"},{"entropy_rank":9,"patch_id":8,"patch_code":"return (cAvailableLocaleSet.contains(locale)) && !(locale.getVariant().length() > 0);return cAvailableLocaleSet.contains(locale);"},{"entropy_rank":12,"patch_id":3,"patch_code":"return (cAvailableLocaleSet.contains(locale)) || !(locale.getCountry().length() > 0);return cAvailableLocaleSet.contains(locale);"},{"entropy_rank":13,"patch_id":7,"patch_code":"return (cAvailableLocaleSet.contains(locale)) || !(locale.getVariant().length() > 0);return cAvailableLocaleSet.contains(locale);"},{"entropy_rank":14,"patch_id":36,"patch_code":"return (cAvailableLocaleSet.contains(locale)) && !(locale.getCountry().length() != 0);return cAvailableLocaleSet.contains(locale);"},{"entropy_rank":15,"patch_id":35,"patch_code":"return (cAvailableLocaleSet.contains(locale)) || !(locale.getCountry().length() != 0);return cAvailableLocaleSet.contains(locale);"},{"entropy_rank":16,"patch_id":6,"patch_code":"return (cAvailableLocaleSet.contains(locale)) && (locale.getVariant().length() > 0);return cAvailableLocaleSet.contains(locale);"},{"entropy_rank":17,"patch_id":2,"patch_code":"return (cAvailableLocaleSet.contains(locale)) && (locale.getCountry().length() > 0);return cAvailableLocaleSet.contains(locale);"},{"entropy_rank":18,"patch_id":34,"patch_code":"return (cAvailableLocaleSet.contains(locale)) && (locale.getCountry().length() != 0);return cAvailableLocaleSet.contains(locale);"},{"entropy_rank":19,"patch_id":39,"patch_code":"return cAvailableLocaleSet.contains(availableLocaleList());return cAvailableLocaleSet.contains(locale);"},{"entropy_rank":20,"patch_id":40,"patch_code":"return cAvailableLocaleSet.contains(availableLocaleSet());return cAvailableLocaleSet.contains(locale);"}],"Lang_58":[{"entropy_rank":1,"patch_id":3,"patch_code":"if (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0)!='-' || Character.isDigit(numeric.charAt(0)))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }if (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }"},{"entropy_rank":2,"patch_id":16,"patch_code":"if (dec != mant && (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0))))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }if (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }"},{"entropy_rank":3,"patch_id":19,"patch_code":"if (dec == mant || (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0))))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }if (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }"},{"entropy_rank":4,"patch_id":17,"patch_code":"if (dec != mant || (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0))))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }if (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }"},{"entropy_rank":5,"patch_id":2,"patch_code":"if (dec == null\n                        && exp != null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }if (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }"},{"entropy_rank":6,"patch_id":36,"patch_code":"if (numeric != mant && (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0))))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }if (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }"},{"entropy_rank":7,"patch_id":4,"patch_code":"if (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0)<'-' || Character.isDigit(numeric.charAt(0)))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }if (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }"},{"entropy_rank":8,"patch_id":38,"patch_code":"if (numeric == mant && (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0))))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }if (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }"},{"entropy_rank":9,"patch_id":30,"patch_code":"if (exp == mant && (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0))))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }if (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }"},{"entropy_rank":10,"patch_id":18,"patch_code":"if (dec == mant && (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0))))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }if (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }"},{"entropy_rank":11,"patch_id":6,"patch_code":"if (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0)>'-' || Character.isDigit(numeric.charAt(0)))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }if (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }"},{"entropy_rank":12,"patch_id":7,"patch_code":"if (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0)>='-' || Character.isDigit(numeric.charAt(0)))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }if (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }"},{"entropy_rank":13,"patch_id":23,"patch_code":"if (dec == str || (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0))))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }if (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }"},{"entropy_rank":14,"patch_id":34,"patch_code":"if (exp == str && (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0))))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }if (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }"},{"entropy_rank":15,"patch_id":37,"patch_code":"if (numeric != mant || (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0))))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }if (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }"},{"entropy_rank":16,"patch_id":39,"patch_code":"if (numeric == mant || (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0))))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }if (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }"},{"entropy_rank":17,"patch_id":8,"patch_code":"if (dec != numeric && (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0))))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }if (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }"},{"entropy_rank":18,"patch_id":11,"patch_code":"if (dec == numeric || (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0))))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }if (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }"},{"entropy_rank":19,"patch_id":9,"patch_code":"if (dec != numeric || (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0))))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }if (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }"},{"entropy_rank":20,"patch_id":31,"patch_code":"if (exp == mant || (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0))))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }if (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }"},{"entropy_rank":21,"patch_id":12,"patch_code":"if (dec != exp && (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0))))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }if (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }"},{"entropy_rank":22,"patch_id":20,"patch_code":"if (dec != str && (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0))))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }if (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }"},{"entropy_rank":23,"patch_id":5,"patch_code":"if (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0)<='-' || Character.isDigit(numeric.charAt(0)))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }if (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }"},{"entropy_rank":24,"patch_id":21,"patch_code":"if (dec != str || (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0))))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }if (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }"},{"entropy_rank":25,"patch_id":28,"patch_code":"if (exp != mant && (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0))))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }if (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }"},{"entropy_rank":26,"patch_id":13,"patch_code":"if (dec != exp || (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0))))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }if (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }"},{"entropy_rank":27,"patch_id":40,"patch_code":"if (numeric != str && (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0))))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }if (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }"},{"entropy_rank":28,"patch_id":26,"patch_code":"if (exp == numeric && (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0))))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }if (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }"},{"entropy_rank":29,"patch_id":15,"patch_code":"if (dec == exp || (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0))))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }if (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }"},{"entropy_rank":30,"patch_id":42,"patch_code":"if (numeric == str && (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0))))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }if (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }"},{"entropy_rank":31,"patch_id":22,"patch_code":"if (dec == str && (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0))))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }if (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }"},{"entropy_rank":32,"patch_id":43,"patch_code":"if (numeric == str || (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0))))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }if (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }"},{"entropy_rank":33,"patch_id":14,"patch_code":"if (dec == exp && (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0))))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }if (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }"},{"entropy_rank":34,"patch_id":35,"patch_code":"if (exp == str || (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0))))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }if (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }"},{"entropy_rank":35,"patch_id":10,"patch_code":"if (dec == numeric && (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0))))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }if (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }"},{"entropy_rank":36,"patch_id":27,"patch_code":"if (exp == numeric || (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0))))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }if (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }"},{"entropy_rank":37,"patch_id":29,"patch_code":"if (exp != mant || (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0))))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }if (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }"},{"entropy_rank":38,"patch_id":41,"patch_code":"if (numeric != str || (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0))))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }if (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }"},{"entropy_rank":39,"patch_id":32,"patch_code":"if (exp != str && (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0))))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }if (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }"},{"entropy_rank":40,"patch_id":24,"patch_code":"if (exp != numeric && (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0))))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }if (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }"},{"entropy_rank":41,"patch_id":33,"patch_code":"if (exp != str || (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0))))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }if (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }"},{"entropy_rank":42,"patch_id":25,"patch_code":"if (exp != numeric || (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0))))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }if (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }"},{"entropy_rank":43,"patch_id":1,"patch_code":"if (dec != null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }if (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            \/\/Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }"}],"Lang_59":[{"entropy_rank":1,"patch_id":4,"patch_code":"str.getChars(0, width, buffer, size);str.getChars(0, strLen, buffer, size);"},{"entropy_rank":2,"patch_id":5,"patch_code":"str.getChars(0, strLen, buffer, width);str.getChars(0, strLen, buffer, size);"},{"entropy_rank":3,"patch_id":68,"patch_code":"str.getChars(0, strLen, buffer, size());str.getChars(0, strLen, buffer, size);"},{"entropy_rank":4,"patch_id":66,"patch_code":"str.getChars(0, strLen, buffer, capacity());str.getChars(0, strLen, buffer, size);"},{"entropy_rank":5,"patch_id":7,"patch_code":"getNullText().getChars(0, strLen, buffer, size);str.getChars(0, strLen, buffer, size);"},{"entropy_rank":6,"patch_id":52,"patch_code":"str.getChars(0, strLen, toCharArray(), size);str.getChars(0, strLen, buffer, size);"},{"entropy_rank":7,"patch_id":27,"patch_code":"str.getChars(0, length(), buffer, size);str.getChars(0, strLen, buffer, size);"},{"entropy_rank":8,"patch_id":23,"patch_code":"toString().getChars(0, strLen, buffer, size);str.getChars(0, strLen, buffer, size);"},{"entropy_rank":9,"patch_id":65,"patch_code":"str.getChars(0, strLen, buffer, length());str.getChars(0, strLen, buffer, size);"},{"entropy_rank":10,"patch_id":16,"patch_code":"appendNull().getChars(0, strLen, buffer, size);str.getChars(0, strLen, buffer, size);"},{"entropy_rank":11,"patch_id":79,"patch_code":"str.getChars(0, strLen, buffer, hashCode());str.getChars(0, strLen, buffer, size);"},{"entropy_rank":12,"patch_id":30,"patch_code":"str.getChars(0, size(), buffer, size);str.getChars(0, strLen, buffer, size);"},{"entropy_rank":13,"patch_id":3,"patch_code":"str.getChars(0, this.size, buffer, size);str.getChars(0, strLen, buffer, size);"},{"entropy_rank":14,"patch_id":17,"patch_code":"reverse().getChars(0, strLen, buffer, size);str.getChars(0, strLen, buffer, size);"},{"entropy_rank":15,"patch_id":41,"patch_code":"str.getChars(0, hashCode(), buffer, size);str.getChars(0, strLen, buffer, size);"},{"entropy_rank":16,"patch_id":1,"patch_code":"this.nullText.getChars(0, strLen, buffer, size);str.getChars(0, strLen, buffer, size);"},{"entropy_rank":17,"patch_id":28,"patch_code":"str.getChars(0, capacity(), buffer, size);str.getChars(0, strLen, buffer, size);"},{"entropy_rank":18,"patch_id":24,"patch_code":"toStringBuffer().getChars(0, strLen, buffer, size);str.getChars(0, strLen, buffer, size);"},{"entropy_rank":19,"patch_id":13,"patch_code":"clear().getChars(0, strLen, buffer, size);str.getChars(0, strLen, buffer, size);"},{"entropy_rank":20,"patch_id":18,"patch_code":"trim().getChars(0, strLen, buffer, size);str.getChars(0, strLen, buffer, size);"},{"entropy_rank":21,"patch_id":15,"patch_code":"appendNewLine().getChars(0, strLen, buffer, size);str.getChars(0, strLen, buffer, size);"},{"entropy_rank":22,"patch_id":6,"patch_code":"getNewLineText().getChars(0, strLen, buffer, size);str.getChars(0, strLen, buffer, size);"},{"entropy_rank":23,"patch_id":2,"patch_code":"this.newLine.getChars(0, strLen, buffer, size);str.getChars(0, strLen, buffer, size);"},{"entropy_rank":24,"patch_id":10,"patch_code":"minimizeCapacity().getChars(0, strLen, buffer, size);str.getChars(0, strLen, buffer, size);"}],"Lang_6":[{"entropy_rank":1,"patch_id":3,"patch_code":"pos += Character.charCount(Character.codePointAt(input, consumed));pos += Character.charCount(Character.codePointAt(input, pos));"},{"entropy_rank":2,"patch_id":1,"patch_code":"pos = Character.charCount(Character.codePointAt(input, pos));pos += Character.charCount(Character.codePointAt(input, pos));"},{"entropy_rank":3,"patch_id":4,"patch_code":"pos += Character.charCount(Character.codePointAt(input, len));pos += Character.charCount(Character.codePointAt(input, pos));"},{"entropy_rank":4,"patch_id":2,"patch_code":"pos += Character.charCount(Character.codePointAt(input, pt));pos += Character.charCount(Character.codePointAt(input, pos));"}],"Lang_63":[{"entropy_rank":6,"patch_id":7,"patch_code":"months = 1;months -= 1;"},{"entropy_rank":7,"patch_id":9,"patch_code":"months -= 1f;months -= 1;"},{"entropy_rank":8,"patch_id":8,"patch_code":"months -= 1d;months -= 1;"},{"entropy_rank":9,"patch_id":12,"patch_code":"milliseconds = reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);"},{"entropy_rank":10,"patch_id":13,"patch_code":"milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, seconds);milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);"},{"entropy_rank":11,"patch_id":11,"patch_code":"months -= 1;"},{"entropy_rank":12,"patch_id":15,"patch_code":"milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, minutes);milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);"},{"entropy_rank":13,"patch_id":18,"patch_code":"milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, hours);milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);"},{"entropy_rank":15,"patch_id":14,"patch_code":"milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, months);milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);"},{"entropy_rank":16,"patch_id":16,"patch_code":"milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, days);milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);"},{"entropy_rank":17,"patch_id":124,"patch_code":"seconds = reduceAndCorrect(start, end, Calendar.SECOND, seconds);seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);"},{"entropy_rank":19,"patch_id":362,"patch_code":"if (start == null) return DurationFormatUtils.ISO_EXTENDED_FORMAT_PATTERN;\n\t hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);"},{"entropy_rank":20,"patch_id":118,"patch_code":"\n        seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n        minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n        hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n        days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n        months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n        years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n\n        \/\/ This next block of code adds in values that \n        \/\/ aren't requested. This allows the user to ask for the \n        \/\/ number of months and get the real count and not just 0->11.\n        if (!Token.containsTokenWithValue(tokens, y)) {\n            if (Token.containsTokenWithValue(tokens, M)) {\n                months += 12 * years;\n                years = 0;\n            } else {\n                \/\/ TODO: this is a bit weak, needs work to know about leap years\n                days += 365 * years;\n                years = 0;\n            }\n        }\n        if (!Token.containsTokenWithValue(tokens, M)) {\n            days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n            months = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n\tmilliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n"},{"entropy_rank":22,"patch_id":17,"patch_code":"milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, years);milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);"},{"entropy_rank":23,"patch_id":123,"patch_code":"milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);"},{"entropy_rank":25,"patch_id":119,"patch_code":"\n        seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n        minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n        hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n        days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n        months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n        years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n\n        \/\/ This next block of code adds in values that \n        \/\/ aren't requested. This allows the user to ask for the \n        \/\/ number of months and get the real count and not just 0->11.\n        if (!Token.containsTokenWithValue(tokens, y)) {\n            if (Token.containsTokenWithValue(tokens, M)) {\n                months += 12 * years;\n                years = 0;\n            } else {\n                \/\/ TODO: this is a bit weak, needs work to know about leap years\n                days += 365 * years;\n                years = 0;\n            }\n        }\n        if (!Token.containsTokenWithValue(tokens, M)) {\n            days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n            months = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\n            minutes += 60 * hours;\n            hours = 0;\n        }\n\tmilliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n"},{"entropy_rank":25,"patch_id":120,"patch_code":"\n        seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n        minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n        hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n        days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n        months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n        years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n\n        \/\/ This next block of code adds in values that \n        \/\/ aren't requested. This allows the user to ask for the \n        \/\/ number of months and get the real count and not just 0->11.\n        if (!Token.containsTokenWithValue(tokens, y)) {\n            if (Token.containsTokenWithValue(tokens, M)) {\n                months += 12 * years;\n                years = 0;\n            } else {\n                \/\/ TODO: this is a bit weak, needs work to know about leap years\n                days += 365 * years;\n                years = 0;\n            }\n        }\n        if (!Token.containsTokenWithValue(tokens, M)) {\n            days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n            months = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\n            minutes += 60 * hours;\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n\tmilliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n"},{"entropy_rank":27,"patch_id":121,"patch_code":"\n        seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n        minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n        hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n        days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n        months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n        years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n\n        \/\/ This next block of code adds in values that \n        \/\/ aren't requested. This allows the user to ask for the \n        \/\/ number of months and get the real count and not just 0->11.\n        if (!Token.containsTokenWithValue(tokens, y)) {\n            if (Token.containsTokenWithValue(tokens, M)) {\n                months += 12 * years;\n                years = 0;\n            } else {\n                \/\/ TODO: this is a bit weak, needs work to know about leap years\n                days += 365 * years;\n                years = 0;\n            }\n        }\n        if (!Token.containsTokenWithValue(tokens, M)) {\n            days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n            months = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\n            minutes += 60 * hours;\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\tmilliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n"},{"entropy_rank":30,"patch_id":247,"patch_code":"if (start == null) return new String();\n\t minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);"},{"entropy_rank":34,"patch_id":421,"patch_code":"hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, months);hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);"},{"entropy_rank":36,"patch_id":28,"patch_code":"if (end == null) {\n\t    throw new IllegalArgumentException(\"Null 'end' argument.\");\n\t}\nmilliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);"},{"entropy_rank":37,"patch_id":199,"patch_code":"seconds -= reduceAndCorrect(start, end, Calendar.SECOND, years);seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);"},{"entropy_rank":38,"patch_id":200,"patch_code":"seconds -= reduceAndCorrect(start, end, Calendar.SECOND, hours);seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);"},{"entropy_rank":39,"patch_id":201,"patch_code":"seconds -= reduceAndCorrect(start, end, Calendar.SECOND, minutes);seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);"},{"entropy_rank":40,"patch_id":20,"patch_code":"if (start == null) {\n\t    throw new IllegalArgumentException(\"Null 'start' argument.\");\n\t}\nmilliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);"},{"entropy_rank":42,"patch_id":103,"patch_code":"milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n\tint years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        \/\/ each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n        while (days < 0) {\n            days += 31;\n\/\/days += 31; \/\/ TODO: Need tests to show this is bad and the new code is good.\n\/\/ HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is \n\/\/ 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n\/\/ Also it's contextual - if asked for no M in the format then I should probably \n\/\/ be doing no calculating here.\n            months -= 1;\n        }\n        while (months < 0) {\n            months += 12;\n            years -= 1;\n        }\n        "},{"entropy_rank":47,"patch_id":107,"patch_code":"milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n\twhile (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n        while (days < 0) {\n            days += 31;\n\/\/days += 31; \/\/ TODO: Need tests to show this is bad and the new code is good.\n\/\/ HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is \n\/\/ 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n\/\/ Also it's contextual - if asked for no M in the format then I should probably \n\/\/ be doing no calculating here.\n            months -= 1;\n        }\n        while (months < 0) {\n            months += 12;\n            years -= 1;\n        }\n        "},{"entropy_rank":48,"patch_id":126,"patch_code":"seconds -= reduceAndCorrect(start, end, Calendar.SECOND, months);seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);"},{"entropy_rank":49,"patch_id":108,"patch_code":"milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n\twhile (days < 0) {\n            days += 31;\n\/\/days += 31; \/\/ TODO: Need tests to show this is bad and the new code is good.\n\/\/ HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is \n\/\/ 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n\/\/ Also it's contextual - if asked for no M in the format then I should probably \n\/\/ be doing no calculating here.\n            months -= 1;\n        }\n        while (months < 0) {\n            months += 12;\n            years -= 1;\n        }\n        "},{"entropy_rank":52,"patch_id":33,"patch_code":"if (end == null) return ISO_EXTENDED_FORMAT_PATTERN;\n\t milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);"},{"entropy_rank":53,"patch_id":115,"patch_code":"\n        seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n        minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n        hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n        days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n        months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n        years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n\tmilliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n"},{"entropy_rank":54,"patch_id":25,"patch_code":"if (start == null) return ISO_EXTENDED_FORMAT_PATTERN;\n\t milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);"},{"entropy_rank":55,"patch_id":100,"patch_code":"milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n\tint hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        \/\/ each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n        while (days < 0) {\n            days += 31;\n\/\/days += 31; \/\/ TODO: Need tests to show this is bad and the new code is good.\n\/\/ HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is \n\/\/ 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n\/\/ Also it's contextual - if asked for no M in the format then I should probably \n\/\/ be doing no calculating here.\n            months -= 1;\n        }\n        while (months < 0) {\n            months += 12;\n            years -= 1;\n        }\n        "},{"entropy_rank":56,"patch_id":34,"patch_code":"if (end == null) return DurationFormatUtils.ISO_EXTENDED_FORMAT_PATTERN;\n\t milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);"},{"entropy_rank":57,"patch_id":258,"patch_code":"if (end == null) return DurationFormatUtils.ISO_EXTENDED_FORMAT_PATTERN;\n\t minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);"},{"entropy_rank":58,"patch_id":26,"patch_code":"if (start == null) return DurationFormatUtils.ISO_EXTENDED_FORMAT_PATTERN;\n\t milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);"},{"entropy_rank":60,"patch_id":101,"patch_code":"milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n\tint days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        \/\/ each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n        while (days < 0) {\n            days += 31;\n\/\/days += 31; \/\/ TODO: Need tests to show this is bad and the new code is good.\n\/\/ HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is \n\/\/ 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n\/\/ Also it's contextual - if asked for no M in the format then I should probably \n\/\/ be doing no calculating here.\n            months -= 1;\n        }\n        while (months < 0) {\n            months += 12;\n            years -= 1;\n        }\n        "},{"entropy_rank":63,"patch_id":140,"patch_code":"if (end == null) {\n\t    throw new IllegalArgumentException(\"Null 'end' argument.\");\n\t}\nseconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);"},{"entropy_rank":64,"patch_id":31,"patch_code":"if (end == null) return new String();\n\t milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);"},{"entropy_rank":66,"patch_id":23,"patch_code":"if (start == null) return new String();\n\t milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);"},{"entropy_rank":67,"patch_id":132,"patch_code":"if (start == null) {\n\t    throw new IllegalArgumentException(\"Null 'start' argument.\");\n\t}\nseconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);"},{"entropy_rank":68,"patch_id":98,"patch_code":"milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n\tint seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        \/\/ each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n        while (days < 0) {\n            days += 31;\n\/\/days += 31; \/\/ TODO: Need tests to show this is bad and the new code is good.\n\/\/ HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is \n\/\/ 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n\/\/ Also it's contextual - if asked for no M in the format then I should probably \n\/\/ be doing no calculating here.\n            months -= 1;\n        }\n        while (months < 0) {\n            months += 12;\n            years -= 1;\n        }\n        "},{"entropy_rank":69,"patch_id":99,"patch_code":"milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n\tint minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        \/\/ each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n        while (days < 0) {\n            days += 31;\n\/\/days += 31; \/\/ TODO: Need tests to show this is bad and the new code is good.\n\/\/ HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is \n\/\/ 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n\/\/ Also it's contextual - if asked for no M in the format then I should probably \n\/\/ be doing no calculating here.\n            months -= 1;\n        }\n        while (months < 0) {\n            months += 12;\n            years -= 1;\n        }\n        "},{"entropy_rank":70,"patch_id":32,"patch_code":"if (end == null) return format;\n\t milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);"},{"entropy_rank":71,"patch_id":29,"patch_code":"if (end == null) {\n\t    return null;\n\t}\nmilliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);"},{"entropy_rank":72,"patch_id":21,"patch_code":"if (start == null) {\n\t    return null;\n\t}\nmilliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);"},{"entropy_rank":73,"patch_id":24,"patch_code":"if (start == null) return format;\n\t milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);"},{"entropy_rank":74,"patch_id":117,"patch_code":"\n        seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n        minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n        hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n        days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n        months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n        years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n\n        \/\/ This next block of code adds in values that \n        \/\/ aren't requested. This allows the user to ask for the \n        \/\/ number of months and get the real count and not just 0->11.\n        if (!Token.containsTokenWithValue(tokens, y)) {\n            if (Token.containsTokenWithValue(tokens, M)) {\n                months += 12 * years;\n                years = 0;\n            } else {\n                \/\/ TODO: this is a bit weak, needs work to know about leap years\n                days += 365 * years;\n                years = 0;\n            }\n        }\n        if (!Token.containsTokenWithValue(tokens, M)) {\n            days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n            months = 0;\n        }\n\tmilliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n"},{"entropy_rank":75,"patch_id":137,"patch_code":"if (start == null) return ISO_EXTENDED_FORMAT_PATTERN;\n\t seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);"},{"entropy_rank":76,"patch_id":129,"patch_code":"seconds -= reduceAndCorrect(start, end, Calendar.SECOND, hours);seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);"},{"entropy_rank":77,"patch_id":138,"patch_code":"if (start == null) return DurationFormatUtils.ISO_EXTENDED_FORMAT_PATTERN;\n\t seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);"},{"entropy_rank":78,"patch_id":135,"patch_code":"if (start == null) return new String();\n\t seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);"},{"entropy_rank":79,"patch_id":127,"patch_code":"seconds -= reduceAndCorrect(start, end, Calendar.SECOND, days);seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);"},{"entropy_rank":80,"patch_id":102,"patch_code":"milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n\tint months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        \/\/ each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n        while (days < 0) {\n            days += 31;\n\/\/days += 31; \/\/ TODO: Need tests to show this is bad and the new code is good.\n\/\/ HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is \n\/\/ 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n\/\/ Also it's contextual - if asked for no M in the format then I should probably \n\/\/ be doing no calculating here.\n            months -= 1;\n        }\n        while (months < 0) {\n            months += 12;\n            years -= 1;\n        }\n        "},{"entropy_rank":81,"patch_id":130,"patch_code":"seconds -= reduceAndCorrect(start, end, Calendar.SECOND, minutes);seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);"},{"entropy_rank":86,"patch_id":10,"patch_code":"months -= 1;\n\tdays += 31;\n\/\/days += 31; \/\/ TODO: Need tests to show this is bad and the new code is good.\n\/\/ HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is \n\/\/ 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n\/\/ Also it's contextual - if asked for no M in the format then I should probably \n\/\/ be doing no calculating here.\n            "},{"entropy_rank":87,"patch_id":1,"patch_code":"days = 31;days += 31;"},{"entropy_rank":88,"patch_id":112,"patch_code":"\n        seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n        minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n        hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n\tmilliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n"},{"entropy_rank":89,"patch_id":113,"patch_code":"\n        seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n        minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n        hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n        days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n\tmilliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n"},{"entropy_rank":90,"patch_id":109,"patch_code":"milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n\twhile (months < 0) {\n            months += 12;\n            years -= 1;\n        }\n        "},{"entropy_rank":91,"patch_id":114,"patch_code":"\n        seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n        minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n        hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n        days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n        months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n\tmilliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n"},{"entropy_rank":92,"patch_id":111,"patch_code":"\n        seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n        minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n\tmilliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n"},{"entropy_rank":93,"patch_id":2,"patch_code":"days += 31d;days += 31;"},{"entropy_rank":94,"patch_id":3,"patch_code":"days += 31f;days += 31;"},{"entropy_rank":95,"patch_id":110,"patch_code":"\n        seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n\tmilliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n"},{"entropy_rank":96,"patch_id":105,"patch_code":"milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n\twhile (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n        while (days < 0) {\n            days += 31;\n\/\/days += 31; \/\/ TODO: Need tests to show this is bad and the new code is good.\n\/\/ HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is \n\/\/ 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n\/\/ Also it's contextual - if asked for no M in the format then I should probably \n\/\/ be doing no calculating here.\n            months -= 1;\n        }\n        while (months < 0) {\n            months += 12;\n            years -= 1;\n        }\n        "},{"entropy_rank":97,"patch_id":106,"patch_code":"milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n\twhile (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n        while (days < 0) {\n            days += 31;\n\/\/days += 31; \/\/ TODO: Need tests to show this is bad and the new code is good.\n\/\/ HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is \n\/\/ 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n\/\/ Also it's contextual - if asked for no M in the format then I should probably \n\/\/ be doing no calculating here.\n            months -= 1;\n        }\n        while (months < 0) {\n            months += 12;\n            years -= 1;\n        }\n        "},{"entropy_rank":98,"patch_id":104,"patch_code":"milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n\twhile (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n        while (days < 0) {\n            days += 31;\n\/\/days += 31; \/\/ TODO: Need tests to show this is bad and the new code is good.\n\/\/ HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is \n\/\/ 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n\/\/ Also it's contextual - if asked for no M in the format then I should probably \n\/\/ be doing no calculating here.\n            months -= 1;\n        }\n        while (months < 0) {\n            months += 12;\n            years -= 1;\n        }\n        "},{"entropy_rank":99,"patch_id":4,"patch_code":"\n\/\/days += 31; \/\/ TODO: Need tests to show this is bad and the new code is good.\n\/\/ HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is \n\/\/ 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n\/\/ Also it's contextual - if asked for no M in the format then I should probably \n\/\/ be doing no calculating here.\n            months -= 1;\n\tdays += 31;\n"}],"Lang_7":[{"entropy_rank":1,"patch_id":1,"patch_code":"if ((str.startsWith(\"--\")) || (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\"))) {\n            return null;\n        }if (str.startsWith(\"--\")) {\n            return null;\n        }"},{"entropy_rank":2,"patch_id":2,"patch_code":"if ((str.startsWith(\"--\")) && (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\"))) {\n            return null;\n        }if (str.startsWith(\"--\")) {\n            return null;\n        }"},{"entropy_rank":3,"patch_id":4,"patch_code":"if ((str.startsWith(\"--\")) && !(str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\"))) {\n            return null;\n        }if (str.startsWith(\"--\")) {\n            return null;\n        }"},{"entropy_rank":4,"patch_id":3,"patch_code":"if ((str.startsWith(\"--\")) || !(str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\"))) {\n            return null;\n        }if (str.startsWith(\"--\")) {\n            return null;\n        }"},{"entropy_rank":6,"patch_id":9,"patch_code":"if ((str.startsWith(\"--\")) || (StringUtils.isEmpty(str))) {\n            return null;\n        }if (str.startsWith(\"--\")) {\n            return null;\n        }"},{"entropy_rank":7,"patch_id":17,"patch_code":"if ((str.startsWith(\"--\")) || (str.startsWith(\"-0x\"))) {\n            return null;\n        }if (str.startsWith(\"--\")) {\n            return null;\n        }"},{"entropy_rank":8,"patch_id":13,"patch_code":"if ((str.startsWith(\"--\")) || (str.startsWith(\"0X\"))) {\n            return null;\n        }if (str.startsWith(\"--\")) {\n            return null;\n        }"},{"entropy_rank":9,"patch_id":25,"patch_code":"if ((str.startsWith(\"--\")) || (str.startsWith(\"-0X\"))) {\n            return null;\n        }if (str.startsWith(\"--\")) {\n            return null;\n        }"},{"entropy_rank":11,"patch_id":10,"patch_code":"if ((str.startsWith(\"--\")) && (StringUtils.isEmpty(str))) {\n            return null;\n        }if (str.startsWith(\"--\")) {\n            return null;\n        }"},{"entropy_rank":13,"patch_id":5,"patch_code":"if ((str.startsWith(\"--\")) || (StringUtils.isBlank(str))) {\n            return null;\n        }if (str.startsWith(\"--\")) {\n            return null;\n        }"},{"entropy_rank":14,"patch_id":12,"patch_code":"if ((str.startsWith(\"--\")) && !(StringUtils.isEmpty(str))) {\n            return null;\n        }if (str.startsWith(\"--\")) {\n            return null;\n        }"},{"entropy_rank":15,"patch_id":14,"patch_code":"if ((str.startsWith(\"--\")) && (str.startsWith(\"0X\"))) {\n            return null;\n        }if (str.startsWith(\"--\")) {\n            return null;\n        }"},{"entropy_rank":16,"patch_id":16,"patch_code":"if ((str.startsWith(\"--\")) && !(str.startsWith(\"0X\"))) {\n            return null;\n        }if (str.startsWith(\"--\")) {\n            return null;\n        }"},{"entropy_rank":17,"patch_id":18,"patch_code":"if ((str.startsWith(\"--\")) && (str.startsWith(\"-0x\"))) {\n            return null;\n        }if (str.startsWith(\"--\")) {\n            return null;\n        }"},{"entropy_rank":18,"patch_id":20,"patch_code":"if ((str.startsWith(\"--\")) && !(str.startsWith(\"-0x\"))) {\n            return null;\n        }if (str.startsWith(\"--\")) {\n            return null;\n        }"},{"entropy_rank":19,"patch_id":6,"patch_code":"if ((str.startsWith(\"--\")) && (StringUtils.isBlank(str))) {\n            return null;\n        }if (str.startsWith(\"--\")) {\n            return null;\n        }"},{"entropy_rank":20,"patch_id":8,"patch_code":"if ((str.startsWith(\"--\")) && !(StringUtils.isBlank(str))) {\n            return null;\n        }if (str.startsWith(\"--\")) {\n            return null;\n        }"},{"entropy_rank":21,"patch_id":28,"patch_code":"if ((str.startsWith(\"--\")) && !(str.startsWith(\"-0X\"))) {\n            return null;\n        }if (str.startsWith(\"--\")) {\n            return null;\n        }"},{"entropy_rank":22,"patch_id":26,"patch_code":"if ((str.startsWith(\"--\")) && (str.startsWith(\"-0X\"))) {\n            return null;\n        }if (str.startsWith(\"--\")) {\n            return null;\n        }"},{"entropy_rank":23,"patch_id":15,"patch_code":"if ((str.startsWith(\"--\")) || !(str.startsWith(\"0X\"))) {\n            return null;\n        }if (str.startsWith(\"--\")) {\n            return null;\n        }"},{"entropy_rank":24,"patch_id":21,"patch_code":"if ((str.startsWith(\"--\")) || (str.startsWith(\"0x\"))) {\n            return null;\n        }if (str.startsWith(\"--\")) {\n            return null;\n        }"},{"entropy_rank":26,"patch_id":19,"patch_code":"if ((str.startsWith(\"--\")) || !(str.startsWith(\"-0x\"))) {\n            return null;\n        }if (str.startsWith(\"--\")) {\n            return null;\n        }"},{"entropy_rank":27,"patch_id":24,"patch_code":"if ((str.startsWith(\"--\")) && !(str.startsWith(\"0x\"))) {\n            return null;\n        }if (str.startsWith(\"--\")) {\n            return null;\n        }"},{"entropy_rank":28,"patch_id":7,"patch_code":"if ((str.startsWith(\"--\")) || !(StringUtils.isBlank(str))) {\n            return null;\n        }if (str.startsWith(\"--\")) {\n            return null;\n        }"},{"entropy_rank":29,"patch_id":11,"patch_code":"if ((str.startsWith(\"--\")) || !(StringUtils.isEmpty(str))) {\n            return null;\n        }if (str.startsWith(\"--\")) {\n            return null;\n        }"},{"entropy_rank":30,"patch_id":22,"patch_code":"if ((str.startsWith(\"--\")) && (str.startsWith(\"0x\"))) {\n            return null;\n        }if (str.startsWith(\"--\")) {\n            return null;\n        }"},{"entropy_rank":31,"patch_id":27,"patch_code":"if ((str.startsWith(\"--\")) || !(str.startsWith(\"-0X\"))) {\n            return null;\n        }if (str.startsWith(\"--\")) {\n            return null;\n        }"},{"entropy_rank":32,"patch_id":23,"patch_code":"if ((str.startsWith(\"--\")) || !(str.startsWith(\"0x\"))) {\n            return null;\n        }if (str.startsWith(\"--\")) {\n            return null;\n        }"}],"Math_1":[{"entropy_rank":1,"patch_id":3,"patch_code":"throw new FractionConversionException(r0, p2, q2);throw new FractionConversionException(value, p2, q2);"},{"entropy_rank":2,"patch_id":6,"patch_code":"throw new FractionConversionException(value, a1, q2);throw new FractionConversionException(value, p2, q2);"},{"entropy_rank":3,"patch_id":13,"patch_code":"throw new FractionConversionException(value, p2, a1);throw new FractionConversionException(value, p2, q2);"},{"entropy_rank":4,"patch_id":9,"patch_code":"throw new FractionConversionException(value, a0, q2);throw new FractionConversionException(value, p2, q2);"},{"entropy_rank":5,"patch_id":2,"patch_code":"throw new FractionConversionException(r1, p2, q2);throw new FractionConversionException(value, p2, q2);"},{"entropy_rank":6,"patch_id":14,"patch_code":"throw new FractionConversionException(value, p2, p1);throw new FractionConversionException(value, p2, q2);"},{"entropy_rank":7,"patch_id":10,"patch_code":"throw new FractionConversionException(value, overflow, q2);throw new FractionConversionException(value, p2, q2);"},{"entropy_rank":8,"patch_id":4,"patch_code":"throw new FractionConversionException(value, p1, q2);throw new FractionConversionException(value, p2, q2);"},{"entropy_rank":9,"patch_id":17,"patch_code":"throw new FractionConversionException(value, p2, overflow);throw new FractionConversionException(value, p2, q2);"},{"entropy_rank":10,"patch_id":20,"patch_code":"throw new FractionConversionException(doubleValue(), p2, q2);throw new FractionConversionException(value, p2, q2);"},{"entropy_rank":11,"patch_id":15,"patch_code":"throw new FractionConversionException(value, p2, p0);throw new FractionConversionException(value, p2, q2);"},{"entropy_rank":12,"patch_id":16,"patch_code":"throw new FractionConversionException(value, p2, a0);throw new FractionConversionException(value, p2, q2);"},{"entropy_rank":13,"patch_id":27,"patch_code":"throw new FractionConversionException(getNumeratorAsLong(), p2, q2);throw new FractionConversionException(value, p2, q2);"},{"entropy_rank":14,"patch_id":5,"patch_code":"throw new FractionConversionException(value, p0, q2);throw new FractionConversionException(value, p2, q2);"},{"entropy_rank":15,"patch_id":79,"patch_code":"throw new FractionConversionException(r0, p2, q2);throw new FractionConversionException(value, p2, q2);"},{"entropy_rank":16,"patch_id":11,"patch_code":"throw new FractionConversionException(value, p2, q1);throw new FractionConversionException(value, p2, q2);"},{"entropy_rank":17,"patch_id":62,"patch_code":"throw new FractionConversionException(value, p2, getDenominatorAsLong());throw new FractionConversionException(value, p2, q2);"},{"entropy_rank":18,"patch_id":46,"patch_code":"throw new FractionConversionException(value, getNumeratorAsLong(), q2);throw new FractionConversionException(value, p2, q2);"},{"entropy_rank":19,"patch_id":7,"patch_code":"throw new FractionConversionException(value, q1, q2);throw new FractionConversionException(value, p2, q2);"},{"entropy_rank":20,"patch_id":61,"patch_code":"throw new FractionConversionException(value, p2, getDenominatorAsInt());throw new FractionConversionException(value, p2, q2);"},{"entropy_rank":20,"patch_id":29,"patch_code":"throw new FractionConversionException(intValue(), p2, q2);throw new FractionConversionException(value, p2, q2);"},{"entropy_rank":22,"patch_id":45,"patch_code":"throw new FractionConversionException(value, getNumeratorAsInt(), q2);throw new FractionConversionException(value, p2, q2);"},{"entropy_rank":23,"patch_id":8,"patch_code":"throw new FractionConversionException(value, q0, q2);throw new FractionConversionException(value, p2, q2);"},{"entropy_rank":24,"patch_id":42,"patch_code":"throw new FractionConversionException(value, getDenominatorAsInt(), q2);throw new FractionConversionException(value, p2, q2);"},{"entropy_rank":25,"patch_id":65,"patch_code":"throw new FractionConversionException(value, p2, getNumeratorAsLong());throw new FractionConversionException(value, p2, q2);"},{"entropy_rank":25,"patch_id":43,"patch_code":"throw new FractionConversionException(value, getDenominatorAsLong(), q2);throw new FractionConversionException(value, p2, q2);"},{"entropy_rank":27,"patch_id":82,"patch_code":"throw new FractionConversionException(value, a1, q2);throw new FractionConversionException(value, p2, q2);"},{"entropy_rank":27,"patch_id":26,"patch_code":"throw new FractionConversionException(getNumeratorAsInt(), p2, q2);throw new FractionConversionException(value, p2, q2);"},{"entropy_rank":29,"patch_id":48,"patch_code":"throw new FractionConversionException(value, intValue(), q2);throw new FractionConversionException(value, p2, q2);"},{"entropy_rank":30,"patch_id":24,"patch_code":"throw new FractionConversionException(getDenominatorAsLong(), p2, q2);throw new FractionConversionException(value, p2, q2);"},{"entropy_rank":31,"patch_id":23,"patch_code":"throw new FractionConversionException(getDenominatorAsInt(), p2, q2);throw new FractionConversionException(value, p2, q2);"},{"entropy_rank":32,"patch_id":89,"patch_code":"throw new FractionConversionException(value, p2, a1);throw new FractionConversionException(value, p2, q2);"},{"entropy_rank":33,"patch_id":85,"patch_code":"throw new FractionConversionException(value, a0, q2);throw new FractionConversionException(value, p2, q2);"},{"entropy_rank":34,"patch_id":64,"patch_code":"throw new FractionConversionException(value, p2, getNumeratorAsInt());throw new FractionConversionException(value, p2, q2);"},{"entropy_rank":35,"patch_id":28,"patch_code":"throw new FractionConversionException(hashCode(), p2, q2);throw new FractionConversionException(value, p2, q2);"},{"entropy_rank":36,"patch_id":30,"patch_code":"throw new FractionConversionException(longValue(), p2, q2);throw new FractionConversionException(value, p2, q2);"},{"entropy_rank":37,"patch_id":21,"patch_code":"throw new FractionConversionException(floatValue(), p2, q2);throw new FractionConversionException(value, p2, q2);"},{"entropy_rank":38,"patch_id":12,"patch_code":"throw new FractionConversionException(value, p2, q0);throw new FractionConversionException(value, p2, q2);"},{"entropy_rank":39,"patch_id":66,"patch_code":"throw new FractionConversionException(value, p2, hashCode());throw new FractionConversionException(value, p2, q2);"},{"entropy_rank":40,"patch_id":49,"patch_code":"throw new FractionConversionException(value, longValue(), q2);throw new FractionConversionException(value, p2, q2);"},{"entropy_rank":41,"patch_id":78,"patch_code":"throw new FractionConversionException(r1, p2, q2);throw new FractionConversionException(value, p2, q2);"},{"entropy_rank":42,"patch_id":1,"patch_code":"throw new FractionConversionException(epsilon, p2, q2);throw new FractionConversionException(value, p2, q2);"},{"entropy_rank":43,"patch_id":67,"patch_code":"throw new FractionConversionException(value, p2, intValue());throw new FractionConversionException(value, p2, q2);"},{"entropy_rank":44,"patch_id":47,"patch_code":"throw new FractionConversionException(value, hashCode(), q2);throw new FractionConversionException(value, p2, q2);"},{"entropy_rank":45,"patch_id":90,"patch_code":"throw new FractionConversionException(value, p2, p1);throw new FractionConversionException(value, p2, q2);"},{"entropy_rank":46,"patch_id":80,"patch_code":"throw new FractionConversionException(value, p1, q2);throw new FractionConversionException(value, p2, q2);"},{"entropy_rank":47,"patch_id":91,"patch_code":"throw new FractionConversionException(value, p2, p0);throw new FractionConversionException(value, p2, q2);"},{"entropy_rank":48,"patch_id":68,"patch_code":"throw new FractionConversionException(value, p2, longValue());throw new FractionConversionException(value, p2, q2);"},{"entropy_rank":49,"patch_id":98,"patch_code":"throw new FractionConversionException(getNumerator(), p2, q2);throw new FractionConversionException(value, p2, q2);"},{"entropy_rank":49,"patch_id":93,"patch_code":"throw new FractionConversionException(value, p2, overflow);throw new FractionConversionException(value, p2, q2);"},{"entropy_rank":51,"patch_id":83,"patch_code":"throw new FractionConversionException(value, q1, q2);throw new FractionConversionException(value, p2, q2);"},{"entropy_rank":52,"patch_id":86,"patch_code":"throw new FractionConversionException(value, overflow, q2);throw new FractionConversionException(value, p2, q2);"},{"entropy_rank":53,"patch_id":95,"patch_code":"throw new FractionConversionException(doubleValue(), p2, q2);throw new FractionConversionException(value, p2, q2);"},{"entropy_rank":54,"patch_id":92,"patch_code":"throw new FractionConversionException(value, p2, a0);throw new FractionConversionException(value, p2, q2);"},{"entropy_rank":55,"patch_id":81,"patch_code":"throw new FractionConversionException(value, p0, q2);throw new FractionConversionException(value, p2, q2);"},{"entropy_rank":56,"patch_id":97,"patch_code":"throw new FractionConversionException(getDenominator(), p2, q2);throw new FractionConversionException(value, p2, q2);"},{"entropy_rank":57,"patch_id":87,"patch_code":"throw new FractionConversionException(value, p2, q1);throw new FractionConversionException(value, p2, q2);"},{"entropy_rank":58,"patch_id":84,"patch_code":"throw new FractionConversionException(value, q0, q2);throw new FractionConversionException(value, p2, q2);"},{"entropy_rank":59,"patch_id":100,"patch_code":"throw new FractionConversionException(intValue(), p2, q2);throw new FractionConversionException(value, p2, q2);"},{"entropy_rank":60,"patch_id":32,"patch_code":"throw new FractionConversionException(percentageValue(), p2, q2);throw new FractionConversionException(value, p2, q2);"},{"entropy_rank":61,"patch_id":99,"patch_code":"throw new FractionConversionException(hashCode(), p2, q2);throw new FractionConversionException(value, p2, q2);"},{"entropy_rank":62,"patch_id":96,"patch_code":"throw new FractionConversionException(floatValue(), p2, q2);throw new FractionConversionException(value, p2, q2);"},{"entropy_rank":63,"patch_id":88,"patch_code":"throw new FractionConversionException(value, p2, q0);throw new FractionConversionException(value, p2, q2);"},{"entropy_rank":63,"patch_id":77,"patch_code":"throw new FractionConversionException(epsilon, p2, q2);throw new FractionConversionException(value, p2, q2);"},{"entropy_rank":65,"patch_id":101,"patch_code":"throw new FractionConversionException(longValue(), p2, q2);throw new FractionConversionException(value, p2, q2);"},{"entropy_rank":67,"patch_id":75,"patch_code":"throw new FractionConversionException(value, p2, q2);"}],"Math_11":[{"entropy_rank":1,"patch_id":1,"patch_code":"return this.covarianceMatrixDeterminant;\nreturn FastMath.pow(2 * FastMath.PI, -dim \/ 2) *\n            FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n            getExponentTerm(vals);"},{"entropy_rank":2,"patch_id":2,"patch_code":"return FastMath.pow(2 * FastMath.PI, -dim \/ 2d) *\n            FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n            getExponentTerm(vals);return FastMath.pow(2 * FastMath.PI, -dim \/ 2) *\n            FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n            getExponentTerm(vals);"},{"entropy_rank":3,"patch_id":3,"patch_code":"return FastMath.pow(2 * FastMath.PI, -dim \/ 2f) *\n            FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n            getExponentTerm(vals);return FastMath.pow(2 * FastMath.PI, -dim \/ 2) *\n            FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n            getExponentTerm(vals);"},{"entropy_rank":4,"patch_id":4,"patch_code":"return FastMath.pow(2 * FastMath.PI, (1.0 \/ 2) * -dim) *\n            FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n            getExponentTerm(vals);return FastMath.pow(2 * FastMath.PI, -dim \/ 2) *\n            FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n            getExponentTerm(vals);"}],"Math_15":[{"entropy_rank":1,"patch_id":8,"patch_code":"if (y >= TWO_POWER_52 || y<-TWO_POWER_52) {\n                return pow(-x, y);\n            }if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) {\n                return pow(-x, y);\n            }"},{"entropy_rank":2,"patch_id":5,"patch_code":"if (y>TWO_POWER_52 || y <= -TWO_POWER_52) {\n                return pow(-x, y);\n            }if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) {\n                return pow(-x, y);\n            }"},{"entropy_rank":3,"patch_id":4,"patch_code":"if (y<=TWO_POWER_52 || y <= -TWO_POWER_52) {\n                return pow(-x, y);\n            }if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) {\n                return pow(-x, y);\n            }"},{"entropy_rank":4,"patch_id":1,"patch_code":"if (y==TWO_POWER_52 || y <= -TWO_POWER_52) {\n                return pow(-x, y);\n            }if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) {\n                return pow(-x, y);\n            }"},{"entropy_rank":5,"patch_id":9,"patch_code":"if (y >= TWO_POWER_52 || y>-TWO_POWER_52) {\n                return pow(-x, y);\n            }if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) {\n                return pow(-x, y);\n            }"},{"entropy_rank":6,"patch_id":10,"patch_code":"if (y >= TWO_POWER_52 || y>=-TWO_POWER_52) {\n                return pow(-x, y);\n            }if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) {\n                return pow(-x, y);\n            }"},{"entropy_rank":7,"patch_id":6,"patch_code":"if (y >= TWO_POWER_52 || y==-TWO_POWER_52) {\n                return pow(-x, y);\n            }if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) {\n                return pow(-x, y);\n            }"},{"entropy_rank":8,"patch_id":3,"patch_code":"if (y<TWO_POWER_52 || y <= -TWO_POWER_52) {\n                return pow(-x, y);\n            }if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) {\n                return pow(-x, y);\n            }"},{"entropy_rank":9,"patch_id":7,"patch_code":"if (y >= TWO_POWER_52 || y!=-TWO_POWER_52) {\n                return pow(-x, y);\n            }if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) {\n                return pow(-x, y);\n            }"},{"entropy_rank":10,"patch_id":2,"patch_code":"if (y!=TWO_POWER_52 || y <= -TWO_POWER_52) {\n                return pow(-x, y);\n            }if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) {\n                return pow(-x, y);\n            }"}],"Math_21":[{"entropy_rank":1,"patch_id":118,"patch_code":"if (ii < order || (c[ii][ii] > c[isi][isi])) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":2,"patch_id":23,"patch_code":"\n            for (int i = r + 1; i < order; ++i) {\n                int ii  = index[i];\n                int isi = index[swap[i]];\n                if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }\n            }\n\tswap[r] = r;\n"},{"entropy_rank":3,"patch_id":110,"patch_code":"if (ii > i || (c[ii][ii] > c[isi][isi])) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":4,"patch_id":117,"patch_code":"if (ii < order && (c[ii][ii] > c[isi][isi])) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":5,"patch_id":125,"patch_code":"if (ii != this.rank && (c[ii][ii] > c[isi][isi])) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":6,"patch_id":1,"patch_code":"int[] swap  = new int[this.rank];int[] swap  = new int[order];"},{"entropy_rank":7,"patch_id":3,"patch_code":"int[] swap  = new int[getRank()];int[] swap  = new int[order];"},{"entropy_rank":8,"patch_id":12,"patch_code":"swap[r] = order;swap[r] = r;"},{"entropy_rank":9,"patch_id":11,"patch_code":"swap[r] = this.rank;swap[r] = r;"},{"entropy_rank":10,"patch_id":9,"patch_code":"swap[order] = r;swap[r] = r;"},{"entropy_rank":11,"patch_id":17,"patch_code":"swap[getRank()] = r;swap[r] = r;"},{"entropy_rank":12,"patch_id":19,"patch_code":"swap[r] = getRank();swap[r] = r;"},{"entropy_rank":13,"patch_id":57,"patch_code":"if ((c[ii][ii] > c[isi][isi]) || (c[index[i]][index[i]] < -small)) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":14,"patch_id":89,"patch_code":"if (ii != r && (c[ii][ii] > c[isi][isi])) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":15,"patch_id":58,"patch_code":"if ((c[ii][ii] > c[isi][isi]) && (c[index[i]][index[i]] < -small)) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":16,"patch_id":50,"patch_code":"if (c[ii][ii]<c[isi][isi]) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":17,"patch_id":65,"patch_code":"if (ii != isi && (c[ii][ii] > c[isi][isi])) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":18,"patch_id":7,"patch_code":"index[r] = r;swap[r] = r;"},{"entropy_rank":19,"patch_id":68,"patch_code":"if (ii == isi || (c[ii][ii] > c[isi][isi])) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":20,"patch_id":103,"patch_code":"if (ii == i && (c[ii][ii] > c[isi][isi])) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":21,"patch_id":8,"patch_code":"swap[this.rank] = r;swap[r] = r;"},{"entropy_rank":22,"patch_id":93,"patch_code":"if (ii < r && (c[ii][ii] > c[isi][isi])) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":23,"patch_id":67,"patch_code":"if (ii == isi && (c[ii][ii] > c[isi][isi])) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":24,"patch_id":73,"patch_code":"if (ii > isi && (c[ii][ii] > c[isi][isi])) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":25,"patch_id":69,"patch_code":"if (ii < isi && (c[ii][ii] > c[isi][isi])) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":26,"patch_id":92,"patch_code":"if (ii == r || (c[ii][ii] > c[isi][isi])) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":27,"patch_id":97,"patch_code":"if (ii > r && (c[ii][ii] > c[isi][isi])) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":28,"patch_id":48,"patch_code":"if (c[ii][ii]==c[isi][isi]) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":29,"patch_id":91,"patch_code":"if (ii == r && (c[ii][ii] > c[isi][isi])) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":30,"patch_id":135,"patch_code":"if (ii >= this.rank && (c[ii][ii] > c[isi][isi])) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":31,"patch_id":137,"patch_code":"if (isi != i && (c[ii][ii] > c[isi][isi])) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":32,"patch_id":77,"patch_code":"if (ii != i && (c[ii][ii] > c[isi][isi])) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":33,"patch_id":66,"patch_code":"if (ii != isi || (c[ii][ii] > c[isi][isi])) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":34,"patch_id":75,"patch_code":"if (ii >= isi && (c[ii][ii] > c[isi][isi])) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":35,"patch_id":60,"patch_code":"if ((c[ii][ii] > c[isi][isi]) && !(c[index[i]][index[i]] < -small)) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":36,"patch_id":100,"patch_code":"if (ii >= r || (c[ii][ii] > c[isi][isi])) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":37,"patch_id":52,"patch_code":"if (c[ii][ii]>=c[isi][isi]) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":38,"patch_id":113,"patch_code":"if (ii != order && (c[ii][ii] > c[isi][isi])) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":39,"patch_id":39,"patch_code":"int isi = index[swap[getRank()]];int isi = index[swap[i]];"},{"entropy_rank":40,"patch_id":80,"patch_code":"if (ii == i || (c[ii][ii] > c[isi][isi])) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":41,"patch_id":51,"patch_code":"if (c[ii][ii]<=c[isi][isi]) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":42,"patch_id":59,"patch_code":"if ((c[ii][ii] > c[isi][isi]) || !(c[index[i]][index[i]] < -small)) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":43,"patch_id":71,"patch_code":"if (ii <= isi && (c[ii][ii] > c[isi][isi])) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":44,"patch_id":99,"patch_code":"if (ii >= r && (c[ii][ii] > c[isi][isi])) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":44,"patch_id":90,"patch_code":"if (ii != r || (c[ii][ii] > c[isi][isi])) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":46,"patch_id":49,"patch_code":"if (c[ii][ii]!=c[isi][isi]) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":47,"patch_id":61,"patch_code":"if (c != b && (c[ii][ii] > c[isi][isi])) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":48,"patch_id":95,"patch_code":"if (ii <= r && (c[ii][ii] > c[isi][isi])) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":49,"patch_id":78,"patch_code":"if (ii != i || (c[ii][ii] > c[isi][isi])) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":50,"patch_id":104,"patch_code":"if (ii == i || (c[ii][ii] > c[isi][isi])) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":51,"patch_id":81,"patch_code":"if (ii < i && (c[ii][ii] > c[isi][isi])) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":52,"patch_id":85,"patch_code":"if (ii > i && (c[ii][ii] > c[isi][isi])) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":53,"patch_id":76,"patch_code":"if (ii >= isi || (c[ii][ii] > c[isi][isi])) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":54,"patch_id":79,"patch_code":"if (ii == i && (c[ii][ii] > c[isi][isi])) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":55,"patch_id":94,"patch_code":"if (ii < r || (c[ii][ii] > c[isi][isi])) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":56,"patch_id":98,"patch_code":"if (ii > r || (c[ii][ii] > c[isi][isi])) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":57,"patch_id":96,"patch_code":"if (ii <= r || (c[ii][ii] > c[isi][isi])) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":58,"patch_id":74,"patch_code":"if (ii > isi || (c[ii][ii] > c[isi][isi])) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":59,"patch_id":70,"patch_code":"if (ii < isi || (c[ii][ii] > c[isi][isi])) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":60,"patch_id":88,"patch_code":"if (ii >= i || (c[ii][ii] > c[isi][isi])) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":61,"patch_id":101,"patch_code":"if (ii != i && (c[ii][ii] > c[isi][isi])) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":62,"patch_id":72,"patch_code":"if (ii <= isi || (c[ii][ii] > c[isi][isi])) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":63,"patch_id":87,"patch_code":"if (ii >= i && (c[ii][ii] > c[isi][isi])) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":64,"patch_id":62,"patch_code":"if (c != b || (c[ii][ii] > c[isi][isi])) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":65,"patch_id":82,"patch_code":"if (ii < i || (c[ii][ii] > c[isi][isi])) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":66,"patch_id":83,"patch_code":"if (ii <= i && (c[ii][ii] > c[isi][isi])) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":67,"patch_id":141,"patch_code":"if (isi < i && (c[ii][ii] > c[isi][isi])) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":68,"patch_id":64,"patch_code":"if (c == b || (c[ii][ii] > c[isi][isi])) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":69,"patch_id":86,"patch_code":"if (ii > i || (c[ii][ii] > c[isi][isi])) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":70,"patch_id":84,"patch_code":"if (ii <= i || (c[ii][ii] > c[isi][isi])) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":71,"patch_id":63,"patch_code":"if (c == b && (c[ii][ii] > c[isi][isi])) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":72,"patch_id":139,"patch_code":"if (isi == i && (c[ii][ii] > c[isi][isi])) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":73,"patch_id":130,"patch_code":"if (ii < this.rank || (c[ii][ii] > c[isi][isi])) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":74,"patch_id":112,"patch_code":"if (ii >= i || (c[ii][ii] > c[isi][isi])) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":75,"patch_id":115,"patch_code":"if (ii == order && (c[ii][ii] > c[isi][isi])) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":76,"patch_id":27,"patch_code":"swap[r] = r;"},{"entropy_rank":77,"patch_id":109,"patch_code":"if (ii > i && (c[ii][ii] > c[isi][isi])) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":78,"patch_id":134,"patch_code":"if (ii > this.rank || (c[ii][ii] > c[isi][isi])) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":79,"patch_id":21,"patch_code":"if (swap == null) swap = index;\n swap[r] = r;swap[r] = r;"},{"entropy_rank":80,"patch_id":24,"patch_code":"\n            for (int i = r + 1; i < order; ++i) {\n                int ii  = index[i];\n                int isi = index[swap[i]];\n                if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }\n            }\n\n\n            \/\/ swap elements\n            if (swap[r] != r) {\n                int tmp = index[r];\n                index[r] = index[swap[r]];\n                index[swap[r]] = tmp;\n            }\n\tswap[r] = r;\n"},{"entropy_rank":81,"patch_id":26,"patch_code":"\n            for (int i = r + 1; i < order; ++i) {\n                int ii  = index[i];\n                int isi = index[swap[i]];\n                if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }\n            }\n\n\n            \/\/ swap elements\n            if (swap[r] != r) {\n                int tmp = index[r];\n                index[r] = index[swap[r]];\n                index[swap[r]] = tmp;\n            }\n\n            \/\/ check diagonal element\n            int ir = index[r];\n            if (c[ir][ir] < small) {\n\n                if (r == 0) {\n                    throw new NonPositiveDefiniteMatrixException(c[ir][ir], ir, small);\n                }\n\n                \/\/ check remaining diagonal elements\n                for (int i = r; i < order; ++i) {\n                    if (c[index[i]][index[i]] < -small) {\n                        \/\/ there is at least one sufficiently negative diagonal element,\n                        \/\/ the symmetric positive semidefinite matrix is wrong\n                        throw new NonPositiveDefiniteMatrixException(c[index[i]][index[i]], i, small);\n                    }\n                }\n\n                \/\/ all remaining diagonal elements are close to zero, we consider we have\n                \/\/ found the rank of the symmetric positive semidefinite matrix\n                ++r;\n                loop = false;\n\n            } else {\n\n                \/\/ transform the matrix\n                final double sqrt = FastMath.sqrt(c[ir][ir]);\n                b[r][r] = sqrt;\n                final double inverse  = 1 \/ sqrt;\n                for (int i = r + 1; i < order; ++i) {\n                    final int ii = index[i];\n                    final double e = inverse * c[ii][ir];\n                    b[i][r] = e;\n                    c[ii][ii] -= e * e;\n                    for (int j = r + 1; j < i; ++j) {\n                        final int ij = index[j];\n                        final double f = c[ii][ij] - e * b[j][r];\n                        c[ii][ij] = f;\n                        c[ij][ii] = f;\n                    }\n                }\n\n                \/\/ prepare next iteration\n                loop = ++r < order;\n            }\n\tswap[r] = r;\n"},{"entropy_rank":82,"patch_id":107,"patch_code":"if (ii <= i && (c[ii][ii] > c[isi][isi])) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":83,"patch_id":25,"patch_code":"\n            for (int i = r + 1; i < order; ++i) {\n                int ii  = index[i];\n                int isi = index[swap[i]];\n                if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }\n            }\n\n\n            \/\/ swap elements\n            if (swap[r] != r) {\n                int tmp = index[r];\n                index[r] = index[swap[r]];\n                index[swap[r]] = tmp;\n            }\n\n            \/\/ check diagonal element\n            int ir = index[r];\n\tswap[r] = r;\n"},{"entropy_rank":84,"patch_id":145,"patch_code":"if (isi > i && (c[ii][ii] > c[isi][isi])) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":85,"patch_id":20,"patch_code":"if (swap != null) {\n\tswap[r] = r;\n            for (int i = r + 1; i < order; ++i) {\n                int ii  = index[i];\n                int isi = index[swap[i]];\n                if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }\n            }\n\n\n            \/\/ swap elements\n            if (swap[r] != r) {\n                int tmp = index[r];\n                index[r] = index[swap[r]];\n                index[swap[r]] = tmp;\n            }\n\t}\nswap[r] = r;\n            for (int i = r + 1; i < order; ++i) {\n                int ii  = index[i];\n                int isi = index[swap[i]];\n                if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }\n            }\n\n\n            \/\/ swap elements\n            if (swap[r] != r) {\n                int tmp = index[r];\n                index[r] = index[swap[r]];\n                index[swap[r]] = tmp;\n            }\n\t}\n"},{"entropy_rank":86,"patch_id":131,"patch_code":"if (ii <= this.rank && (c[ii][ii] > c[isi][isi])) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":87,"patch_id":136,"patch_code":"if (ii >= this.rank || (c[ii][ii] > c[isi][isi])) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":88,"patch_id":132,"patch_code":"if (ii <= this.rank || (c[ii][ii] > c[isi][isi])) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":89,"patch_id":140,"patch_code":"if (isi == i || (c[ii][ii] > c[isi][isi])) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":90,"patch_id":144,"patch_code":"if (isi <= i || (c[ii][ii] > c[isi][isi])) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":91,"patch_id":126,"patch_code":"if (ii != this.rank || (c[ii][ii] > c[isi][isi])) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":92,"patch_id":111,"patch_code":"if (ii >= i && (c[ii][ii] > c[isi][isi])) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"},{"entropy_rank":93,"patch_id":116,"patch_code":"if (ii == order || (c[ii][ii] > c[isi][isi])) {\n                    swap[r] = i;\n                }if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }"}],"Math_22":[{"entropy_rank":1,"patch_id":1,"patch_code":"return false;return true;"}],"Math_28":[{"entropy_rank":1,"patch_id":6,"patch_code":"for (Integer row : minRatioPositions) {\n                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n                        int column = i + tableau.getArtificialVariableOffset();\n                        final double entry = tableau.getEntry(row, column);\n                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n                            return row;\n                        }\n                    }\n                }"},{"entropy_rank":2,"patch_id":2,"patch_code":"if (minRatioPositions == null) {\n\t    throw new IllegalArgumentException(\"Null 'minRatioPositions' argument.\");\n\t}\nfor (Integer row : minRatioPositions) {\n                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n                        int column = i + tableau.getArtificialVariableOffset();\n                        final double entry = tableau.getEntry(row, column);\n                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n                            return row;\n                        }\n                    }\n                }for (Integer row : minRatioPositions) {\n                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n                        int column = i + tableau.getArtificialVariableOffset();\n                        final double entry = tableau.getEntry(row, column);\n                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n                            return row;\n                        }\n                    }\n                }"},{"entropy_rank":3,"patch_id":3,"patch_code":"if (minRatioPositions == null) {\n\t    return null;\n\t}\nfor (Integer row : minRatioPositions) {\n                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n                        int column = i + tableau.getArtificialVariableOffset();\n                        final double entry = tableau.getEntry(row, column);\n                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n                            return row;\n                        }\n                    }\n                }for (Integer row : minRatioPositions) {\n                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n                        int column = i + tableau.getArtificialVariableOffset();\n                        final double entry = tableau.getEntry(row, column);\n                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n                            return row;\n                        }\n                    }\n                }"}],"Math_3":[{"entropy_rank":1,"patch_id":2,"patch_code":""}],"Math_30":[{"entropy_rank":1,"patch_id":1,"patch_code":"final double n1n2prod = n1 * n2;final int n1n2prod = n1 * n2;"},{"entropy_rank":2,"patch_id":2,"patch_code":"final float n1n2prod = n1 * n2;final int n1n2prod = n1 * n2;"},{"entropy_rank":3,"patch_id":3,"patch_code":"final long n1n2prod = n1 * n2;final int n1n2prod = n1 * n2;"}],"Math_32":[{"entropy_rank":1,"patch_id":15,"patch_code":"if ((Boolean) tree.getAttribute()) {\n                \/\/ the instance covers the whole space\n                setSize(Double.POSITIVE_INFINITY);\n                setBarycenter(Vector2D.NaN);\n            } else {\n                setSize(0);\n                setBarycenter(new Vector2D(0, 0));\n            }"},{"entropy_rank":2,"patch_id":10,"patch_code":"if (tree == null) {\n\t    throw new IllegalArgumentException(\"Null 'tree' argument.\");\n\t}\nif ((Boolean) tree.getAttribute()) {\n                \/\/ the instance covers the whole space\n                setSize(Double.POSITIVE_INFINITY);\n                setBarycenter(Vector2D.NaN);\n            } else {\n                setSize(0);\n                setBarycenter(new Vector2D(0, 0));\n            }if ((Boolean) tree.getAttribute()) {\n                \/\/ the instance covers the whole space\n                setSize(Double.POSITIVE_INFINITY);\n                setBarycenter(Vector2D.NaN);\n            } else {\n                setSize(0);\n                setBarycenter(new Vector2D(0, 0));\n            }"},{"entropy_rank":3,"patch_id":14,"patch_code":"setSize(Double.POSITIVE_INFINITY);\n                setBarycenter(Vector2D.NaN);if ((Boolean) tree.getAttribute()) {\n                \/\/ the instance covers the whole space\n                setSize(Double.POSITIVE_INFINITY);\n                setBarycenter(Vector2D.NaN);\n            } else {\n                setSize(0);\n                setBarycenter(new Vector2D(0, 0));\n            }"},{"entropy_rank":4,"patch_id":13,"patch_code":"setSize(0);\n                setBarycenter(new Vector2D(0, 0));if ((Boolean) tree.getAttribute()) {\n                \/\/ the instance covers the whole space\n                setSize(Double.POSITIVE_INFINITY);\n                setBarycenter(Vector2D.NaN);\n            } else {\n                setSize(0);\n                setBarycenter(new Vector2D(0, 0));\n            }"},{"entropy_rank":5,"patch_id":11,"patch_code":"if (tree == null) {\n\t    return;\n\t}\nif ((Boolean) tree.getAttribute()) {\n                \/\/ the instance covers the whole space\n                setSize(Double.POSITIVE_INFINITY);\n                setBarycenter(Vector2D.NaN);\n            } else {\n                setSize(0);\n                setBarycenter(new Vector2D(0, 0));\n            }if ((Boolean) tree.getAttribute()) {\n                \/\/ the instance covers the whole space\n                setSize(Double.POSITIVE_INFINITY);\n                setBarycenter(Vector2D.NaN);\n            } else {\n                setSize(0);\n                setBarycenter(new Vector2D(0, 0));\n            }"},{"entropy_rank":6,"patch_id":9,"patch_code":"if (tree != null) {\n\tif ((Boolean) tree.getAttribute()) {\n                \/\/ the instance covers the whole space\n                setSize(Double.POSITIVE_INFINITY);\n                setBarycenter(Vector2D.NaN);\n            } else {\n                setSize(0);\n                setBarycenter(new Vector2D(0, 0));\n            }\n\t}\nif ((Boolean) tree.getAttribute()) {\n                \/\/ the instance covers the whole space\n                setSize(Double.POSITIVE_INFINITY);\n                setBarycenter(Vector2D.NaN);\n            } else {\n                setSize(0);\n                setBarycenter(new Vector2D(0, 0));\n            }\n\t}\n"}],"Math_33":[{"entropy_rank":1,"patch_id":10,"patch_code":"if ((Precision.compareTo(entry, 0d, maxUlps) > 0) || (Precision.equals(entry, 1d, maxUlps))) {\n                columnsToDrop.add(i);\n            }if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                columnsToDrop.add(i);\n            }"},{"entropy_rank":2,"patch_id":11,"patch_code":"if ((Precision.compareTo(entry, 0d, maxUlps) > 0) && (Precision.equals(entry, 1d, maxUlps))) {\n                columnsToDrop.add(i);\n            }if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                columnsToDrop.add(i);\n            }"},{"entropy_rank":3,"patch_id":15,"patch_code":"if ((Precision.compareTo(entry, 0d, maxUlps) > 0) && (!Precision.equals(entry, 0d, maxUlps))) {\n                columnsToDrop.add(i);\n            }if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                columnsToDrop.add(i);\n            }"},{"entropy_rank":4,"patch_id":14,"patch_code":"if ((Precision.compareTo(entry, 0d, maxUlps) > 0) || (!Precision.equals(entry, 0d, maxUlps))) {\n                columnsToDrop.add(i);\n            }if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                columnsToDrop.add(i);\n            }"},{"entropy_rank":5,"patch_id":6,"patch_code":"if ((Precision.compareTo(entry, 0d, maxUlps) > 0) || (Precision.compareTo(entry, 0d, epsilon) < 0)) {\n                columnsToDrop.add(i);\n            }if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                columnsToDrop.add(i);\n            }"},{"entropy_rank":6,"patch_id":7,"patch_code":"if ((Precision.compareTo(entry, 0d, maxUlps) > 0) && (Precision.compareTo(entry, 0d, epsilon) < 0)) {\n                columnsToDrop.add(i);\n            }if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                columnsToDrop.add(i);\n            }"},{"entropy_rank":7,"patch_id":13,"patch_code":"if ((Precision.compareTo(entry, 0d, maxUlps) > 0) && !(Precision.equals(entry, 1d, maxUlps))) {\n                columnsToDrop.add(i);\n            }if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                columnsToDrop.add(i);\n            }"},{"entropy_rank":8,"patch_id":12,"patch_code":"if ((Precision.compareTo(entry, 0d, maxUlps) > 0) || !(Precision.equals(entry, 1d, maxUlps))) {\n                columnsToDrop.add(i);\n            }if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                columnsToDrop.add(i);\n            }"},{"entropy_rank":9,"patch_id":3,"patch_code":"if (Precision.compareTo(entry, 0d, maxUlps)<0) {\n                columnsToDrop.add(i);\n            }if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                columnsToDrop.add(i);\n            }"},{"entropy_rank":10,"patch_id":16,"patch_code":"if ((Precision.compareTo(entry, 0d, maxUlps) > 0) || !(!Precision.equals(entry, 0d, maxUlps))) {\n                columnsToDrop.add(i);\n            }if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                columnsToDrop.add(i);\n            }"},{"entropy_rank":11,"patch_id":17,"patch_code":"if ((Precision.compareTo(entry, 0d, maxUlps) > 0) && !(!Precision.equals(entry, 0d, maxUlps))) {\n                columnsToDrop.add(i);\n            }if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                columnsToDrop.add(i);\n            }"},{"entropy_rank":12,"patch_id":9,"patch_code":"if ((Precision.compareTo(entry, 0d, maxUlps) > 0) && !(Precision.compareTo(entry, 0d, epsilon) < 0)) {\n                columnsToDrop.add(i);\n            }if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                columnsToDrop.add(i);\n            }"},{"entropy_rank":13,"patch_id":1,"patch_code":"if (Precision.compareTo(entry, 0d, maxUlps)==0) {\n                columnsToDrop.add(i);\n            }if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                columnsToDrop.add(i);\n            }"},{"entropy_rank":14,"patch_id":8,"patch_code":"if ((Precision.compareTo(entry, 0d, maxUlps) > 0) || !(Precision.compareTo(entry, 0d, epsilon) < 0)) {\n                columnsToDrop.add(i);\n            }if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                columnsToDrop.add(i);\n            }"},{"entropy_rank":15,"patch_id":2,"patch_code":"if (Precision.compareTo(entry, 0d, maxUlps)!=0) {\n                columnsToDrop.add(i);\n            }if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                columnsToDrop.add(i);\n            }"},{"entropy_rank":16,"patch_id":5,"patch_code":"if (Precision.compareTo(entry, 0d, maxUlps)>=0) {\n                columnsToDrop.add(i);\n            }if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                columnsToDrop.add(i);\n            }"},{"entropy_rank":17,"patch_id":4,"patch_code":"if (Precision.compareTo(entry, 0d, maxUlps)<=0) {\n                columnsToDrop.add(i);\n            }if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                columnsToDrop.add(i);\n            }"},{"entropy_rank":18,"patch_id":26,"patch_code":"if (entry > this.epsilon && (Precision.compareTo(entry, 0d, maxUlps) > 0)) {\n                columnsToDrop.add(i);\n            }if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                columnsToDrop.add(i);\n            }"},{"entropy_rank":19,"patch_id":27,"patch_code":"if (entry > this.epsilon || (Precision.compareTo(entry, 0d, maxUlps) > 0)) {\n                columnsToDrop.add(i);\n            }if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                columnsToDrop.add(i);\n            }"},{"entropy_rank":20,"patch_id":23,"patch_code":"if (entry < this.epsilon || (Precision.compareTo(entry, 0d, maxUlps) > 0)) {\n                columnsToDrop.add(i);\n            }if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                columnsToDrop.add(i);\n            }"},{"entropy_rank":21,"patch_id":18,"patch_code":"if (entry != this.epsilon && (Precision.compareTo(entry, 0d, maxUlps) > 0)) {\n                columnsToDrop.add(i);\n            }if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                columnsToDrop.add(i);\n            }"},{"entropy_rank":22,"patch_id":22,"patch_code":"if (entry < this.epsilon && (Precision.compareTo(entry, 0d, maxUlps) > 0)) {\n                columnsToDrop.add(i);\n            }if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                columnsToDrop.add(i);\n            }"},{"entropy_rank":23,"patch_id":28,"patch_code":"if (entry >= this.epsilon && (Precision.compareTo(entry, 0d, maxUlps) > 0)) {\n                columnsToDrop.add(i);\n            }if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                columnsToDrop.add(i);\n            }"},{"entropy_rank":24,"patch_id":29,"patch_code":"if (entry >= this.epsilon || (Precision.compareTo(entry, 0d, maxUlps) > 0)) {\n                columnsToDrop.add(i);\n            }if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                columnsToDrop.add(i);\n            }"},{"entropy_rank":25,"patch_id":21,"patch_code":"if (entry == this.epsilon || (Precision.compareTo(entry, 0d, maxUlps) > 0)) {\n                columnsToDrop.add(i);\n            }if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                columnsToDrop.add(i);\n            }"},{"entropy_rank":26,"patch_id":25,"patch_code":"if (entry <= this.epsilon || (Precision.compareTo(entry, 0d, maxUlps) > 0)) {\n                columnsToDrop.add(i);\n            }if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                columnsToDrop.add(i);\n            }"},{"entropy_rank":27,"patch_id":24,"patch_code":"if (entry <= this.epsilon && (Precision.compareTo(entry, 0d, maxUlps) > 0)) {\n                columnsToDrop.add(i);\n            }if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                columnsToDrop.add(i);\n            }"},{"entropy_rank":28,"patch_id":19,"patch_code":"if (entry != this.epsilon || (Precision.compareTo(entry, 0d, maxUlps) > 0)) {\n                columnsToDrop.add(i);\n            }if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                columnsToDrop.add(i);\n            }"},{"entropy_rank":29,"patch_id":20,"patch_code":"if (entry == this.epsilon && (Precision.compareTo(entry, 0d, maxUlps) > 0)) {\n                columnsToDrop.add(i);\n            }if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                columnsToDrop.add(i);\n            }"}],"Math_34":[{"entropy_rank":1,"patch_id":2,"patch_code":"return getChromosomeList().iterator();return chromosomes.iterator();"},{"entropy_rank":2,"patch_id":1,"patch_code":"return getChromosomes().iterator();return chromosomes.iterator();"}],"Math_35":[{"entropy_rank":1,"patch_id":7,"patch_code":"setElitismRate(elitismRate);\n\tthis.elitismRate = elitismRate;this.elitismRate = elitismRate;"},{"entropy_rank":2,"patch_id":8,"patch_code":"this.elitismRate = elitismRate;\n\tsetElitismRate(elitismRate);this.elitismRate = elitismRate;"},{"entropy_rank":3,"patch_id":5,"patch_code":""},{"entropy_rank":4,"patch_id":6,"patch_code":"setElitismRate(elitismRate);this.elitismRate = elitismRate;"},{"entropy_rank":5,"patch_id":2,"patch_code":"this.elitismRate = getElitismRate();this.elitismRate = elitismRate;"},{"entropy_rank":6,"patch_id":4,"patch_code":"this.elitismRate = elitismRate;"}],"Math_4":[{"entropy_rank":1,"patch_id":30,"patch_code":""},{"entropy_rank":2,"patch_id":15,"patch_code":"if (v1D == null) {\n\t    throw new IllegalArgumentException(\"Null 'v1D' argument.\");\n\t}\nLocation loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));"},{"entropy_rank":3,"patch_id":5,"patch_code":"if (remainingRegion == null) {\n\t    throw new IllegalArgumentException(\"Null 'remainingRegion' argument.\");\n\t}\nLocation loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));"},{"entropy_rank":5,"patch_id":10,"patch_code":"if (line == null) {\n\t    throw new IllegalArgumentException(\"Null 'line' argument.\");\n\t}\nLocation loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));"},{"entropy_rank":6,"patch_id":16,"patch_code":"if (v1D == null) {\n\t    return null;\n\t}\nLocation loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));"},{"entropy_rank":7,"patch_id":31,"patch_code":"Location loc1 = getRemainingRegion().checkPoint(line2.toSubSpace(v2D));Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));"},{"entropy_rank":9,"patch_id":6,"patch_code":"if (remainingRegion == null) {\n\t    return null;\n\t}\nLocation loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));"},{"entropy_rank":10,"patch_id":11,"patch_code":"if (line == null) {\n\t    return null;\n\t}\nLocation loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));"}],"Math_43":[{"entropy_rank":2,"patch_id":80,"patch_code":"if ((!(varianceImpl instanceof Variance)) && !(varianceImpl != variance)) {\n            varianceImpl.increment(value);\n        }if (!(varianceImpl instanceof Variance)) {\n            varianceImpl.increment(value);\n        }"},{"entropy_rank":3,"patch_id":59,"patch_code":"if (!(meanImpl instanceof Mean)) {\n            meanImpl.increment(value);\n        }\n\tminImpl.increment(value);\n        maxImpl.increment(value);\n        sumLogImpl.increment(value);\n        secondMoment.increment(value);\n        \/\/ If mean, variance or geomean have been overridden,\n        \/\/ need to increment these\n        "},{"entropy_rank":5,"patch_id":58,"patch_code":"if (!(meanImpl instanceof Mean)) {\n            meanImpl.increment(value);\n        }\n\tsumsqImpl.increment(value);\n        minImpl.increment(value);\n        maxImpl.increment(value);\n        sumLogImpl.increment(value);\n        secondMoment.increment(value);\n        \/\/ If mean, variance or geomean have been overridden,\n        \/\/ need to increment these\n        "},{"entropy_rank":6,"patch_id":60,"patch_code":"if (!(meanImpl instanceof Mean)) {\n            meanImpl.increment(value);\n        }\n\tmaxImpl.increment(value);\n        sumLogImpl.increment(value);\n        secondMoment.increment(value);\n        \/\/ If mean, variance or geomean have been overridden,\n        \/\/ need to increment these\n        "},{"entropy_rank":7,"patch_id":71,"patch_code":"checkEmpty();\n\tif (!(meanImpl instanceof Mean)) {\n            meanImpl.increment(value);\n        }if (!(meanImpl instanceof Mean)) {\n            meanImpl.increment(value);\n        }"},{"entropy_rank":8,"patch_id":72,"patch_code":"if (!(meanImpl instanceof Mean)) {\n            meanImpl.increment(value);\n        }\n\tcheckEmpty();if (!(meanImpl instanceof Mean)) {\n            meanImpl.increment(value);\n        }"},{"entropy_rank":9,"patch_id":65,"patch_code":"\n        if (!(varianceImpl instanceof Variance)) {\n            varianceImpl.increment(value);\n        }\n        if (!(geoMeanImpl instanceof GeometricMean)) {\n            geoMeanImpl.increment(value);\n        }\n        n++;\n\tif (!(meanImpl instanceof Mean)) {\n            meanImpl.increment(value);\n        }\n"},{"entropy_rank":10,"patch_id":69,"patch_code":"clear();\n\tif (!(meanImpl instanceof Mean)) {\n            meanImpl.increment(value);\n        }if (!(meanImpl instanceof Mean)) {\n            meanImpl.increment(value);\n        }"},{"entropy_rank":11,"patch_id":66,"patch_code":"meanImpl.increment(value);if (!(meanImpl instanceof Mean)) {\n            meanImpl.increment(value);\n        }"},{"entropy_rank":12,"patch_id":64,"patch_code":"\n        if (!(varianceImpl instanceof Variance)) {\n            varianceImpl.increment(value);\n        }\n        if (!(geoMeanImpl instanceof GeometricMean)) {\n            geoMeanImpl.increment(value);\n        }\n\tif (!(meanImpl instanceof Mean)) {\n            meanImpl.increment(value);\n        }\n"},{"entropy_rank":13,"patch_id":67,"patch_code":"if (!(meanImpl instanceof Mean)) {\n            meanImpl.increment(value);\n        }"},{"entropy_rank":14,"patch_id":63,"patch_code":"\n        if (!(varianceImpl instanceof Variance)) {\n            varianceImpl.increment(value);\n        }\n\tif (!(meanImpl instanceof Mean)) {\n            meanImpl.increment(value);\n        }\n"},{"entropy_rank":15,"patch_id":62,"patch_code":"if (!(meanImpl instanceof Mean)) {\n            meanImpl.increment(value);\n        }\n\tsecondMoment.increment(value);\n        \/\/ If mean, variance or geomean have been overridden,\n        \/\/ need to increment these\n        "},{"entropy_rank":16,"patch_id":61,"patch_code":"if (!(meanImpl instanceof Mean)) {\n            meanImpl.increment(value);\n        }\n\tsumLogImpl.increment(value);\n        secondMoment.increment(value);\n        \/\/ If mean, variance or geomean have been overridden,\n        \/\/ need to increment these\n        "},{"entropy_rank":19,"patch_id":70,"patch_code":"if (!(meanImpl instanceof Mean)) {\n            meanImpl.increment(value);\n        }\n\tclear();if (!(meanImpl instanceof Mean)) {\n            meanImpl.increment(value);\n        }"},{"entropy_rank":20,"patch_id":83,"patch_code":"if (!(this.maxImpl instanceof Variance)) {\n            varianceImpl.increment(value);\n        }if (!(varianceImpl instanceof Variance)) {\n            varianceImpl.increment(value);\n        }"},{"entropy_rank":21,"patch_id":53,"patch_code":"if (meanImpl == null) meanImpl = this.sumLogImpl;\n if (!(meanImpl instanceof Mean)) {\n            meanImpl.increment(value);\n        }if (!(meanImpl instanceof Mean)) {\n            meanImpl.increment(value);\n        }"},{"entropy_rank":23,"patch_id":54,"patch_code":"if (meanImpl == null) meanImpl = this.geoMeanImpl;\n if (!(meanImpl instanceof Mean)) {\n            meanImpl.increment(value);\n        }if (!(meanImpl instanceof Mean)) {\n            meanImpl.increment(value);\n        }"},{"entropy_rank":25,"patch_id":81,"patch_code":"if (!(this.minImpl instanceof Variance)) {\n            varianceImpl.increment(value);\n        }if (!(varianceImpl instanceof Variance)) {\n            varianceImpl.increment(value);\n        }"},{"entropy_rank":26,"patch_id":55,"patch_code":"if (meanImpl == null) meanImpl = this.varianceImpl;\n if (!(meanImpl instanceof Mean)) {\n            meanImpl.increment(value);\n        }if (!(meanImpl instanceof Mean)) {\n            meanImpl.increment(value);\n        }"},{"entropy_rank":27,"patch_id":52,"patch_code":"if (meanImpl == null) meanImpl = this.maxImpl;\n if (!(meanImpl instanceof Mean)) {\n            meanImpl.increment(value);\n        }if (!(meanImpl instanceof Mean)) {\n            meanImpl.increment(value);\n        }"},{"entropy_rank":29,"patch_id":50,"patch_code":"if (meanImpl == null) meanImpl = this.sumsqImpl;\n if (!(meanImpl instanceof Mean)) {\n            meanImpl.increment(value);\n        }if (!(meanImpl instanceof Mean)) {\n            meanImpl.increment(value);\n        }"},{"entropy_rank":30,"patch_id":48,"patch_code":"if (meanImpl == null) {\n\t    return;\n\t}\nif (!(meanImpl instanceof Mean)) {\n            meanImpl.increment(value);\n        }if (!(meanImpl instanceof Mean)) {\n            meanImpl.increment(value);\n        }"},{"entropy_rank":32,"patch_id":51,"patch_code":"if (meanImpl == null) meanImpl = this.minImpl;\n if (!(meanImpl instanceof Mean)) {\n            meanImpl.increment(value);\n        }if (!(meanImpl instanceof Mean)) {\n            meanImpl.increment(value);\n        }"},{"entropy_rank":33,"patch_id":49,"patch_code":"if (meanImpl == null) meanImpl = this.sumImpl;\n if (!(meanImpl instanceof Mean)) {\n            meanImpl.increment(value);\n        }if (!(meanImpl instanceof Mean)) {\n            meanImpl.increment(value);\n        }"},{"entropy_rank":38,"patch_id":18,"patch_code":"if (!(this.sumsqImpl instanceof Mean)) {\n            meanImpl.increment(value);\n        }if (!(meanImpl instanceof Mean)) {\n            meanImpl.increment(value);\n        }"},{"entropy_rank":39,"patch_id":17,"patch_code":"if (!(this.varianceImpl instanceof Mean)) {\n            meanImpl.increment(value);\n        }if (!(meanImpl instanceof Mean)) {\n            meanImpl.increment(value);\n        }"},{"entropy_rank":43,"patch_id":20,"patch_code":"if (!(getSummary() instanceof Mean)) {\n            meanImpl.increment(value);\n        }if (!(meanImpl instanceof Mean)) {\n            meanImpl.increment(value);\n        }"},{"entropy_rank":44,"patch_id":19,"patch_code":"if (!(this.sumLogImpl instanceof Mean)) {\n            meanImpl.increment(value);\n        }if (!(meanImpl instanceof Mean)) {\n            meanImpl.increment(value);\n        }"},{"entropy_rank":46,"patch_id":77,"patch_code":"if ((!(varianceImpl instanceof Variance)) || (varianceImpl != variance)) {\n            varianceImpl.increment(value);\n        }if (!(varianceImpl instanceof Variance)) {\n            varianceImpl.increment(value);\n        }"},{"entropy_rank":47,"patch_id":78,"patch_code":"if ((!(varianceImpl instanceof Variance)) && (varianceImpl != variance)) {\n            varianceImpl.increment(value);\n        }if (!(varianceImpl instanceof Variance)) {\n            varianceImpl.increment(value);\n        }"},{"entropy_rank":48,"patch_id":79,"patch_code":"if ((!(varianceImpl instanceof Variance)) || !(varianceImpl != variance)) {\n            varianceImpl.increment(value);\n        }if (!(varianceImpl instanceof Variance)) {\n            varianceImpl.increment(value);\n        }"},{"entropy_rank":49,"patch_id":84,"patch_code":"if (!(this.geoMeanImpl instanceof Variance)) {\n            varianceImpl.increment(value);\n        }if (!(varianceImpl instanceof Variance)) {\n            varianceImpl.increment(value);\n        }"},{"entropy_rank":50,"patch_id":82,"patch_code":"if (!(this.meanImpl instanceof Variance)) {\n            varianceImpl.increment(value);\n        }if (!(varianceImpl instanceof Variance)) {\n            varianceImpl.increment(value);\n        }"}],"Math_5":[{"entropy_rank":1,"patch_id":8,"patch_code":"return ZERO;return NaN;"},{"entropy_rank":2,"patch_id":9,"patch_code":"return Complex.ZERO;return NaN;"},{"entropy_rank":3,"patch_id":1,"patch_code":"return Complex.NaN;return NaN;"},{"entropy_rank":4,"patch_id":12,"patch_code":"return reciprocal();return NaN;"},{"entropy_rank":5,"patch_id":5,"patch_code":"return Complex.ONE;return NaN;"},{"entropy_rank":6,"patch_id":11,"patch_code":"return conjugate();return NaN;"},{"entropy_rank":7,"patch_id":7,"patch_code":"return Complex.I;return NaN;"},{"entropy_rank":8,"patch_id":3,"patch_code":"return Complex.INF;return NaN;"},{"entropy_rank":9,"patch_id":18,"patch_code":"return negate();return NaN;"},{"entropy_rank":10,"patch_id":4,"patch_code":"return ONE;return NaN;"},{"entropy_rank":11,"patch_id":2,"patch_code":"return INF;return NaN;"},{"entropy_rank":12,"patch_id":6,"patch_code":"return I;return NaN;"},{"entropy_rank":13,"patch_id":28,"patch_code":"return sqrt();return NaN;"},{"entropy_rank":14,"patch_id":27,"patch_code":"return sinh();return NaN;"},{"entropy_rank":15,"patch_id":22,"patch_code":"return cos();return NaN;"},{"entropy_rank":16,"patch_id":26,"patch_code":"return sin();return NaN;"},{"entropy_rank":17,"patch_id":19,"patch_code":"return acos();return NaN;"},{"entropy_rank":18,"patch_id":20,"patch_code":"return asin();return NaN;"},{"entropy_rank":19,"patch_id":25,"patch_code":"return log();return NaN;"},{"entropy_rank":20,"patch_id":24,"patch_code":"return exp();return NaN;"},{"entropy_rank":21,"patch_id":23,"patch_code":"return cosh();return NaN;"},{"entropy_rank":22,"patch_id":31,"patch_code":"return tanh();return NaN;"},{"entropy_rank":23,"patch_id":29,"patch_code":"return sqrt1z();return NaN;"},{"entropy_rank":24,"patch_id":30,"patch_code":"return tan();return NaN;"},{"entropy_rank":25,"patch_id":21,"patch_code":"return atan();return NaN;"}],"Math_50":[{"entropy_rank":1,"patch_id":4,"patch_code":"if (x>x1) {\n                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n                        f0 = computeObjectiveValue(x0);\n                    }if (x == x1) {\n                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n                        f0 = computeObjectiveValue(x0);\n                    }"},{"entropy_rank":2,"patch_id":2,"patch_code":"if (x<x1) {\n                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n                        f0 = computeObjectiveValue(x0);\n                    }if (x == x1) {\n                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n                        f0 = computeObjectiveValue(x0);\n                    }"},{"entropy_rank":3,"patch_id":3,"patch_code":"if (x<=x1) {\n                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n                        f0 = computeObjectiveValue(x0);\n                    }if (x == x1) {\n                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n                        f0 = computeObjectiveValue(x0);\n                    }"},{"entropy_rank":4,"patch_id":1,"patch_code":"if (x!=x1) {\n                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n                        f0 = computeObjectiveValue(x0);\n                    }if (x == x1) {\n                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n                        f0 = computeObjectiveValue(x0);\n                    }"},{"entropy_rank":5,"patch_id":5,"patch_code":"if (x>=x1) {\n                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n                        f0 = computeObjectiveValue(x0);\n                    }if (x == x1) {\n                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n                        f0 = computeObjectiveValue(x0);\n                    }"}],"Math_52":[{"entropy_rank":1,"patch_id":4,"patch_code":"if (c>0) {\n    \/\/ the (q1, q2, q3) vector is close to the (u1, u2) plane\n    \/\/ we try other vectors\n    Vector3D v3 = Vector3D.crossProduct(v1, v2);\n    Vector3D v3Su3 = v3.subtract(u3);\n    k = v1Su1.crossProduct(v3Su3);\n    Vector3D u2Prime = u1.crossProduct(u3);\n    c = k.dotProduct(u2Prime);\n\n    if (c == 0) {\n      \/\/ the (q1, q2, q3) vector is also close to the (u1, u3) plane,\n      \/\/ it is almost aligned with u1: we try (u2, u3) and (v2, v3)\n      k = v2Su2.crossProduct(v3Su3);;\n      c = k.dotProduct(u2.crossProduct(u3));;\n\n      if (c == 0) {\n        \/\/ the (q1, q2, q3) vector is aligned with everything\n        \/\/ this is really the identity rotation\n        q0 = 1.0;\n        q1 = 0.0;\n        q2 = 0.0;\n        q3 = 0.0;\n        return;\n      }\n\n      \/\/ we will have to use u2 and v2 to compute the scalar part\n      uRef = u2;\n      vRef = v2;\n\n    }\n\n  }if (c == 0) {\n    \/\/ the (q1, q2, q3) vector is close to the (u1, u2) plane\n    \/\/ we try other vectors\n    Vector3D v3 = Vector3D.crossProduct(v1, v2);\n    Vector3D v3Su3 = v3.subtract(u3);\n    k = v1Su1.crossProduct(v3Su3);\n    Vector3D u2Prime = u1.crossProduct(u3);\n    c = k.dotProduct(u2Prime);\n\n    if (c == 0) {\n      \/\/ the (q1, q2, q3) vector is also close to the (u1, u3) plane,\n      \/\/ it is almost aligned with u1: we try (u2, u3) and (v2, v3)\n      k = v2Su2.crossProduct(v3Su3);;\n      c = k.dotProduct(u2.crossProduct(u3));;\n\n      if (c == 0) {\n        \/\/ the (q1, q2, q3) vector is aligned with everything\n        \/\/ this is really the identity rotation\n        q0 = 1.0;\n        q1 = 0.0;\n        q2 = 0.0;\n        q3 = 0.0;\n        return;\n      }\n\n      \/\/ we will have to use u2 and v2 to compute the scalar part\n      uRef = u2;\n      vRef = v2;\n\n    }\n\n  }"},{"entropy_rank":2,"patch_id":1,"patch_code":"if (c!=0) {\n    \/\/ the (q1, q2, q3) vector is close to the (u1, u2) plane\n    \/\/ we try other vectors\n    Vector3D v3 = Vector3D.crossProduct(v1, v2);\n    Vector3D v3Su3 = v3.subtract(u3);\n    k = v1Su1.crossProduct(v3Su3);\n    Vector3D u2Prime = u1.crossProduct(u3);\n    c = k.dotProduct(u2Prime);\n\n    if (c == 0) {\n      \/\/ the (q1, q2, q3) vector is also close to the (u1, u3) plane,\n      \/\/ it is almost aligned with u1: we try (u2, u3) and (v2, v3)\n      k = v2Su2.crossProduct(v3Su3);;\n      c = k.dotProduct(u2.crossProduct(u3));;\n\n      if (c == 0) {\n        \/\/ the (q1, q2, q3) vector is aligned with everything\n        \/\/ this is really the identity rotation\n        q0 = 1.0;\n        q1 = 0.0;\n        q2 = 0.0;\n        q3 = 0.0;\n        return;\n      }\n\n      \/\/ we will have to use u2 and v2 to compute the scalar part\n      uRef = u2;\n      vRef = v2;\n\n    }\n\n  }if (c == 0) {\n    \/\/ the (q1, q2, q3) vector is close to the (u1, u2) plane\n    \/\/ we try other vectors\n    Vector3D v3 = Vector3D.crossProduct(v1, v2);\n    Vector3D v3Su3 = v3.subtract(u3);\n    k = v1Su1.crossProduct(v3Su3);\n    Vector3D u2Prime = u1.crossProduct(u3);\n    c = k.dotProduct(u2Prime);\n\n    if (c == 0) {\n      \/\/ the (q1, q2, q3) vector is also close to the (u1, u3) plane,\n      \/\/ it is almost aligned with u1: we try (u2, u3) and (v2, v3)\n      k = v2Su2.crossProduct(v3Su3);;\n      c = k.dotProduct(u2.crossProduct(u3));;\n\n      if (c == 0) {\n        \/\/ the (q1, q2, q3) vector is aligned with everything\n        \/\/ this is really the identity rotation\n        q0 = 1.0;\n        q1 = 0.0;\n        q2 = 0.0;\n        q3 = 0.0;\n        return;\n      }\n\n      \/\/ we will have to use u2 and v2 to compute the scalar part\n      uRef = u2;\n      vRef = v2;\n\n    }\n\n  }"},{"entropy_rank":3,"patch_id":2,"patch_code":"if (c<0) {\n    \/\/ the (q1, q2, q3) vector is close to the (u1, u2) plane\n    \/\/ we try other vectors\n    Vector3D v3 = Vector3D.crossProduct(v1, v2);\n    Vector3D v3Su3 = v3.subtract(u3);\n    k = v1Su1.crossProduct(v3Su3);\n    Vector3D u2Prime = u1.crossProduct(u3);\n    c = k.dotProduct(u2Prime);\n\n    if (c == 0) {\n      \/\/ the (q1, q2, q3) vector is also close to the (u1, u3) plane,\n      \/\/ it is almost aligned with u1: we try (u2, u3) and (v2, v3)\n      k = v2Su2.crossProduct(v3Su3);;\n      c = k.dotProduct(u2.crossProduct(u3));;\n\n      if (c == 0) {\n        \/\/ the (q1, q2, q3) vector is aligned with everything\n        \/\/ this is really the identity rotation\n        q0 = 1.0;\n        q1 = 0.0;\n        q2 = 0.0;\n        q3 = 0.0;\n        return;\n      }\n\n      \/\/ we will have to use u2 and v2 to compute the scalar part\n      uRef = u2;\n      vRef = v2;\n\n    }\n\n  }if (c == 0) {\n    \/\/ the (q1, q2, q3) vector is close to the (u1, u2) plane\n    \/\/ we try other vectors\n    Vector3D v3 = Vector3D.crossProduct(v1, v2);\n    Vector3D v3Su3 = v3.subtract(u3);\n    k = v1Su1.crossProduct(v3Su3);\n    Vector3D u2Prime = u1.crossProduct(u3);\n    c = k.dotProduct(u2Prime);\n\n    if (c == 0) {\n      \/\/ the (q1, q2, q3) vector is also close to the (u1, u3) plane,\n      \/\/ it is almost aligned with u1: we try (u2, u3) and (v2, v3)\n      k = v2Su2.crossProduct(v3Su3);;\n      c = k.dotProduct(u2.crossProduct(u3));;\n\n      if (c == 0) {\n        \/\/ the (q1, q2, q3) vector is aligned with everything\n        \/\/ this is really the identity rotation\n        q0 = 1.0;\n        q1 = 0.0;\n        q2 = 0.0;\n        q3 = 0.0;\n        return;\n      }\n\n      \/\/ we will have to use u2 and v2 to compute the scalar part\n      uRef = u2;\n      vRef = v2;\n\n    }\n\n  }"},{"entropy_rank":4,"patch_id":3,"patch_code":"if (c<=0) {\n    \/\/ the (q1, q2, q3) vector is close to the (u1, u2) plane\n    \/\/ we try other vectors\n    Vector3D v3 = Vector3D.crossProduct(v1, v2);\n    Vector3D v3Su3 = v3.subtract(u3);\n    k = v1Su1.crossProduct(v3Su3);\n    Vector3D u2Prime = u1.crossProduct(u3);\n    c = k.dotProduct(u2Prime);\n\n    if (c == 0) {\n      \/\/ the (q1, q2, q3) vector is also close to the (u1, u3) plane,\n      \/\/ it is almost aligned with u1: we try (u2, u3) and (v2, v3)\n      k = v2Su2.crossProduct(v3Su3);;\n      c = k.dotProduct(u2.crossProduct(u3));;\n\n      if (c == 0) {\n        \/\/ the (q1, q2, q3) vector is aligned with everything\n        \/\/ this is really the identity rotation\n        q0 = 1.0;\n        q1 = 0.0;\n        q2 = 0.0;\n        q3 = 0.0;\n        return;\n      }\n\n      \/\/ we will have to use u2 and v2 to compute the scalar part\n      uRef = u2;\n      vRef = v2;\n\n    }\n\n  }if (c == 0) {\n    \/\/ the (q1, q2, q3) vector is close to the (u1, u2) plane\n    \/\/ we try other vectors\n    Vector3D v3 = Vector3D.crossProduct(v1, v2);\n    Vector3D v3Su3 = v3.subtract(u3);\n    k = v1Su1.crossProduct(v3Su3);\n    Vector3D u2Prime = u1.crossProduct(u3);\n    c = k.dotProduct(u2Prime);\n\n    if (c == 0) {\n      \/\/ the (q1, q2, q3) vector is also close to the (u1, u3) plane,\n      \/\/ it is almost aligned with u1: we try (u2, u3) and (v2, v3)\n      k = v2Su2.crossProduct(v3Su3);;\n      c = k.dotProduct(u2.crossProduct(u3));;\n\n      if (c == 0) {\n        \/\/ the (q1, q2, q3) vector is aligned with everything\n        \/\/ this is really the identity rotation\n        q0 = 1.0;\n        q1 = 0.0;\n        q2 = 0.0;\n        q3 = 0.0;\n        return;\n      }\n\n      \/\/ we will have to use u2 and v2 to compute the scalar part\n      uRef = u2;\n      vRef = v2;\n\n    }\n\n  }"},{"entropy_rank":5,"patch_id":5,"patch_code":"if (c>=0) {\n    \/\/ the (q1, q2, q3) vector is close to the (u1, u2) plane\n    \/\/ we try other vectors\n    Vector3D v3 = Vector3D.crossProduct(v1, v2);\n    Vector3D v3Su3 = v3.subtract(u3);\n    k = v1Su1.crossProduct(v3Su3);\n    Vector3D u2Prime = u1.crossProduct(u3);\n    c = k.dotProduct(u2Prime);\n\n    if (c == 0) {\n      \/\/ the (q1, q2, q3) vector is also close to the (u1, u3) plane,\n      \/\/ it is almost aligned with u1: we try (u2, u3) and (v2, v3)\n      k = v2Su2.crossProduct(v3Su3);;\n      c = k.dotProduct(u2.crossProduct(u3));;\n\n      if (c == 0) {\n        \/\/ the (q1, q2, q3) vector is aligned with everything\n        \/\/ this is really the identity rotation\n        q0 = 1.0;\n        q1 = 0.0;\n        q2 = 0.0;\n        q3 = 0.0;\n        return;\n      }\n\n      \/\/ we will have to use u2 and v2 to compute the scalar part\n      uRef = u2;\n      vRef = v2;\n\n    }\n\n  }if (c == 0) {\n    \/\/ the (q1, q2, q3) vector is close to the (u1, u2) plane\n    \/\/ we try other vectors\n    Vector3D v3 = Vector3D.crossProduct(v1, v2);\n    Vector3D v3Su3 = v3.subtract(u3);\n    k = v1Su1.crossProduct(v3Su3);\n    Vector3D u2Prime = u1.crossProduct(u3);\n    c = k.dotProduct(u2Prime);\n\n    if (c == 0) {\n      \/\/ the (q1, q2, q3) vector is also close to the (u1, u3) plane,\n      \/\/ it is almost aligned with u1: we try (u2, u3) and (v2, v3)\n      k = v2Su2.crossProduct(v3Su3);;\n      c = k.dotProduct(u2.crossProduct(u3));;\n\n      if (c == 0) {\n        \/\/ the (q1, q2, q3) vector is aligned with everything\n        \/\/ this is really the identity rotation\n        q0 = 1.0;\n        q1 = 0.0;\n        q2 = 0.0;\n        q3 = 0.0;\n        return;\n      }\n\n      \/\/ we will have to use u2 and v2 to compute the scalar part\n      uRef = u2;\n      vRef = v2;\n\n    }\n\n  }"}],"Math_56":[{"entropy_rank":2,"patch_id":10,"patch_code":""},{"entropy_rank":3,"patch_id":99,"patch_code":"this.uniCounterOffset[last] = idx;indices[last] = idx;"},{"entropy_rank":4,"patch_id":98,"patch_code":"this.size[last] = idx;indices[last] = idx;"},{"entropy_rank":5,"patch_id":100,"patch_code":"indices[count] = idx;indices[last] = idx;"},{"entropy_rank":6,"patch_id":101,"patch_code":"indices[this.dimension] = idx;indices[last] = idx;"},{"entropy_rank":7,"patch_id":19,"patch_code":"while ((count < index) && !(index < 0 ||\n            index >= totalSize)) {\n            count += idx;\n            ++idx;\n        }while (count < index) {\n            count += idx;\n            ++idx;\n        }"},{"entropy_rank":8,"patch_id":58,"patch_code":"count += getSize();count += idx;"},{"entropy_rank":9,"patch_id":48,"patch_code":"while (count < index) {\n            count += idx;\n            ++idx;\n        }"},{"entropy_rank":10,"patch_id":50,"patch_code":"count += index;count += idx;"},{"entropy_rank":11,"patch_id":75,"patch_code":"++idx;\n\tcount += idx;\n            "},{"entropy_rank":12,"patch_id":17,"patch_code":"while ((count < index) && (index < 0 ||\n            index >= totalSize)) {\n            count += idx;\n            ++idx;\n        }while (count < index) {\n            count += idx;\n            ++idx;\n        }"},{"entropy_rank":13,"patch_id":57,"patch_code":"count += getDimension();count += idx;"},{"entropy_rank":14,"patch_id":16,"patch_code":"while ((count < index) || (index < 0 ||\n            index >= totalSize)) {\n            count += idx;\n            ++idx;\n        }while (count < index) {\n            count += idx;\n            ++idx;\n        }"},{"entropy_rank":15,"patch_id":67,"patch_code":"++count;++idx;"},{"entropy_rank":16,"patch_id":49,"patch_code":"count = idx;count += idx;"},{"entropy_rank":17,"patch_id":53,"patch_code":"count += this.totalSize;count += idx;"},{"entropy_rank":18,"patch_id":55,"patch_code":"count += this.last;count += idx;"},{"entropy_rank":19,"patch_id":52,"patch_code":"count += this.dimension;count += idx;"},{"entropy_rank":20,"patch_id":63,"patch_code":"++index;++idx;"},{"entropy_rank":21,"patch_id":46,"patch_code":"\n        --idx;\n        indices[last] = idx;\n\twhile (count < index) {\n            count += idx;\n            ++idx;\n        }\n"},{"entropy_rank":22,"patch_id":4,"patch_code":"short idx = 1;int idx = 1;"},{"entropy_rank":23,"patch_id":6,"patch_code":"byte idx = 1;int idx = 1;"},{"entropy_rank":24,"patch_id":110,"patch_code":"indices[last] = this.last;indices[last] = idx;"},{"entropy_rank":25,"patch_id":96,"patch_code":"--idx;"},{"entropy_rank":26,"patch_id":93,"patch_code":"--idx;\n\twhile (count < index) {\n            count += idx;\n            ++idx;\n        }\n        "},{"entropy_rank":27,"patch_id":109,"patch_code":"indices[last] = count;indices[last] = idx;"},{"entropy_rank":28,"patch_id":76,"patch_code":"++idx;"},{"entropy_rank":29,"patch_id":5,"patch_code":"char idx = 1;int idx = 1;"},{"entropy_rank":30,"patch_id":20,"patch_code":"while ((count < index) || (index < 0)) {\n            count += idx;\n            ++idx;\n        }while (count < index) {\n            count += idx;\n            ++idx;\n        }"},{"entropy_rank":31,"patch_id":23,"patch_code":"while ((count < index) && !(index < 0)) {\n            count += idx;\n            ++idx;\n        }while (count < index) {\n            count += idx;\n            ++idx;\n        }"},{"entropy_rank":32,"patch_id":81,"patch_code":"--count;--idx;"},{"entropy_rank":33,"patch_id":28,"patch_code":"while ((count < index) || (count <= index)) {\n            count += idx;\n            ++idx;\n        }while (count < index) {\n            count += idx;\n            ++idx;\n        }"},{"entropy_rank":34,"patch_id":31,"patch_code":"while ((count < index) && !(count <= index)) {\n            count += idx;\n            ++idx;\n        }while (count < index) {\n            count += idx;\n            ++idx;\n        }"},{"entropy_rank":35,"patch_id":27,"patch_code":"while ((count < index) && !(index >= totalSize)) {\n            count += idx;\n            ++idx;\n        }while (count < index) {\n            count += idx;\n            ++idx;\n        }"},{"entropy_rank":36,"patch_id":24,"patch_code":"while ((count < index) || (index >= totalSize)) {\n            count += idx;\n            ++idx;\n        }while (count < index) {\n            count += idx;\n            ++idx;\n        }"},{"entropy_rank":37,"patch_id":29,"patch_code":"while ((count < index) && (count <= index)) {\n            count += idx;\n            ++idx;\n        }while (count < index) {\n            count += idx;\n            ++idx;\n        }"},{"entropy_rank":38,"patch_id":30,"patch_code":"while ((count < index) || !(count <= index)) {\n            count += idx;\n            ++idx;\n        }while (count < index) {\n            count += idx;\n            ++idx;\n        }"},{"entropy_rank":39,"patch_id":21,"patch_code":"while ((count < index) && (index < 0)) {\n            count += idx;\n            ++idx;\n        }while (count < index) {\n            count += idx;\n            ++idx;\n        }"},{"entropy_rank":40,"patch_id":25,"patch_code":"while ((count < index) && (index >= totalSize)) {\n            count += idx;\n            ++idx;\n        }while (count < index) {\n            count += idx;\n            ++idx;\n        }"},{"entropy_rank":41,"patch_id":77,"patch_code":"--index;--idx;"},{"entropy_rank":42,"patch_id":14,"patch_code":"while (count>index) {\n            count += idx;\n            ++idx;\n        }while (count < index) {\n            count += idx;\n            ++idx;\n        }"},{"entropy_rank":43,"patch_id":13,"patch_code":"while (count<=index) {\n            count += idx;\n            ++idx;\n        }while (count < index) {\n            count += idx;\n            ++idx;\n        }"},{"entropy_rank":44,"patch_id":12,"patch_code":"while (count!=index) {\n            count += idx;\n            ++idx;\n        }while (count < index) {\n            count += idx;\n            ++idx;\n        }"},{"entropy_rank":45,"patch_id":15,"patch_code":"while (count>=index) {\n            count += idx;\n            ++idx;\n        }while (count < index) {\n            count += idx;\n            ++idx;\n        }"},{"entropy_rank":46,"patch_id":11,"patch_code":"while (count==index) {\n            count += idx;\n            ++idx;\n        }while (count < index) {\n            count += idx;\n            ++idx;\n        }"},{"entropy_rank":47,"patch_id":45,"patch_code":"\n        --idx;\n\twhile (count < index) {\n            count += idx;\n            ++idx;\n        }\n"},{"entropy_rank":48,"patch_id":94,"patch_code":"\n        indices[last] = idx;\n\t--idx;\n"},{"entropy_rank":49,"patch_id":61,"patch_code":"\n            ++idx;\n\tcount += idx;\n"}],"Math_57":[{"entropy_rank":1,"patch_id":1,"patch_code":"double sum = 0;int sum = 0;"},{"entropy_rank":2,"patch_id":3,"patch_code":"long sum = 0;int sum = 0;"},{"entropy_rank":3,"patch_id":2,"patch_code":"float sum = 0;int sum = 0;"},{"entropy_rank":4,"patch_id":5,"patch_code":"char sum = 0;int sum = 0;"}],"Math_58":[{"entropy_rank":1,"patch_id":2,"patch_code":"return fit(guess);return fit(new Gaussian.Parametric(), guess);"}],"Math_59":[{"entropy_rank":3,"patch_id":2,"patch_code":"return (a <= b) ? b : (b);return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);"},{"entropy_rank":4,"patch_id":10,"patch_code":"return (a <= b) ? b : (Float.isNaN(a - b) ? Float.NaN : b);return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);"},{"entropy_rank":5,"patch_id":7,"patch_code":"return (a<b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);"},{"entropy_rank":6,"patch_id":9,"patch_code":"return (a>=b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);"},{"entropy_rank":7,"patch_id":8,"patch_code":"return (a>b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);"},{"entropy_rank":8,"patch_id":5,"patch_code":"return (a==b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);"},{"entropy_rank":9,"patch_id":6,"patch_code":"return (a!=b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);"},{"entropy_rank":10,"patch_id":3,"patch_code":"return b;return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);"},{"entropy_rank":11,"patch_id":13,"patch_code":"return b;return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);"},{"entropy_rank":12,"patch_id":11,"patch_code":"return (a <= b) ? b : (Float.NaN);return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);"},{"entropy_rank":13,"patch_id":4,"patch_code":"return (Float.isNaN(a + b) ? Float.NaN : b);return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);"},{"entropy_rank":14,"patch_id":1,"patch_code":"return (a <= b) ? b : (Float.NaN);return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);"}],"Math_62":[{"entropy_rank":1,"patch_id":37,"patch_code":"sortPairs(goal);\n\treturn optimize(f, goal, min, max, 0);return optimize(f, goal, min, max, 0);"},{"entropy_rank":2,"patch_id":23,"patch_code":"if (f == null) {\n\t    throw new IllegalArgumentException(\"Null 'f' argument.\");\n\t}\nreturn optimize(f, goal, min, max, 0);return optimize(f, goal, min, max, 0);"},{"entropy_rank":3,"patch_id":28,"patch_code":"if (goal == null) {\n\t    throw new IllegalArgumentException(\"Null 'goal' argument.\");\n\t}\nreturn optimize(f, goal, min, max, 0);return optimize(f, goal, min, max, 0);"},{"entropy_rank":4,"patch_id":32,"patch_code":"if (!(f != null && goal != null)) return null;\n\treturn optimize(f, goal, min, max, 0);return optimize(f, goal, min, max, 0);"},{"entropy_rank":5,"patch_id":24,"patch_code":"if (f == null) {\n\t    return null;\n\t}\nreturn optimize(f, goal, min, max, 0);return optimize(f, goal, min, max, 0);"},{"entropy_rank":6,"patch_id":29,"patch_code":"if (goal == null) {\n\t    return null;\n\t}\nreturn optimize(f, goal, min, max, 0);return optimize(f, goal, min, max, 0);"},{"entropy_rank":7,"patch_id":52,"patch_code":"final double bound1 = (i == 0) ? startValue : min + generator.nextDouble() * (max - min);final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);"},{"entropy_rank":8,"patch_id":90,"patch_code":"final double bound1 = min + generator.nextDouble() * (max - min);final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);"},{"entropy_rank":9,"patch_id":84,"patch_code":"if (generator == null) {\n\t    throw new IllegalArgumentException(\"Null 'generator' argument.\");\n\t}\nfinal double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);"},{"entropy_rank":10,"patch_id":100,"patch_code":"final double bound1 = (i == 0) ? min : min - generator.nextDouble() * (max - min);final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);"},{"entropy_rank":12,"patch_id":55,"patch_code":"final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (startValue - min);final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);"},{"entropy_rank":13,"patch_id":54,"patch_code":"final double bound1 = (i == 0) ? min : startValue + generator.nextDouble() * (max - min);final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);"},{"entropy_rank":14,"patch_id":98,"patch_code":"final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max + min);final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);"},{"entropy_rank":15,"patch_id":58,"patch_code":"final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - startValue);final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);"},{"entropy_rank":16,"patch_id":89,"patch_code":"final double bound1 = min;final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);"},{"entropy_rank":17,"patch_id":99,"patch_code":"final double bound1 = (i == 0) ? min : min + generator.nextDouble() \/ (max - min);final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);"},{"entropy_rank":18,"patch_id":97,"patch_code":"final double bound1 = (i == 0) ? min : (min + generator.nextDouble()) * (max - min);final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);"},{"entropy_rank":19,"patch_id":61,"patch_code":"final double bound1 = (getEvaluations() == 0) ? min : min + generator.nextDouble() * (max - min);final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);"},{"entropy_rank":20,"patch_id":102,"patch_code":"final double bound1 = min + generator.nextDouble() * (max - min);final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);"},{"entropy_rank":21,"patch_id":60,"patch_code":"final double bound1 = (getMaxEvaluations() == 0) ? min : min + generator.nextDouble() * (max - min);final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);"},{"entropy_rank":22,"patch_id":94,"patch_code":"final double bound1 = (i>0) ? min : min + generator.nextDouble() * (max - min);final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);"},{"entropy_rank":23,"patch_id":96,"patch_code":"final double bound1 = (i == 0) ? min : min + (generator.nextDouble() * max) - min;final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);"},{"entropy_rank":24,"patch_id":76,"patch_code":"final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (getMaxEvaluations() - min);final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);"},{"entropy_rank":25,"patch_id":65,"patch_code":"final double bound1 = (i == 0) ? getEvaluations() : min + generator.nextDouble() * (max - min);final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);"},{"entropy_rank":26,"patch_id":64,"patch_code":"final double bound1 = (i == 0) ? getMaxEvaluations() : min + generator.nextDouble() * (max - min);final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);"},{"entropy_rank":27,"patch_id":92,"patch_code":"final double bound1 = (i<0) ? min : min + generator.nextDouble() * (max - min);final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);"},{"entropy_rank":28,"patch_id":93,"patch_code":"final double bound1 = (i<=0) ? min : min + generator.nextDouble() * (max - min);final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);"},{"entropy_rank":29,"patch_id":91,"patch_code":"final double bound1 = (i!=0) ? min : min + generator.nextDouble() * (max - min);final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);"},{"entropy_rank":30,"patch_id":68,"patch_code":"final double bound1 = (i == 0) ? min : getMaxEvaluations() + generator.nextDouble() * (max - min);final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);"},{"entropy_rank":31,"patch_id":77,"patch_code":"final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (getEvaluations() - min);final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);"},{"entropy_rank":32,"patch_id":80,"patch_code":"final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - getMaxEvaluations());final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);"},{"entropy_rank":33,"patch_id":95,"patch_code":"final double bound1 = (i>=0) ? min : min + generator.nextDouble() * (max - min);final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);"},{"entropy_rank":34,"patch_id":69,"patch_code":"final double bound1 = (i == 0) ? min : getEvaluations() + generator.nextDouble() * (max - min);final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);"},{"entropy_rank":35,"patch_id":81,"patch_code":"final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - getEvaluations());final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);"},{"entropy_rank":36,"patch_id":125,"patch_code":"final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (startValue - min);final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min);"},{"entropy_rank":39,"patch_id":106,"patch_code":"final double bound1 = (i == 0) ? min : min + generator.nextInt() * (max - min);final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);"},{"entropy_rank":42,"patch_id":88,"patch_code":"if (generator == null) continue;\n\tfinal double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);"},{"entropy_rank":44,"patch_id":123,"patch_code":"final double bound2 = (i == 0) ? max : bound1 + generator.nextDouble() * (max - min);final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min);"},{"entropy_rank":45,"patch_id":85,"patch_code":"if (generator == null) {\n\t    return null;\n\t}\nfinal double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);"},{"entropy_rank":46,"patch_id":5,"patch_code":"return optimize(f, goal, min, max);return optimize(f, goal, min, max, 0);"},{"entropy_rank":47,"patch_id":34,"patch_code":"return optimize(f, goal, min, max, 0f);return optimize(f, goal, min, max, 0);"},{"entropy_rank":48,"patch_id":33,"patch_code":"return optimize(f, goal, min, max, 0d);return optimize(f, goal, min, max, 0);"},{"entropy_rank":49,"patch_id":19,"patch_code":"return optimize(f, goal, min, getMaxEvaluations(), 0);return optimize(f, goal, min, max, 0);"},{"entropy_rank":50,"patch_id":15,"patch_code":"return optimize(f, goal, getMaxEvaluations(), max, 0);return optimize(f, goal, min, max, 0);"},{"entropy_rank":51,"patch_id":3,"patch_code":"return optimize(f, goal, max, 0);return optimize(f, goal, min, max, 0);"},{"entropy_rank":52,"patch_id":20,"patch_code":"return optimize(f, goal, min, getEvaluations(), 0);return optimize(f, goal, min, max, 0);"},{"entropy_rank":53,"patch_id":4,"patch_code":"return optimize(f, goal, min, 0);return optimize(f, goal, min, max, 0);"},{"entropy_rank":54,"patch_id":16,"patch_code":"return optimize(f, goal, getEvaluations(), max, 0);return optimize(f, goal, min, max, 0);"}],"Math_63":[{"entropy_rank":1,"patch_id":102,"patch_code":"return (Double.isNaN(x) || Double.isNaN(y)) || x == y;return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":2,"patch_id":97,"patch_code":"return (Double.isNaN(x) && Double.isNaN(y)) || x!=y;return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":3,"patch_id":85,"patch_code":"return ((Double.isNaN(x) && Double.isNaN(y)) || x == y) || ((x > ZS));return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":4,"patch_id":86,"patch_code":"return ((Double.isNaN(x) && Double.isNaN(y)) || x == y) && ((x > ZS));return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":5,"patch_id":87,"patch_code":"return ((Double.isNaN(x) && Double.isNaN(y)) || x == y) || !((x > ZS));return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":6,"patch_id":88,"patch_code":"return ((Double.isNaN(x) && Double.isNaN(y)) || x == y) && !((x > ZS));return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":7,"patch_id":58,"patch_code":"return ((Double.isNaN(x) && Double.isNaN(y)) || x == y) && ((x >= 0));return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":8,"patch_id":18,"patch_code":"return ((Double.isNaN(x) && Double.isNaN(y)) || x == y) && ((x == 0.0F));return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":9,"patch_id":57,"patch_code":"return ((Double.isNaN(x) && Double.isNaN(y)) || x == y) || ((x >= 0));return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":10,"patch_id":82,"patch_code":"return ((Double.isNaN(x) && Double.isNaN(y)) || x == y) && ((x > 0));return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":10,"patch_id":17,"patch_code":"return ((Double.isNaN(x) && Double.isNaN(y)) || x == y) || ((x == 0.0F));return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":12,"patch_id":100,"patch_code":"return (Double.isNaN(x) && Double.isNaN(y)) || x>y;return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":13,"patch_id":98,"patch_code":"return (Double.isNaN(x) && Double.isNaN(y)) || x<y;return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":14,"patch_id":60,"patch_code":"return ((Double.isNaN(x) && Double.isNaN(y)) || x == y) && !((x >= 0));return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":15,"patch_id":101,"patch_code":"return (Double.isNaN(x) && Double.isNaN(y)) || x>=y;return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":16,"patch_id":59,"patch_code":"return ((Double.isNaN(x) && Double.isNaN(y)) || x == y) || !((x >= 0));return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":17,"patch_id":81,"patch_code":"return ((Double.isNaN(x) && Double.isNaN(y)) || x == y) || ((x > 0));return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":18,"patch_id":33,"patch_code":"return ((Double.isNaN(x) && Double.isNaN(y)) || x == y) || ((x >= ZS));return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":19,"patch_id":45,"patch_code":"return ((Double.isNaN(x) && Double.isNaN(y)) || x == y) || ((x == 0L));return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":20,"patch_id":99,"patch_code":"return (Double.isNaN(x) && Double.isNaN(y)) || x<=y;return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":21,"patch_id":46,"patch_code":"return ((Double.isNaN(x) && Double.isNaN(y)) || x == y) && ((x == 0L));return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":22,"patch_id":34,"patch_code":"return ((Double.isNaN(x) && Double.isNaN(y)) || x == y) && ((x >= ZS));return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":23,"patch_id":70,"patch_code":"return ((Double.isNaN(x) && Double.isNaN(y)) || x == y) && ((x > ZB));return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":24,"patch_id":21,"patch_code":"return ((Double.isNaN(x) && Double.isNaN(y)) || x == y) || ((x >= ZB));return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":25,"patch_id":38,"patch_code":"return ((Double.isNaN(x) && Double.isNaN(y)) || x == y) && ((x == ZS));return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":26,"patch_id":50,"patch_code":"return ((Double.isNaN(x) && Double.isNaN(y)) || x == y) && ((x == 0.0));return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":27,"patch_id":19,"patch_code":"return ((Double.isNaN(x) && Double.isNaN(y)) || x == y) || !((x == 0.0F));return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":28,"patch_id":25,"patch_code":"return ((Double.isNaN(x) && Double.isNaN(y)) || x == y) || ((x >= 0.0F));return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":29,"patch_id":26,"patch_code":"return ((Double.isNaN(x) && Double.isNaN(y)) || x == y) && ((x >= 0.0F));return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":30,"patch_id":51,"patch_code":"return ((Double.isNaN(x) && Double.isNaN(y)) || x == y) || !((x == 0.0));return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":31,"patch_id":37,"patch_code":"return ((Double.isNaN(x) && Double.isNaN(y)) || x == y) || ((x == ZS));return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":31,"patch_id":22,"patch_code":"return ((Double.isNaN(x) && Double.isNaN(y)) || x == y) && ((x >= ZB));return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":33,"patch_id":83,"patch_code":"return ((Double.isNaN(x) && Double.isNaN(y)) || x == y) || !((x > 0));return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":34,"patch_id":69,"patch_code":"return ((Double.isNaN(x) && Double.isNaN(y)) || x == y) || ((x > ZB));return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":35,"patch_id":74,"patch_code":"return ((Double.isNaN(x) && Double.isNaN(y)) || x == y) && ((x > 0L));return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":36,"patch_id":52,"patch_code":"return ((Double.isNaN(x) && Double.isNaN(y)) || x == y) && !((x == 0.0));return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":37,"patch_id":84,"patch_code":"return ((Double.isNaN(x) && Double.isNaN(y)) || x == y) && !((x > 0));return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":37,"patch_id":20,"patch_code":"return ((Double.isNaN(x) && Double.isNaN(y)) || x == y) && !((x == 0.0F));return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":39,"patch_id":89,"patch_code":"return ((Double.isNaN(x) && Double.isNaN(y)) || x == y) || (x < y);return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":40,"patch_id":40,"patch_code":"return ((Double.isNaN(x) && Double.isNaN(y)) || x == y) && !((x == ZS));return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":41,"patch_id":39,"patch_code":"return ((Double.isNaN(x) && Double.isNaN(y)) || x == y) || !((x == ZS));return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":41,"patch_id":90,"patch_code":"return ((Double.isNaN(x) && Double.isNaN(y)) || x == y) && (x < y);return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":43,"patch_id":35,"patch_code":"return ((Double.isNaN(x) && Double.isNaN(y)) || x == y) || !((x >= ZS));return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":44,"patch_id":49,"patch_code":"return ((Double.isNaN(x) && Double.isNaN(y)) || x == y) || ((x == 0.0));return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":45,"patch_id":73,"patch_code":"return ((Double.isNaN(x) && Double.isNaN(y)) || x == y) || ((x > 0L));return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":46,"patch_id":27,"patch_code":"return ((Double.isNaN(x) && Double.isNaN(y)) || x == y) || !((x >= 0.0F));return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":47,"patch_id":28,"patch_code":"return ((Double.isNaN(x) && Double.isNaN(y)) || x == y) && !((x >= 0.0F));return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":48,"patch_id":71,"patch_code":"return ((Double.isNaN(x) && Double.isNaN(y)) || x == y) || !((x > ZB));return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":48,"patch_id":47,"patch_code":"return ((Double.isNaN(x) && Double.isNaN(y)) || x == y) || !((x == 0L));return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":50,"patch_id":36,"patch_code":"return ((Double.isNaN(x) && Double.isNaN(y)) || x == y) && !((x >= ZS));return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":51,"patch_id":76,"patch_code":"return ((Double.isNaN(x) && Double.isNaN(y)) || x == y) && !((x > 0L));return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":51,"patch_id":75,"patch_code":"return ((Double.isNaN(x) && Double.isNaN(y)) || x == y) || !((x > 0L));return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":53,"patch_id":23,"patch_code":"return ((Double.isNaN(x) && Double.isNaN(y)) || x == y) || !((x >= ZB));return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":54,"patch_id":72,"patch_code":"return ((Double.isNaN(x) && Double.isNaN(y)) || x == y) && !((x > ZB));return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":55,"patch_id":91,"patch_code":"return ((Double.isNaN(x) && Double.isNaN(y)) || x == y) || !(x < y);return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":56,"patch_id":48,"patch_code":"return ((Double.isNaN(x) && Double.isNaN(y)) || x == y) && !((x == 0L));return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":57,"patch_id":24,"patch_code":"return ((Double.isNaN(x) && Double.isNaN(y)) || x == y) && !((x >= ZB));return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":58,"patch_id":92,"patch_code":"return ((Double.isNaN(x) && Double.isNaN(y)) || x == y) && !(x < y);return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":59,"patch_id":77,"patch_code":"return ((Double.isNaN(x) && Double.isNaN(y)) || x == y) || ((x > 0.0));return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":60,"patch_id":78,"patch_code":"return ((Double.isNaN(x) && Double.isNaN(y)) || x == y) && ((x > 0.0));return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":61,"patch_id":13,"patch_code":"return ((Double.isNaN(x) && Double.isNaN(y)) || x == y) || ((x == ZB));return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":63,"patch_id":53,"patch_code":"return ((Double.isNaN(x) && Double.isNaN(y)) || x == y) || ((x >= 0L));return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":64,"patch_id":14,"patch_code":"return ((Double.isNaN(x) && Double.isNaN(y)) || x == y) && ((x == ZB));return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":65,"patch_id":65,"patch_code":"return ((Double.isNaN(x) && Double.isNaN(y)) || x == y) || ((x >= 0.0));return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":67,"patch_id":93,"patch_code":"return ((Double.isNaN(x) && Double.isNaN(y)) || x == y) || ((x > 0.0F));return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":67,"patch_id":15,"patch_code":"return ((Double.isNaN(x) && Double.isNaN(y)) || x == y) || !((x == ZB));return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":70,"patch_id":94,"patch_code":"return ((Double.isNaN(x) && Double.isNaN(y)) || x == y) && ((x > 0.0F));return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":71,"patch_id":54,"patch_code":"return ((Double.isNaN(x) && Double.isNaN(y)) || x == y) && ((x >= 0L));return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":72,"patch_id":66,"patch_code":"return ((Double.isNaN(x) && Double.isNaN(y)) || x == y) && ((x >= 0.0));return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":73,"patch_id":16,"patch_code":"return ((Double.isNaN(x) && Double.isNaN(y)) || x == y) && !((x == ZB));return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":74,"patch_id":79,"patch_code":"return ((Double.isNaN(x) && Double.isNaN(y)) || x == y) || !((x > 0.0));return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":76,"patch_id":95,"patch_code":"return ((Double.isNaN(x) && Double.isNaN(y)) || x == y) || !((x > 0.0F));return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":77,"patch_id":80,"patch_code":"return ((Double.isNaN(x) && Double.isNaN(y)) || x == y) && !((x > 0.0));return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":78,"patch_id":55,"patch_code":"return ((Double.isNaN(x) && Double.isNaN(y)) || x == y) || !((x >= 0L));return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":79,"patch_id":67,"patch_code":"return ((Double.isNaN(x) && Double.isNaN(y)) || x == y) || !((x >= 0.0));return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":80,"patch_id":96,"patch_code":"return ((Double.isNaN(x) && Double.isNaN(y)) || x == y) && !((x > 0.0F));return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":81,"patch_id":56,"patch_code":"return ((Double.isNaN(x) && Double.isNaN(y)) || x == y) && !((x >= 0L));return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"},{"entropy_rank":82,"patch_id":68,"patch_code":"return ((Double.isNaN(x) && Double.isNaN(y)) || x == y) && !((x >= 0.0));return (Double.isNaN(x) && Double.isNaN(y)) || x == y;"}],"Math_65":[{"entropy_rank":1,"patch_id":43,"patch_code":"if (residualsWeights == null) {\n\t    throw new IllegalArgumentException(\"Null 'residualsWeights' argument.\");\n\t}\nchiSquare += residual * residual \/ residualsWeights[i];chiSquare += residual * residual \/ residualsWeights[i];"},{"entropy_rank":2,"patch_id":44,"patch_code":"if (residualsWeights == null) {\n\t    return 0.0;\n\t}\nchiSquare += residual * residual \/ residualsWeights[i];chiSquare += residual * residual \/ residualsWeights[i];"},{"entropy_rank":3,"patch_id":60,"patch_code":"chiSquare += residual * residual * residualsWeights[i];chiSquare += residual * residual \/ residualsWeights[i];"},{"entropy_rank":4,"patch_id":42,"patch_code":"if (residualsWeights != null) {\n\tchiSquare += residual * residual \/ residualsWeights[i];\n\t}\nchiSquare += residual * residual \/ residualsWeights[i];\n\t}\n"},{"entropy_rank":5,"patch_id":4,"patch_code":"chiSquare += residual * chiSquare \/ residualsWeights[i];chiSquare += residual * residual \/ residualsWeights[i];"},{"entropy_rank":6,"patch_id":54,"patch_code":"chiSquare += residual * residual \/ (double)residualsWeights[i];chiSquare += residual * residual \/ residualsWeights[i];"},{"entropy_rank":7,"patch_id":2,"patch_code":"chiSquare += chiSquare * residual \/ residualsWeights[i];chiSquare += residual * residual \/ residualsWeights[i];"},{"entropy_rank":8,"patch_id":1,"patch_code":"chiSquare = residual * residual \/ residualsWeights[i];chiSquare += residual * residual \/ residualsWeights[i];"},{"entropy_rank":9,"patch_id":58,"patch_code":"chiSquare += residual * (residual \/ residualsWeights[i]);chiSquare += residual * residual \/ residualsWeights[i];"},{"entropy_rank":10,"patch_id":56,"patch_code":"chiSquare += (double)residual * residual \/ residualsWeights[i];chiSquare += residual * residual \/ residualsWeights[i];"},{"entropy_rank":11,"patch_id":59,"patch_code":"chiSquare += residual \/ residual \/ residualsWeights[i];chiSquare += residual * residual \/ residualsWeights[i];"},{"entropy_rank":12,"patch_id":35,"patch_code":"chiSquare += residual * residual \/ residualsWeights[getIterations()];chiSquare += residual * residual \/ residualsWeights[i];"},{"entropy_rank":13,"patch_id":16,"patch_code":"chiSquare += getRMS() * residual \/ residualsWeights[i];chiSquare += residual * residual \/ residualsWeights[i];"},{"entropy_rank":14,"patch_id":34,"patch_code":"chiSquare += residual * residual \/ residualsWeights[getMaxIterations()];chiSquare += residual * residual \/ residualsWeights[i];"},{"entropy_rank":15,"patch_id":24,"patch_code":"chiSquare += residual * getRMS() \/ residualsWeights[i];chiSquare += residual * residual \/ residualsWeights[i];"},{"entropy_rank":16,"patch_id":5,"patch_code":"chiSquare += residual * this.cost \/ residualsWeights[i];chiSquare += residual * residual \/ residualsWeights[i];"},{"entropy_rank":17,"patch_id":17,"patch_code":"chiSquare += getChiSquare() * residual \/ residualsWeights[i];chiSquare += residual * residual \/ residualsWeights[i];"},{"entropy_rank":18,"patch_id":3,"patch_code":"chiSquare += this.cost * residual \/ residualsWeights[i];chiSquare += residual * residual \/ residualsWeights[i];"},{"entropy_rank":19,"patch_id":37,"patch_code":"chiSquare += residual * residual \/ residualsWeights[getEvaluations()];chiSquare += residual * residual \/ residualsWeights[i];"},{"entropy_rank":20,"patch_id":57,"patch_code":"chiSquare += (float)residual * residual \/ residualsWeights[i];chiSquare += residual * residual \/ residualsWeights[i];"},{"entropy_rank":21,"patch_id":38,"patch_code":"chiSquare += residual * residual \/ residualsWeights[getJacobianEvaluations()];chiSquare += residual * residual \/ residualsWeights[i];"},{"entropy_rank":22,"patch_id":25,"patch_code":"chiSquare += residual * getChiSquare() \/ residualsWeights[i];chiSquare += residual * residual \/ residualsWeights[i];"},{"entropy_rank":23,"patch_id":36,"patch_code":"chiSquare += residual * residual \/ residualsWeights[getMaxEvaluations()];chiSquare += residual * residual \/ residualsWeights[i];"},{"entropy_rank":24,"patch_id":14,"patch_code":"chiSquare += getJacobianEvaluations() * residual \/ residualsWeights[i];chiSquare += residual * residual \/ residualsWeights[i];"},{"entropy_rank":25,"patch_id":55,"patch_code":"chiSquare += residual * residual \/ (float)residualsWeights[i];chiSquare += residual * residual \/ residualsWeights[i];"},{"entropy_rank":26,"patch_id":45,"patch_code":"if (residualsWeights == null) residualsWeights = this.targetValues;\n chiSquare += residual * residual \/ residualsWeights[i];chiSquare += residual * residual \/ residualsWeights[i];"},{"entropy_rank":27,"patch_id":61,"patch_code":"chiSquare += residual * residual % residualsWeights[i];chiSquare += residual * residual \/ residualsWeights[i];"},{"entropy_rank":28,"patch_id":48,"patch_code":"if (residualsWeights == null) residualsWeights = this.residuals;\n chiSquare += residual * residual \/ residualsWeights[i];chiSquare += residual * residual \/ residualsWeights[i];"},{"entropy_rank":29,"patch_id":7,"patch_code":"chiSquare += residual * residual \/ this.targetValues[i];chiSquare += residual * residual \/ residualsWeights[i];"},{"entropy_rank":30,"patch_id":50,"patch_code":"if (residualsWeights == null) return chiSquare;\n\t chiSquare += residual * residual \/ residualsWeights[i];chiSquare += residual * residual \/ residualsWeights[i];"},{"entropy_rank":31,"patch_id":18,"patch_code":"chiSquare += residual * getMaxIterations() \/ residualsWeights[i];chiSquare += residual * residual \/ residualsWeights[i];"},{"entropy_rank":32,"patch_id":22,"patch_code":"chiSquare += residual * getJacobianEvaluations() \/ residualsWeights[i];chiSquare += residual * residual \/ residualsWeights[i];"},{"entropy_rank":33,"patch_id":10,"patch_code":"chiSquare += getMaxIterations() * residual \/ residualsWeights[i];chiSquare += residual * residual \/ residualsWeights[i];"},{"entropy_rank":34,"patch_id":11,"patch_code":"chiSquare += getIterations() * residual \/ residualsWeights[i];chiSquare += residual * residual \/ residualsWeights[i];"},{"entropy_rank":35,"patch_id":46,"patch_code":"if (residualsWeights == null) residualsWeights = this.point;\n chiSquare += residual * residual \/ residualsWeights[i];chiSquare += residual * residual \/ residualsWeights[i];"},{"entropy_rank":36,"patch_id":12,"patch_code":"chiSquare += getMaxEvaluations() * residual \/ residualsWeights[i];chiSquare += residual * residual \/ residualsWeights[i];"},{"entropy_rank":37,"patch_id":20,"patch_code":"chiSquare += residual * getMaxEvaluations() \/ residualsWeights[i];chiSquare += residual * residual \/ residualsWeights[i];"},{"entropy_rank":38,"patch_id":13,"patch_code":"chiSquare += getEvaluations() * residual \/ residualsWeights[i];chiSquare += residual * residual \/ residualsWeights[i];"},{"entropy_rank":39,"patch_id":6,"patch_code":"chiSquare += residual * residual \/ this.residuals[i];chiSquare += residual * residual \/ residualsWeights[i];"},{"entropy_rank":40,"patch_id":47,"patch_code":"if (residualsWeights == null) residualsWeights = this.objective;\n chiSquare += residual * residual \/ residualsWeights[i];chiSquare += residual * residual \/ residualsWeights[i];"},{"entropy_rank":41,"patch_id":51,"patch_code":"if (residualsWeights == null) return this.cost;\n\t chiSquare += residual * residual \/ residualsWeights[i];chiSquare += residual * residual \/ residualsWeights[i];"},{"entropy_rank":42,"patch_id":19,"patch_code":"chiSquare += residual * getIterations() \/ residualsWeights[i];chiSquare += residual * residual \/ residualsWeights[i];"},{"entropy_rank":43,"patch_id":9,"patch_code":"chiSquare += residual * residual \/ this.point[i];chiSquare += residual * residual \/ residualsWeights[i];"},{"entropy_rank":44,"patch_id":21,"patch_code":"chiSquare += residual * getEvaluations() \/ residualsWeights[i];chiSquare += residual * residual \/ residualsWeights[i];"},{"entropy_rank":45,"patch_id":8,"patch_code":"chiSquare += residual * residual \/ this.objective[i];chiSquare += residual * residual \/ residualsWeights[i];"}],"Math_70":[{"entropy_rank":1,"patch_id":28,"patch_code":"return solve(f, min, max);return solve(min, max);"},{"entropy_rank":2,"patch_id":1,"patch_code":"return solve(initial, min, max);return solve(min, max);"},{"entropy_rank":3,"patch_id":41,"patch_code":"return solve(this.maximalIterationCount, this.absoluteAccuracy);return solve(min, max);"},{"entropy_rank":4,"patch_id":19,"patch_code":"return solve(min, max, initial);return solve(min, max);"},{"entropy_rank":5,"patch_id":32,"patch_code":"return solve(this.maximalIterationCount, this.maximalIterationCount);return solve(min, max);"},{"entropy_rank":6,"patch_id":56,"patch_code":"return solve(this.defaultMaximalIterationCount, this.defaultAbsoluteAccuracy);return solve(min, max);"},{"entropy_rank":7,"patch_id":88,"patch_code":"return solve(initial, initial);return solve(min, max);"},{"entropy_rank":8,"patch_id":42,"patch_code":"return solve(this.maximalIterationCount, this.relativeAccuracy);return solve(min, max);"},{"entropy_rank":9,"patch_id":43,"patch_code":"return solve(this.maximalIterationCount, this.defaultAbsoluteAccuracy);return solve(min, max);"},{"entropy_rank":10,"patch_id":29,"patch_code":"return solve(this.f, min, max);return solve(min, max);"},{"entropy_rank":11,"patch_id":57,"patch_code":"return solve(this.defaultMaximalIterationCount, this.defaultRelativeAccuracy);return solve(min, max);"},{"entropy_rank":12,"patch_id":10,"patch_code":"return solve(min, initial, max);return solve(min, max);"},{"entropy_rank":13,"patch_id":54,"patch_code":"return solve(this.defaultMaximalIterationCount, this.absoluteAccuracy);return solve(min, max);"},{"entropy_rank":14,"patch_id":33,"patch_code":"return solve(this.maximalIterationCount, this.defaultMaximalIterationCount);return solve(min, max);"},{"entropy_rank":14,"patch_id":46,"patch_code":"return solve(this.defaultMaximalIterationCount, this.defaultMaximalIterationCount);return solve(min, max);"},{"entropy_rank":16,"patch_id":87,"patch_code":"return solve(initial, min);return solve(min, max);"},{"entropy_rank":17,"patch_id":45,"patch_code":"return solve(this.defaultMaximalIterationCount, this.maximalIterationCount);return solve(min, max);"},{"entropy_rank":18,"patch_id":44,"patch_code":"return solve(this.maximalIterationCount, this.defaultRelativeAccuracy);return solve(min, max);"},{"entropy_rank":19,"patch_id":37,"patch_code":"return solve(this.maximalIterationCount, this.functionValueAccuracy);return solve(min, max);"},{"entropy_rank":20,"patch_id":58,"patch_code":"return solve(this.iterationCount, this.maximalIterationCount);return solve(min, max);"},{"entropy_rank":21,"patch_id":34,"patch_code":"return solve(this.maximalIterationCount, this.iterationCount);return solve(min, max);"},{"entropy_rank":22,"patch_id":51,"patch_code":"return solve(this.defaultMaximalIterationCount, this.defaultFunctionValueAccuracy);return solve(min, max);"},{"entropy_rank":23,"patch_id":36,"patch_code":"return solve(this.maximalIterationCount, initial);return solve(min, max);"},{"entropy_rank":24,"patch_id":71,"patch_code":"return solve(max, this.maximalIterationCount);return solve(min, max);"},{"entropy_rank":25,"patch_id":38,"patch_code":"return solve(this.maximalIterationCount, this.defaultFunctionValueAccuracy);return solve(min, max);"},{"entropy_rank":26,"patch_id":67,"patch_code":"return solve(this.iterationCount, this.absoluteAccuracy);return solve(min, max);"},{"entropy_rank":27,"patch_id":84,"patch_code":"return solve(initial, this.maximalIterationCount);return solve(min, max);"},{"entropy_rank":28,"patch_id":55,"patch_code":"return solve(this.defaultMaximalIterationCount, this.relativeAccuracy);return solve(min, max);"},{"entropy_rank":29,"patch_id":35,"patch_code":"return solve(this.maximalIterationCount, min);return solve(min, max);"},{"entropy_rank":30,"patch_id":74,"patch_code":"return solve(max, min);return solve(min, max);"},{"entropy_rank":31,"patch_id":75,"patch_code":"return solve(max, initial);return solve(min, max);"},{"entropy_rank":32,"patch_id":97,"patch_code":"return solve(this.functionValueAccuracy, this.maximalIterationCount);return solve(min, max);"},{"entropy_rank":33,"patch_id":40,"patch_code":"return solve(this.maximalIterationCount, this.functionValue);return solve(min, max);"},{"entropy_rank":34,"patch_id":15,"patch_code":"return solve(min, this.absoluteAccuracy, max);return solve(min, max);"},{"entropy_rank":35,"patch_id":24,"patch_code":"return solve(min, max, this.absoluteAccuracy);return solve(min, max);"},{"entropy_rank":36,"patch_id":50,"patch_code":"return solve(this.defaultMaximalIterationCount, this.functionValueAccuracy);return solve(min, max);"},{"entropy_rank":37,"patch_id":26,"patch_code":"return solve(min, max, this.defaultAbsoluteAccuracy);return solve(min, max);"},{"entropy_rank":38,"patch_id":59,"patch_code":"return solve(this.iterationCount, this.defaultMaximalIterationCount);return solve(min, max);"},{"entropy_rank":39,"patch_id":72,"patch_code":"return solve(max, this.defaultMaximalIterationCount);return solve(min, max);"},{"entropy_rank":40,"patch_id":6,"patch_code":"return solve(this.absoluteAccuracy, min, max);return solve(min, max);"},{"entropy_rank":41,"patch_id":85,"patch_code":"return solve(initial, this.defaultMaximalIterationCount);return solve(min, max);"},{"entropy_rank":41,"patch_id":17,"patch_code":"return solve(min, this.defaultAbsoluteAccuracy, max);return solve(min, max);"},{"entropy_rank":43,"patch_id":93,"patch_code":"return solve(initial, this.absoluteAccuracy);return solve(min, max);"},{"entropy_rank":44,"patch_id":39,"patch_code":"return solve(this.maximalIterationCount, this.result);return solve(min, max);"},{"entropy_rank":45,"patch_id":25,"patch_code":"return solve(min, max, this.relativeAccuracy);return solve(min, max);"},{"entropy_rank":46,"patch_id":60,"patch_code":"return solve(this.iterationCount, this.iterationCount);return solve(min, max);"},{"entropy_rank":47,"patch_id":49,"patch_code":"return solve(this.defaultMaximalIterationCount, initial);return solve(min, max);"},{"entropy_rank":48,"patch_id":8,"patch_code":"return solve(this.defaultAbsoluteAccuracy, min, max);return solve(min, max);"},{"entropy_rank":49,"patch_id":69,"patch_code":"return solve(this.iterationCount, this.defaultAbsoluteAccuracy);return solve(min, max);"},{"entropy_rank":50,"patch_id":68,"patch_code":"return solve(this.iterationCount, this.relativeAccuracy);return solve(min, max);"},{"entropy_rank":51,"patch_id":80,"patch_code":"return solve(max, this.absoluteAccuracy);return solve(min, max);"},{"entropy_rank":52,"patch_id":18,"patch_code":"return solve(min, this.defaultRelativeAccuracy, max);return solve(min, max);"},{"entropy_rank":53,"patch_id":95,"patch_code":"return solve(initial, this.defaultAbsoluteAccuracy);return solve(min, max);"},{"entropy_rank":54,"patch_id":27,"patch_code":"return solve(min, max, this.defaultRelativeAccuracy);return solve(min, max);"},{"entropy_rank":55,"patch_id":9,"patch_code":"return solve(this.defaultRelativeAccuracy, min, max);return solve(min, max);"},{"entropy_rank":56,"patch_id":16,"patch_code":"return solve(min, this.relativeAccuracy, max);return solve(min, max);"},{"entropy_rank":57,"patch_id":82,"patch_code":"return solve(max, this.defaultAbsoluteAccuracy);return solve(min, max);"},{"entropy_rank":58,"patch_id":48,"patch_code":"return solve(this.defaultMaximalIterationCount, min);return solve(min, max);"},{"entropy_rank":59,"patch_id":5,"patch_code":"return solve(this.functionValue, min, max);return solve(min, max);"},{"entropy_rank":60,"patch_id":47,"patch_code":"return solve(this.defaultMaximalIterationCount, this.iterationCount);return solve(min, max);"},{"entropy_rank":61,"patch_id":70,"patch_code":"return solve(this.iterationCount, this.defaultRelativeAccuracy);return solve(min, max);"},{"entropy_rank":62,"patch_id":63,"patch_code":"return solve(this.iterationCount, this.functionValueAccuracy);return solve(min, max);"},{"entropy_rank":63,"patch_id":7,"patch_code":"return solve(this.relativeAccuracy, min, max);return solve(min, max);"},{"entropy_rank":64,"patch_id":98,"patch_code":"return solve(this.functionValueAccuracy, this.defaultMaximalIterationCount);return solve(min, max);"},{"entropy_rank":65,"patch_id":53,"patch_code":"return solve(this.defaultMaximalIterationCount, this.functionValue);return solve(min, max);"},{"entropy_rank":66,"patch_id":3,"patch_code":"return solve(this.defaultFunctionValueAccuracy, min, max);return solve(min, max);"},{"entropy_rank":67,"patch_id":94,"patch_code":"return solve(initial, this.relativeAccuracy);return solve(min, max);"},{"entropy_rank":68,"patch_id":21,"patch_code":"return solve(min, max, this.defaultFunctionValueAccuracy);return solve(min, max);"},{"entropy_rank":69,"patch_id":66,"patch_code":"return solve(this.iterationCount, this.functionValue);return solve(min, max);"},{"entropy_rank":69,"patch_id":96,"patch_code":"return solve(initial, this.defaultRelativeAccuracy);return solve(min, max);"},{"entropy_rank":71,"patch_id":83,"patch_code":"return solve(max, this.defaultRelativeAccuracy);return solve(min, max);"},{"entropy_rank":72,"patch_id":4,"patch_code":"return solve(this.result, min, max);return solve(min, max);"},{"entropy_rank":73,"patch_id":99,"patch_code":"return solve(this.functionValueAccuracy, this.iterationCount);return solve(min, max);"},{"entropy_rank":74,"patch_id":20,"patch_code":"return solve(min, max, this.functionValueAccuracy);return solve(min, max);"},{"entropy_rank":75,"patch_id":62,"patch_code":"return solve(this.iterationCount, initial);return solve(min, max);"},{"entropy_rank":76,"patch_id":52,"patch_code":"return solve(this.defaultMaximalIterationCount, this.result);return solve(min, max);"},{"entropy_rank":77,"patch_id":81,"patch_code":"return solve(max, this.relativeAccuracy);return solve(min, max);"},{"entropy_rank":77,"patch_id":2,"patch_code":"return solve(this.functionValueAccuracy, min, max);return solve(min, max);"},{"entropy_rank":79,"patch_id":13,"patch_code":"return solve(min, this.result, max);return solve(min, max);"},{"entropy_rank":80,"patch_id":22,"patch_code":"return solve(min, max, this.result);return solve(min, max);"},{"entropy_rank":80,"patch_id":64,"patch_code":"return solve(this.iterationCount, this.defaultFunctionValueAccuracy);return solve(min, max);"},{"entropy_rank":82,"patch_id":12,"patch_code":"return solve(min, this.defaultFunctionValueAccuracy, max);return solve(min, max);"},{"entropy_rank":83,"patch_id":86,"patch_code":"return solve(initial, this.iterationCount);return solve(min, max);"},{"entropy_rank":84,"patch_id":14,"patch_code":"return solve(min, this.functionValue, max);return solve(min, max);"},{"entropy_rank":85,"patch_id":73,"patch_code":"return solve(max, this.iterationCount);return solve(min, max);"},{"entropy_rank":86,"patch_id":65,"patch_code":"return solve(this.iterationCount, this.result);return solve(min, max);"},{"entropy_rank":86,"patch_id":11,"patch_code":"return solve(min, this.functionValueAccuracy, max);return solve(min, max);"},{"entropy_rank":88,"patch_id":23,"patch_code":"return solve(min, max, this.functionValue);return solve(min, max);"},{"entropy_rank":89,"patch_id":61,"patch_code":"return solve(this.iterationCount, min);return solve(min, max);"},{"entropy_rank":90,"patch_id":89,"patch_code":"return solve(initial, this.functionValueAccuracy);return solve(min, max);"},{"entropy_rank":91,"patch_id":90,"patch_code":"return solve(initial, this.defaultFunctionValueAccuracy);return solve(min, max);"},{"entropy_rank":92,"patch_id":77,"patch_code":"return solve(max, this.defaultFunctionValueAccuracy);return solve(min, max);"},{"entropy_rank":93,"patch_id":101,"patch_code":"return solve(this.functionValueAccuracy, initial);return solve(min, max);"},{"entropy_rank":94,"patch_id":76,"patch_code":"return solve(max, this.functionValueAccuracy);return solve(min, max);"},{"entropy_rank":95,"patch_id":100,"patch_code":"return solve(this.functionValueAccuracy, min);return solve(min, max);"},{"entropy_rank":96,"patch_id":78,"patch_code":"return solve(max, this.result);return solve(min, max);"},{"entropy_rank":97,"patch_id":92,"patch_code":"return solve(initial, this.functionValue);return solve(min, max);"},{"entropy_rank":98,"patch_id":79,"patch_code":"return solve(max, this.functionValue);return solve(min, max);"},{"entropy_rank":99,"patch_id":91,"patch_code":"return solve(initial, this.result);return solve(min, max);"}],"Math_73":[{"entropy_rank":1,"patch_id":103,"patch_code":"return solve(this.f, min, yMin, max, yMax, initial, this.defaultRelativeAccuracy);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":2,"patch_id":92,"patch_code":"return solve(this.f, min, yMin, max, yMax, initial, yMin);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":3,"patch_id":95,"patch_code":"return solve(this.f, min, yMin, max, yMax, initial, initial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":4,"patch_id":28,"patch_code":"return solve(this.f, min, yInitial, max, yMax, initial, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":5,"patch_id":13,"patch_code":"return solve(this.f, yInitial, yMin, max, yMax, initial, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":6,"patch_id":15,"patch_code":"return solve(this.f, initial, yMin, max, yMax, initial, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":7,"patch_id":31,"patch_code":"return solve(this.f, min, initial, max, yMax, initial, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":8,"patch_id":18,"patch_code":"return solve(this.f, this.result, yMin, max, yMax, initial, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":9,"patch_id":12,"patch_code":"return solve(this.f, yMin, yMin, max, yMax, initial, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":10,"patch_id":16,"patch_code":"return solve(this.f, this.functionValueAccuracy, yMin, max, yMax, initial, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":11,"patch_id":91,"patch_code":"return solve(this.f, min, yMin, max, yMax, initial, yMax);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":12,"patch_id":11,"patch_code":"return solve(this.f, yMax, yMin, max, yMax, initial, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":13,"patch_id":78,"patch_code":"return solve(this.f, min, yMin, max, yMax, min, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":14,"patch_id":8,"patch_code":"return solve(this.f, this.maximalIterationCount, yMin, max, yMax, initial, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":15,"patch_id":76,"patch_code":"return solve(this.f, min, yMin, max, yMax, yMin, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":16,"patch_id":77,"patch_code":"return solve(this.f, min, yMin, max, yMax, yInitial, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":17,"patch_id":93,"patch_code":"return solve(this.f, min, yMin, max, yMax, initial, min);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":17,"patch_id":46,"patch_code":"return solve(this.f, min, yMin, min, yMax, initial, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":19,"patch_id":47,"patch_code":"return solve(this.f, min, yMin, initial, yMax, initial, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":20,"patch_id":94,"patch_code":"return solve(this.f, min, yMin, max, yMax, initial, max);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":20,"patch_id":14,"patch_code":"return solve(this.f, max, yMin, max, yMax, initial, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":22,"patch_id":27,"patch_code":"return solve(this.f, min, yMax, max, yMax, initial, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":23,"patch_id":79,"patch_code":"return solve(this.f, min, yMin, max, yMax, max, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":24,"patch_id":10,"patch_code":"return solve(this.f, this.iterationCount, yMin, max, yMax, initial, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":25,"patch_id":59,"patch_code":"return solve(this.f, min, yMin, max, yMin, initial, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":26,"patch_id":19,"patch_code":"return solve(this.f, this.functionValue, yMin, max, yMax, initial, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":27,"patch_id":29,"patch_code":"return solve(this.f, min, min, max, yMax, initial, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":28,"patch_id":96,"patch_code":"return solve(this.f, min, yMin, max, yMax, initial, this.functionValueAccuracy);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":29,"patch_id":80,"patch_code":"return solve(this.f, min, yMin, max, yMax, this.functionValueAccuracy, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":30,"patch_id":40,"patch_code":"return solve(this.f, min, yMin, this.maximalIterationCount, yMax, initial, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":31,"patch_id":72,"patch_code":"return solve(this.f, min, yMin, max, yMax, this.maximalIterationCount, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":32,"patch_id":17,"patch_code":"return solve(this.f, this.defaultFunctionValueAccuracy, yMin, max, yMax, initial, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":33,"patch_id":48,"patch_code":"return solve(this.f, min, yMin, this.functionValueAccuracy, yMax, initial, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":34,"patch_id":82,"patch_code":"return solve(this.f, min, yMin, max, yMax, this.result, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":35,"patch_id":45,"patch_code":"return solve(this.f, min, yMin, yInitial, yMax, initial, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":36,"patch_id":9,"patch_code":"return solve(this.f, this.defaultMaximalIterationCount, yMin, max, yMax, initial, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":37,"patch_id":44,"patch_code":"return solve(this.f, min, yMin, yMin, yMax, initial, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":38,"patch_id":60,"patch_code":"return solve(this.f, min, yMin, max, yInitial, initial, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":39,"patch_id":32,"patch_code":"return solve(this.f, min, this.functionValueAccuracy, max, yMax, initial, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":40,"patch_id":88,"patch_code":"return solve(this.f, min, yMin, max, yMax, initial, this.maximalIterationCount);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":40,"patch_id":30,"patch_code":"return solve(this.f, min, max, max, yMax, initial, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":42,"patch_id":75,"patch_code":"return solve(this.f, min, yMin, max, yMax, yMax, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":43,"patch_id":43,"patch_code":"return solve(this.f, min, yMin, yMax, yMax, initial, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":44,"patch_id":73,"patch_code":"return solve(this.f, min, yMin, max, yMax, this.defaultMaximalIterationCount, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":45,"patch_id":21,"patch_code":"return solve(this.f, this.relativeAccuracy, yMin, max, yMax, initial, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":46,"patch_id":81,"patch_code":"return solve(this.f, min, yMin, max, yMax, this.defaultFunctionValueAccuracy, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":47,"patch_id":89,"patch_code":"return solve(this.f, min, yMin, max, yMax, initial, this.defaultMaximalIterationCount);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":48,"patch_id":97,"patch_code":"return solve(this.f, min, yMin, max, yMax, initial, this.defaultFunctionValueAccuracy);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":48,"patch_id":98,"patch_code":"return solve(this.f, min, yMin, max, yMax, initial, this.result);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":50,"patch_id":56,"patch_code":"return solve(this.f, min, yMin, max, this.maximalIterationCount, initial, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":51,"patch_id":50,"patch_code":"return solve(this.f, min, yMin, this.result, yMax, initial, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":52,"patch_id":74,"patch_code":"return solve(this.f, min, yMin, max, yMax, this.iterationCount, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":53,"patch_id":64,"patch_code":"return solve(this.f, min, yMin, max, this.functionValueAccuracy, initial, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":54,"patch_id":24,"patch_code":"return solve(this.f, min, this.maximalIterationCount, max, yMax, initial, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":55,"patch_id":41,"patch_code":"return solve(this.f, min, yMin, this.defaultMaximalIterationCount, yMax, initial, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":56,"patch_id":90,"patch_code":"return solve(this.f, min, yMin, max, yMax, initial, this.iterationCount);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":57,"patch_id":49,"patch_code":"return solve(this.f, min, yMin, this.defaultFunctionValueAccuracy, yMax, initial, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":58,"patch_id":83,"patch_code":"return solve(this.f, min, yMin, max, yMax, this.functionValue, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":59,"patch_id":63,"patch_code":"return solve(this.f, min, yMin, max, initial, initial, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":60,"patch_id":34,"patch_code":"return solve(this.f, min, this.result, max, yMax, initial, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":61,"patch_id":23,"patch_code":"return solve(this.f, this.defaultRelativeAccuracy, yMin, max, yMax, initial, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":62,"patch_id":62,"patch_code":"return solve(this.f, min, yMin, max, max, initial, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":63,"patch_id":99,"patch_code":"return solve(this.f, min, yMin, max, yMax, initial, this.functionValue);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":64,"patch_id":33,"patch_code":"return solve(this.f, min, this.defaultFunctionValueAccuracy, max, yMax, initial, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":65,"patch_id":22,"patch_code":"return solve(this.f, this.defaultAbsoluteAccuracy, yMin, max, yMax, initial, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":66,"patch_id":42,"patch_code":"return solve(this.f, min, yMin, this.iterationCount, yMax, initial, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":67,"patch_id":20,"patch_code":"return solve(this.f, this.absoluteAccuracy, yMin, max, yMax, initial, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":68,"patch_id":35,"patch_code":"return solve(this.f, min, this.functionValue, max, yMax, initial, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":69,"patch_id":51,"patch_code":"return solve(this.f, min, yMin, this.functionValue, yMax, initial, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":70,"patch_id":66,"patch_code":"return solve(this.f, min, yMin, max, this.result, initial, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":71,"patch_id":85,"patch_code":"return solve(this.f, min, yMin, max, yMax, this.relativeAccuracy, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":72,"patch_id":57,"patch_code":"return solve(this.f, min, yMin, max, this.defaultMaximalIterationCount, initial, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":73,"patch_id":25,"patch_code":"return solve(this.f, min, this.defaultMaximalIterationCount, max, yMax, initial, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":74,"patch_id":84,"patch_code":"return solve(this.f, min, yMin, max, yMax, this.absoluteAccuracy, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":75,"patch_id":101,"patch_code":"return solve(this.f, min, yMin, max, yMax, initial, this.relativeAccuracy);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":76,"patch_id":53,"patch_code":"return solve(this.f, min, yMin, this.relativeAccuracy, yMax, initial, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":77,"patch_id":87,"patch_code":"return solve(this.f, min, yMin, max, yMax, this.defaultRelativeAccuracy, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":78,"patch_id":52,"patch_code":"return solve(this.f, min, yMin, this.absoluteAccuracy, yMax, initial, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":79,"patch_id":100,"patch_code":"return solve(this.f, min, yMin, max, yMax, initial, this.absoluteAccuracy);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":80,"patch_id":61,"patch_code":"return solve(this.f, min, yMin, max, min, initial, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":81,"patch_id":86,"patch_code":"return solve(this.f, min, yMin, max, yMax, this.defaultAbsoluteAccuracy, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":82,"patch_id":26,"patch_code":"return solve(this.f, min, this.iterationCount, max, yMax, initial, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":83,"patch_id":65,"patch_code":"return solve(this.f, min, yMin, max, this.defaultFunctionValueAccuracy, initial, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":84,"patch_id":67,"patch_code":"return solve(this.f, min, yMin, max, this.functionValue, initial, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":85,"patch_id":55,"patch_code":"return solve(this.f, min, yMin, this.defaultRelativeAccuracy, yMax, initial, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":86,"patch_id":54,"patch_code":"return solve(this.f, min, yMin, this.defaultAbsoluteAccuracy, yMax, initial, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":87,"patch_id":58,"patch_code":"return solve(this.f, min, yMin, max, this.iterationCount, initial, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":88,"patch_id":37,"patch_code":"return solve(this.f, min, this.relativeAccuracy, max, yMax, initial, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":89,"patch_id":39,"patch_code":"return solve(this.f, min, this.defaultRelativeAccuracy, max, yMax, initial, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":90,"patch_id":38,"patch_code":"return solve(this.f, min, this.defaultAbsoluteAccuracy, max, yMax, initial, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":91,"patch_id":36,"patch_code":"return solve(this.f, min, this.absoluteAccuracy, max, yMax, initial, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":92,"patch_id":68,"patch_code":"return solve(this.f, min, yMin, max, this.absoluteAccuracy, initial, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":93,"patch_id":69,"patch_code":"return solve(this.f, min, yMin, max, this.relativeAccuracy, initial, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":94,"patch_id":70,"patch_code":"return solve(this.f, min, yMin, max, this.defaultAbsoluteAccuracy, initial, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"},{"entropy_rank":95,"patch_id":71,"patch_code":"return solve(this.f, min, yMin, max, this.defaultRelativeAccuracy, initial, yInitial);return solve(f, min, yMin, max, yMax, initial, yInitial);"}],"Math_75":[{"entropy_rank":1,"patch_id":3,"patch_code":"return getPct((Comparable<?>) v);return getCumPct((Comparable<?>) v);"},{"entropy_rank":2,"patch_id":5,"patch_code":"return getCumFreq((Comparable<?>) v);return getCumPct((Comparable<?>) v);"},{"entropy_rank":3,"patch_id":4,"patch_code":"return getCount((Comparable<?>) v);return getCumPct((Comparable<?>) v);"}],"Math_77":[{"entropy_rank":2,"patch_id":1,"patch_code":"max = Math.max(max, Math.abs(a));max += Math.max(max, Math.abs(a));"}],"Math_79":[{"entropy_rank":1,"patch_id":2,"patch_code":"double sum = 0;int sum = 0;"},{"entropy_rank":2,"patch_id":1,"patch_code":"double sum = 0;\n      for (int i = 0; i < p1.length; i++) {\n          final double dp = p1[i] - p2[i];\n          sum += dp * dp;\n      }int sum = 0;\n      for (int i = 0; i < p1.length; i++) {\n          final int dp = p1[i] - p2[i];\n          sum += dp * dp;\n      }"},{"entropy_rank":3,"patch_id":3,"patch_code":"float sum = 0;\n      for (int i = 0; i < p1.length; i++) {\n          final float dp = p1[i] - p2[i];\n          sum += dp * dp;\n      }int sum = 0;\n      for (int i = 0; i < p1.length; i++) {\n          final int dp = p1[i] - p2[i];\n          sum += dp * dp;\n      }"},{"entropy_rank":4,"patch_id":5,"patch_code":"long sum = 0;\n      for (int i = 0; i < p1.length; i++) {\n          final long dp = p1[i] - p2[i];\n          sum += dp * dp;\n      }int sum = 0;\n      for (int i = 0; i < p1.length; i++) {\n          final int dp = p1[i] - p2[i];\n          sum += dp * dp;\n      }"},{"entropy_rank":5,"patch_id":6,"patch_code":"long sum = 0;int sum = 0;"},{"entropy_rank":6,"patch_id":4,"patch_code":"float sum = 0;int sum = 0;"},{"entropy_rank":7,"patch_id":8,"patch_code":"short sum = 0;int sum = 0;"},{"entropy_rank":8,"patch_id":12,"patch_code":"byte sum = 0;int sum = 0;"},{"entropy_rank":9,"patch_id":10,"patch_code":"char sum = 0;int sum = 0;"}],"Math_8":[{"entropy_rank":1,"patch_id":14,"patch_code":"if (singletons == null) {\n\t    throw new IllegalArgumentException(\"Null 'singletons' argument.\");\n\t}\nfinal T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);"},{"entropy_rank":2,"patch_id":15,"patch_code":"if (singletons == null) {\n\t    return null;\n\t}\nfinal T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);"},{"entropy_rank":3,"patch_id":3,"patch_code":"final T[]out = (T[]) java.lang.reflect.Array.newInstance(getSamples().get(0).getClass(), sampleSize);final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);"},{"entropy_rank":4,"patch_id":1,"patch_code":"\/**\n     * Generate a random sample from the distribution.\n     *\n     * @param sampleSize the number of random values to generate.\n     * @return an array representing the random sample.\n     * @throws NotStrictlyPositiveException if {@code sampleSize} is not\n     * positive.\n     *\/\n    public T[] sample(int sampleSize) throws NotStrictlyPositiveException {\n        if (sampleSize <= 0) {\n            throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n                    sampleSize);\n        }\n\n        final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);\n\n        for (int i = 0; i < sampleSize; i++) {\n            out[i] = sample();\n        }\n\n        return out;\n\n    }"}],"Math_80":[{"entropy_rank":1,"patch_id":7,"patch_code":"int j = 4 * this.pingPong - 1;int j = 4 * n - 1;"},{"entropy_rank":2,"patch_id":9,"patch_code":"int j = 4 * step - 1;int j = 4 * n - 1;"},{"entropy_rank":3,"patch_id":10,"patch_code":"int j = 4 * this.tType - 1;int j = 4 * n - 1;"}],"Math_82":[{"entropy_rank":1,"patch_id":1,"patch_code":"if (MathUtils.compareTo(entry, 0, epsilon)==0) {\n                final double ratio = rhs \/ entry;\n                if (ratio < minRatio) {\n                    minRatio = ratio;\n                    minRatioPos = i; \n                }\n            }if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n                final double ratio = rhs \/ entry;\n                if (ratio < minRatio) {\n                    minRatio = ratio;\n                    minRatioPos = i; \n                }\n            }"},{"entropy_rank":2,"patch_id":3,"patch_code":"if (MathUtils.compareTo(entry, 0, epsilon)<0) {\n                final double ratio = rhs \/ entry;\n                if (ratio < minRatio) {\n                    minRatio = ratio;\n                    minRatioPos = i; \n                }\n            }if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n                final double ratio = rhs \/ entry;\n                if (ratio < minRatio) {\n                    minRatio = ratio;\n                    minRatioPos = i; \n                }\n            }"},{"entropy_rank":3,"patch_id":5,"patch_code":"if (MathUtils.compareTo(entry, 0, epsilon)>0) {\n                final double ratio = rhs \/ entry;\n                if (ratio < minRatio) {\n                    minRatio = ratio;\n                    minRatioPos = i; \n                }\n            }if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n                final double ratio = rhs \/ entry;\n                if (ratio < minRatio) {\n                    minRatio = ratio;\n                    minRatioPos = i; \n                }\n            }"},{"entropy_rank":4,"patch_id":2,"patch_code":"if (MathUtils.compareTo(entry, 0, epsilon)!=0) {\n                final double ratio = rhs \/ entry;\n                if (ratio < minRatio) {\n                    minRatio = ratio;\n                    minRatioPos = i; \n                }\n            }if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n                final double ratio = rhs \/ entry;\n                if (ratio < minRatio) {\n                    minRatio = ratio;\n                    minRatioPos = i; \n                }\n            }"},{"entropy_rank":5,"patch_id":4,"patch_code":"if (MathUtils.compareTo(entry, 0, epsilon)<=0) {\n                final double ratio = rhs \/ entry;\n                if (ratio < minRatio) {\n                    minRatio = ratio;\n                    minRatioPos = i; \n                }\n            }if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n                final double ratio = rhs \/ entry;\n                if (ratio < minRatio) {\n                    minRatio = ratio;\n                    minRatioPos = i; \n                }\n            }"}],"Math_85":[{"entropy_rank":1,"patch_id":4,"patch_code":"if (fa * fb<=0.0 ) {\n            throw new ConvergenceException(\n                      \"number of iterations={0}, maximum iterations={1}, \" +\n                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n                      numIterations, maximumIterations, initial,\n                      lowerBound, upperBound, a, b, fa, fb);\n        }if (fa * fb >= 0.0 ) {\n            throw new ConvergenceException(\n                      \"number of iterations={0}, maximum iterations={1}, \" +\n                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n                      numIterations, maximumIterations, initial,\n                      lowerBound, upperBound, a, b, fa, fb);\n        }"},{"entropy_rank":2,"patch_id":2,"patch_code":"if (fa * fb!=0.0 ) {\n            throw new ConvergenceException(\n                      \"number of iterations={0}, maximum iterations={1}, \" +\n                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n                      numIterations, maximumIterations, initial,\n                      lowerBound, upperBound, a, b, fa, fb);\n        }if (fa * fb >= 0.0 ) {\n            throw new ConvergenceException(\n                      \"number of iterations={0}, maximum iterations={1}, \" +\n                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n                      numIterations, maximumIterations, initial,\n                      lowerBound, upperBound, a, b, fa, fb);\n        }"},{"entropy_rank":3,"patch_id":6,"patch_code":"if (fa \/ fb >= 0.0 ) {\n            throw new ConvergenceException(\n                      \"number of iterations={0}, maximum iterations={1}, \" +\n                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n                      numIterations, maximumIterations, initial,\n                      lowerBound, upperBound, a, b, fa, fb);\n        }if (fa * fb >= 0.0 ) {\n            throw new ConvergenceException(\n                      \"number of iterations={0}, maximum iterations={1}, \" +\n                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n                      numIterations, maximumIterations, initial,\n                      lowerBound, upperBound, a, b, fa, fb);\n        }"},{"entropy_rank":4,"patch_id":1,"patch_code":"if (fa * fb==0.0 ) {\n            throw new ConvergenceException(\n                      \"number of iterations={0}, maximum iterations={1}, \" +\n                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n                      numIterations, maximumIterations, initial,\n                      lowerBound, upperBound, a, b, fa, fb);\n        }if (fa * fb >= 0.0 ) {\n            throw new ConvergenceException(\n                      \"number of iterations={0}, maximum iterations={1}, \" +\n                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n                      numIterations, maximumIterations, initial,\n                      lowerBound, upperBound, a, b, fa, fb);\n        }"},{"entropy_rank":5,"patch_id":3,"patch_code":"if (fa * fb<0.0 ) {\n            throw new ConvergenceException(\n                      \"number of iterations={0}, maximum iterations={1}, \" +\n                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n                      numIterations, maximumIterations, initial,\n                      lowerBound, upperBound, a, b, fa, fb);\n        }if (fa * fb >= 0.0 ) {\n            throw new ConvergenceException(\n                      \"number of iterations={0}, maximum iterations={1}, \" +\n                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n                      numIterations, maximumIterations, initial,\n                      lowerBound, upperBound, a, b, fa, fb);\n        }"},{"entropy_rank":6,"patch_id":5,"patch_code":"if (fa * fb>0.0 ) {\n            throw new ConvergenceException(\n                      \"number of iterations={0}, maximum iterations={1}, \" +\n                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n                      numIterations, maximumIterations, initial,\n                      lowerBound, upperBound, a, b, fa, fb);\n        }if (fa * fb >= 0.0 ) {\n            throw new ConvergenceException(\n                      \"number of iterations={0}, maximum iterations={1}, \" +\n                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n                      numIterations, maximumIterations, initial,\n                      lowerBound, upperBound, a, b, fa, fb);\n        }"}],"Math_88":[{"entropy_rank":5,"patch_id":113,"patch_code":"coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) + (restrictToNonNegative ? 0 : mostNegative);coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);"},{"entropy_rank":6,"patch_id":189,"patch_code":"for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() - i; j++) {\n                    if (tableau.getEntry(basicRow, j) == 1) {\n                         coefficients[i] = 0;\n                    }\n                }for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n                    if (tableau.getEntry(basicRow, j) == 1) {\n                         coefficients[i] = 0;\n                    }\n                }"},{"entropy_rank":8,"patch_id":133,"patch_code":"initialize();\n\tcoefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);"},{"entropy_rank":9,"patch_id":32,"patch_code":"coefficients[getOriginalNumDecisionVariables()] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);"},{"entropy_rank":10,"patch_id":29,"patch_code":"coefficients[getArtificialVariableOffset()] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);"},{"entropy_rank":11,"patch_id":157,"patch_code":"if (getData() != null) {\n                for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n                    if (tableau.getEntry(basicRow, j) == 1) {\n                         coefficients[i] = 0;\n                    }\n                }\n            }if (basicRow != null) {\n                for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n                    if (tableau.getEntry(basicRow, j) == 1) {\n                         coefficients[i] = 0;\n                    }\n                }\n            }"},{"entropy_rank":12,"patch_id":22,"patch_code":"coefficients[getNumObjectiveFunctions()] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);"},{"entropy_rank":14,"patch_id":34,"patch_code":"coefficients[getNumArtificialVariables()] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);"},{"entropy_rank":15,"patch_id":28,"patch_code":"coefficients[getSlackVariableOffset()] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);"},{"entropy_rank":16,"patch_id":30,"patch_code":"coefficients[getRhsOffset()] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);"},{"entropy_rank":17,"patch_id":176,"patch_code":"for (int j = getNumObjectiveFunctions(); j < getSlackVariableOffset() + i; j++) {\n                    if (tableau.getEntry(basicRow, j) == 1) {\n                         coefficients[i] = 0;\n                    }\n                }for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n                    if (tableau.getEntry(basicRow, j) == 1) {\n                         coefficients[i] = 0;\n                    }\n                }"},{"entropy_rank":18,"patch_id":100,"patch_code":"coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : getOriginalNumDecisionVariables());coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);"},{"entropy_rank":19,"patch_id":31,"patch_code":"coefficients[getNumDecisionVariables()] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);"},{"entropy_rank":20,"patch_id":33,"patch_code":"coefficients[getNumSlackVariables()] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);"},{"entropy_rank":21,"patch_id":115,"patch_code":"coefficients[i] =\n                    (getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);"},{"entropy_rank":22,"patch_id":97,"patch_code":"coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : getArtificialVariableOffset());coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);"},{"entropy_rank":23,"patch_id":120,"patch_code":"coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (0);coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);"},{"entropy_rank":24,"patch_id":173,"patch_code":"for (int j = getNumObjectiveFunctions(); j < getNumVariables() + i; j++) {\n                    if (tableau.getEntry(basicRow, j) == 1) {\n                         coefficients[i] = 0;\n                    }\n                }for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n                    if (tableau.getEntry(basicRow, j) == 1) {\n                         coefficients[i] = 0;\n                    }\n                }"},{"entropy_rank":25,"patch_id":200,"patch_code":"if (j != i && (tableau.getEntry(basicRow, j) == 1)) {\n                         coefficients[i] = 0;\n                    }if (tableau.getEntry(basicRow, j) == 1) {\n                         coefficients[i] = 0;\n                    }"},{"entropy_rank":26,"patch_id":185,"patch_code":"for (int j = getNumObjectiveFunctions(); j!=getNumObjectiveFunctions() + i; j++) {\n                    if (tableau.getEntry(basicRow, j) == 1) {\n                         coefficients[i] = 0;\n                    }\n                }for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n                    if (tableau.getEntry(basicRow, j) == 1) {\n                         coefficients[i] = 0;\n                    }\n                }"},{"entropy_rank":27,"patch_id":196,"patch_code":"if (tableau.getEntry(basicRow, j)<1) {\n                         coefficients[i] = 0;\n                    }if (tableau.getEntry(basicRow, j) == 1) {\n                         coefficients[i] = 0;\n                    }"},{"entropy_rank":28,"patch_id":178,"patch_code":"for (int j = getNumObjectiveFunctions(); j < getRhsOffset() + i; j++) {\n                    if (tableau.getEntry(basicRow, j) == 1) {\n                         coefficients[i] = 0;\n                    }\n                }for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n                    if (tableau.getEntry(basicRow, j) == 1) {\n                         coefficients[i] = 0;\n                    }\n                }"},{"entropy_rank":29,"patch_id":175,"patch_code":"for (int j = getNumObjectiveFunctions(); j < getHeight() + i; j++) {\n                    if (tableau.getEntry(basicRow, j) == 1) {\n                         coefficients[i] = 0;\n                    }\n                }for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n                    if (tableau.getEntry(basicRow, j) == 1) {\n                         coefficients[i] = 0;\n                    }\n                }"},{"entropy_rank":30,"patch_id":121,"patch_code":"coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (mostNegative);coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);"},{"entropy_rank":31,"patch_id":198,"patch_code":"if (tableau.getEntry(basicRow, j)>1) {\n                         coefficients[i] = 0;\n                    }if (tableau.getEntry(basicRow, j) == 1) {\n                         coefficients[i] = 0;\n                    }"},{"entropy_rank":32,"patch_id":199,"patch_code":"if (tableau.getEntry(basicRow, j)>=1) {\n                         coefficients[i] = 0;\n                    }if (tableau.getEntry(basicRow, j) == 1) {\n                         coefficients[i] = 0;\n                    }"},{"entropy_rank":33,"patch_id":174,"patch_code":"for (int j = getNumObjectiveFunctions(); j < getWidth() + i; j++) {\n                    if (tableau.getEntry(basicRow, j) == 1) {\n                         coefficients[i] = 0;\n                    }\n                }for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n                    if (tableau.getEntry(basicRow, j) == 1) {\n                         coefficients[i] = 0;\n                    }\n                }"},{"entropy_rank":35,"patch_id":177,"patch_code":"for (int j = getNumObjectiveFunctions(); j < getArtificialVariableOffset() + i; j++) {\n                    if (tableau.getEntry(basicRow, j) == 1) {\n                         coefficients[i] = 0;\n                    }\n                }for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n                    if (tableau.getEntry(basicRow, j) == 1) {\n                         coefficients[i] = 0;\n                    }\n                }"},{"entropy_rank":36,"patch_id":191,"patch_code":"initialize();\n\tfor (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n                    if (tableau.getEntry(basicRow, j) == 1) {\n                         coefficients[i] = 0;\n                    }\n                }for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n                    if (tableau.getEntry(basicRow, j) == 1) {\n                         coefficients[i] = 0;\n                    }\n                }"},{"entropy_rank":37,"patch_id":182,"patch_code":"for (int j = getNumObjectiveFunctions(); j < getNumArtificialVariables() + i; j++) {\n                    if (tableau.getEntry(basicRow, j) == 1) {\n                         coefficients[i] = 0;\n                    }\n                }for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n                    if (tableau.getEntry(basicRow, j) == 1) {\n                         coefficients[i] = 0;\n                    }\n                }"},{"entropy_rank":38,"patch_id":197,"patch_code":"if (tableau.getEntry(basicRow, j)<=1) {\n                         coefficients[i] = 0;\n                    }if (tableau.getEntry(basicRow, j) == 1) {\n                         coefficients[i] = 0;\n                    }"},{"entropy_rank":39,"patch_id":96,"patch_code":"coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : getSlackVariableOffset());coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);"},{"entropy_rank":40,"patch_id":201,"patch_code":"if (j != i || (tableau.getEntry(basicRow, j) == 1)) {\n                         coefficients[i] = 0;\n                    }if (tableau.getEntry(basicRow, j) == 1) {\n                         coefficients[i] = 0;\n                    }"},{"entropy_rank":42,"patch_id":102,"patch_code":"coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : getNumArtificialVariables());coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);"},{"entropy_rank":43,"patch_id":195,"patch_code":"if (tableau.getEntry(basicRow, j)!=1) {\n                         coefficients[i] = 0;\n                    }if (tableau.getEntry(basicRow, j) == 1) {\n                         coefficients[i] = 0;\n                    }"},{"entropy_rank":45,"patch_id":194,"patch_code":"for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n                    if (tableau.getEntry(basicRow, j) == 1) {\n                         coefficients[i] = 0;\n                    }\n                }\n\tdiscardArtificialVariables();for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n                    if (tableau.getEntry(basicRow, j) == 1) {\n                         coefficients[i] = 0;\n                    }\n                }"},{"entropy_rank":46,"patch_id":192,"patch_code":"for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n                    if (tableau.getEntry(basicRow, j) == 1) {\n                         coefficients[i] = 0;\n                    }\n                }\n\tinitialize();for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n                    if (tableau.getEntry(basicRow, j) == 1) {\n                         coefficients[i] = 0;\n                    }\n                }"},{"entropy_rank":48,"patch_id":183,"patch_code":"for (int j = getNumObjectiveFunctions(); j < hashCode() + i; j++) {\n                    if (tableau.getEntry(basicRow, j) == 1) {\n                         coefficients[i] = 0;\n                    }\n                }for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n                    if (tableau.getEntry(basicRow, j) == 1) {\n                         coefficients[i] = 0;\n                    }\n                }"},{"entropy_rank":49,"patch_id":184,"patch_code":"for (int j = getNumObjectiveFunctions(); j==getNumObjectiveFunctions() + i; j++) {\n                    if (tableau.getEntry(basicRow, j) == 1) {\n                         coefficients[i] = 0;\n                    }\n                }for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n                    if (tableau.getEntry(basicRow, j) == 1) {\n                         coefficients[i] = 0;\n                    }\n                }"},{"entropy_rank":50,"patch_id":181,"patch_code":"for (int j = getNumObjectiveFunctions(); j < getNumSlackVariables() + i; j++) {\n                    if (tableau.getEntry(basicRow, j) == 1) {\n                         coefficients[i] = 0;\n                    }\n                }for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n                    if (tableau.getEntry(basicRow, j) == 1) {\n                         coefficients[i] = 0;\n                    }\n                }"},{"entropy_rank":51,"patch_id":193,"patch_code":"discardArtificialVariables();\n\tfor (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n                    if (tableau.getEntry(basicRow, j) == 1) {\n                         coefficients[i] = 0;\n                    }\n                }for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n                    if (tableau.getEntry(basicRow, j) == 1) {\n                         coefficients[i] = 0;\n                    }\n                }"},{"entropy_rank":52,"patch_id":20,"patch_code":"coefficients[getNumVariables()] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);"},{"entropy_rank":53,"patch_id":98,"patch_code":"coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : getRhsOffset());coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);"},{"entropy_rank":54,"patch_id":125,"patch_code":"coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0f : mostNegative);coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);"},{"entropy_rank":55,"patch_id":90,"patch_code":"coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : getNumObjectiveFunctions());coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);"},{"entropy_rank":56,"patch_id":187,"patch_code":"for (int j = getNumObjectiveFunctions(); j>getNumObjectiveFunctions() + i; j++) {\n                    if (tableau.getEntry(basicRow, j) == 1) {\n                         coefficients[i] = 0;\n                    }\n                }for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n                    if (tableau.getEntry(basicRow, j) == 1) {\n                         coefficients[i] = 0;\n                    }\n                }"},{"entropy_rank":57,"patch_id":101,"patch_code":"coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : getNumSlackVariables());coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);"},{"entropy_rank":58,"patch_id":180,"patch_code":"for (int j = getNumObjectiveFunctions(); j < getOriginalNumDecisionVariables() + i; j++) {\n                    if (tableau.getEntry(basicRow, j) == 1) {\n                         coefficients[i] = 0;\n                    }\n                }for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n                    if (tableau.getEntry(basicRow, j) == 1) {\n                         coefficients[i] = 0;\n                    }\n                }"},{"entropy_rank":59,"patch_id":131,"patch_code":"coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);"},{"entropy_rank":60,"patch_id":99,"patch_code":"coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : getNumDecisionVariables());coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);"},{"entropy_rank":61,"patch_id":63,"patch_code":"coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(getArtificialVariableOffset(), getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);"},{"entropy_rank":62,"patch_id":112,"patch_code":"coefficients[i] =\n                    (basicRow != null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);"},{"entropy_rank":63,"patch_id":118,"patch_code":"coefficients[i] =\n                    (0) -\n                    (restrictToNonNegative ? 0 : mostNegative);coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);"},{"entropy_rank":64,"patch_id":143,"patch_code":"if (getNormalizedConstraints() != null) {\n                for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n                    if (tableau.getEntry(basicRow, j) == 1) {\n                         coefficients[i] = 0;\n                    }\n                }\n            }if (basicRow != null) {\n                for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n                    if (tableau.getEntry(basicRow, j) == 1) {\n                         coefficients[i] = 0;\n                    }\n                }\n            }"},{"entropy_rank":65,"patch_id":66,"patch_code":"coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(getOriginalNumDecisionVariables(), getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);"},{"entropy_rank":66,"patch_id":64,"patch_code":"coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(getRhsOffset(), getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);"},{"entropy_rank":67,"patch_id":119,"patch_code":"coefficients[i] =\n                    (getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);"},{"entropy_rank":68,"patch_id":27,"patch_code":"coefficients[getHeight()] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);"},{"entropy_rank":69,"patch_id":26,"patch_code":"coefficients[getWidth()] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);"},{"entropy_rank":70,"patch_id":56,"patch_code":"coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(getNumObjectiveFunctions(), getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);"},{"entropy_rank":71,"patch_id":62,"patch_code":"coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(getSlackVariableOffset(), getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);"},{"entropy_rank":72,"patch_id":2,"patch_code":"coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : this.epsilon);coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);"},{"entropy_rank":73,"patch_id":117,"patch_code":"coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (mostNegative);coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);"},{"entropy_rank":74,"patch_id":68,"patch_code":"coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(getNumArtificialVariables(), getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);"},{"entropy_rank":75,"patch_id":186,"patch_code":"for (int j = getNumObjectiveFunctions(); j<=getNumObjectiveFunctions() + i; j++) {\n                    if (tableau.getEntry(basicRow, j) == 1) {\n                         coefficients[i] = 0;\n                    }\n                }for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n                    if (tableau.getEntry(basicRow, j) == 1) {\n                         coefficients[i] = 0;\n                    }\n                }"},{"entropy_rank":76,"patch_id":88,"patch_code":"coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : getNumVariables());coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);"},{"entropy_rank":77,"patch_id":65,"patch_code":"coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(getNumDecisionVariables(), getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);"},{"entropy_rank":78,"patch_id":67,"patch_code":"coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(getNumSlackVariables(), getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);"},{"entropy_rank":79,"patch_id":60,"patch_code":"coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(getWidth(), getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);"},{"entropy_rank":80,"patch_id":42,"patch_code":"coefficients[i] =\n                    (getSolution() == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);"},{"entropy_rank":81,"patch_id":61,"patch_code":"coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(getHeight(), getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);"},{"entropy_rank":82,"patch_id":36,"patch_code":"coefficients[hashCode()] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);"},{"entropy_rank":83,"patch_id":54,"patch_code":"coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(getNumVariables(), getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);"},{"entropy_rank":85,"patch_id":179,"patch_code":"for (int j = getNumObjectiveFunctions(); j < getNumDecisionVariables() + i; j++) {\n                    if (tableau.getEntry(basicRow, j) == 1) {\n                         coefficients[i] = 0;\n                    }\n                }for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n                    if (tableau.getEntry(basicRow, j) == 1) {\n                         coefficients[i] = 0;\n                    }\n                }"},{"entropy_rank":86,"patch_id":52,"patch_code":"coefficients[i] =\n                    (getData() == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);"},{"entropy_rank":87,"patch_id":161,"patch_code":"for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n                    if (tableau.getEntry(basicRow, j) == 1) {\n                         coefficients[i] = 0;\n                    }\n                }if (basicRow != null) {\n                for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n                    if (tableau.getEntry(basicRow, j) == 1) {\n                         coefficients[i] = 0;\n                    }\n                }\n            }"},{"entropy_rank":88,"patch_id":95,"patch_code":"coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : getHeight());coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);"},{"entropy_rank":89,"patch_id":38,"patch_code":"coefficients[i] =\n                    (getNormalizedConstraints() == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);"},{"entropy_rank":90,"patch_id":94,"patch_code":"coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : getWidth());coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);"},{"entropy_rank":91,"patch_id":106,"patch_code":"if (coefficients == null) {\n\t    throw new IllegalArgumentException(\"Null 'coefficients' argument.\");\n\t}\ncoefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);"},{"entropy_rank":92,"patch_id":70,"patch_code":"coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(hashCode(), getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);"},{"entropy_rank":93,"patch_id":132,"patch_code":""},{"entropy_rank":94,"patch_id":104,"patch_code":"coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : hashCode());coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);"},{"entropy_rank":96,"patch_id":129,"patch_code":"coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);\n\tbasicRow = getBasicRow(getNumObjectiveFunctions() + i);\n                \/\/ if multiple variables can take a given value \n                \/\/ then we choose the first and set the rest equal to 0\n                "},{"entropy_rank":97,"patch_id":110,"patch_code":"if (coefficients == null) continue;\n\tcoefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);"},{"entropy_rank":98,"patch_id":159,"patch_code":"if (basicRow != null) {\n                for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n                    if (tableau.getEntry(basicRow, j) == 1) {\n                         coefficients[i] = 0;\n                    }\n                }\n            }\n\tbasicRow = getBasicRow(getNumObjectiveFunctions() + i);\n                \/\/ if multiple variables can take a given value \n                \/\/ then we choose the first and set the rest equal to 0\n                coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);\n            "},{"entropy_rank":99,"patch_id":107,"patch_code":"if (coefficients == null) {\n\t    return null;\n\t}\ncoefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);"},{"entropy_rank":100,"patch_id":162,"patch_code":"if (basicRow != null) {\n                for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n                    if (tableau.getEntry(basicRow, j) == 1) {\n                         coefficients[i] = 0;\n                    }\n                }\n            }"},{"entropy_rank":101,"patch_id":114,"patch_code":"coefficients[i] =\n                    (0) -\n                    (restrictToNonNegative ? 0 : mostNegative);coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);"},{"entropy_rank":102,"patch_id":190,"patch_code":"for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n                    if (tableau.getEntry(basicRow, j) == 1) {\n                         coefficients[i] = 0;\n                    }\n                }"},{"entropy_rank":103,"patch_id":105,"patch_code":"if (coefficients != null) {\n\tcoefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);\n\t}\ncoefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);\n\t}\n"},{"entropy_rank":104,"patch_id":116,"patch_code":"coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (0);coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);"},{"entropy_rank":105,"patch_id":130,"patch_code":"\n            if (basicRow != null) {\n                for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n                    if (tableau.getEntry(basicRow, j) == 1) {\n                         coefficients[i] = 0;\n                    }\n                }\n            }\n\tcoefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);\n"},{"entropy_rank":106,"patch_id":160,"patch_code":"if (basicRow != null) {\n                for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n                    if (tableau.getEntry(basicRow, j) == 1) {\n                         coefficients[i] = 0;\n                    }\n                }\n            }\n\tcoefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);\n            "},{"entropy_rank":107,"patch_id":188,"patch_code":"for (int j = getNumObjectiveFunctions(); j>=getNumObjectiveFunctions() + i; j++) {\n                    if (tableau.getEntry(basicRow, j) == 1) {\n                         coefficients[i] = 0;\n                    }\n                }for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n                    if (tableau.getEntry(basicRow, j) == 1) {\n                         coefficients[i] = 0;\n                    }\n                }"}],"Math_89":[{"entropy_rank":1,"patch_id":14,"patch_code":"if (v instanceof Comparable<?>) {\n\taddValue((Comparable<?>) v);\n\t} else {\n\tthrow new IllegalArgumentException(\"Illegal argument: v\");\n}\naddValue((Comparable<?>) v);\n\t} else {\n\tthrow new IllegalArgumentException(\"Illegal argument: v\");\n}\n"},{"entropy_rank":2,"patch_id":11,"patch_code":"if (v == null) {\n\t    throw new IllegalArgumentException(\"Null 'v' argument.\");\n\t}\naddValue((Comparable<?>) v);addValue((Comparable<?>) v);"},{"entropy_rank":3,"patch_id":12,"patch_code":"if (v == null) {\n\t    return;\n\t}\naddValue((Comparable<?>) v);addValue((Comparable<?>) v);"},{"entropy_rank":4,"patch_id":2,"patch_code":"getCumPct((Comparable<?>) v);addValue((Comparable<?>) v);"},{"entropy_rank":5,"patch_id":10,"patch_code":"if (v != null) {\n\taddValue((Comparable<?>) v);\n\t}\naddValue((Comparable<?>) v);\n\t}\n"},{"entropy_rank":6,"patch_id":4,"patch_code":"getCumFreq((Comparable<?>) v);addValue((Comparable<?>) v);"},{"entropy_rank":7,"patch_id":3,"patch_code":"getCount((Comparable<?>) v);addValue((Comparable<?>) v);"},{"entropy_rank":8,"patch_id":1,"patch_code":"getPct((Comparable<?>) v);addValue((Comparable<?>) v);"},{"entropy_rank":9,"patch_id":9,"patch_code":"addValue((Comparable<?>) getSumFreq());addValue((Comparable<?>) v);"},{"entropy_rank":10,"patch_id":8,"patch_code":"addValue((Comparable<?>) valuesIterator());addValue((Comparable<?>) v);"},{"entropy_rank":11,"patch_id":13,"patch_code":"if (v == null) v = new Object();\n addValue((Comparable<?>) v);addValue((Comparable<?>) v);"},{"entropy_rank":12,"patch_id":6,"patch_code":"addValue((Comparable<?>) toString());addValue((Comparable<?>) v);"}],"Math_94":[{"entropy_rank":1,"patch_id":48,"patch_code":"\n        \/\/ keep u and v negative, as negative integers range down to\n        \/\/ -2^31, while positive numbers can only be as large as 2^31-1\n        \/\/ (i.e. we can't necessarily negate a negative number without\n        \/\/ overflow)\n        \/* assert u!=0 && v!=0; *\/\n        if (u > 0) {\n            u = -u;\n        } \/\/ make u negative\n        if (v > 0) {\n            v = -v;\n        }\n\tif (u * v == 0) {\n            return (Math.abs(u) + Math.abs(v));\n        }\n"},{"entropy_rank":2,"patch_id":19,"patch_code":"if ((u * v == 0) || ((u & 1) == 0 && (v & 1) == 0)) {\n            return (Math.abs(u) + Math.abs(v));\n        }if (u * v == 0) {\n            return (Math.abs(u) + Math.abs(v));\n        }"},{"entropy_rank":3,"patch_id":47,"patch_code":"\n        \/\/ keep u and v negative, as negative integers range down to\n        \/\/ -2^31, while positive numbers can only be as large as 2^31-1\n        \/\/ (i.e. we can't necessarily negate a negative number without\n        \/\/ overflow)\n        \/* assert u!=0 && v!=0; *\/\n        if (u > 0) {\n            u = -u;\n        }\n\tif (u * v == 0) {\n            return (Math.abs(u) + Math.abs(v));\n        }\n"},{"entropy_rank":4,"patch_id":20,"patch_code":"if ((u * v == 0) && ((u & 1) == 0 && (v & 1) == 0)) {\n            return (Math.abs(u) + Math.abs(v));\n        }if (u * v == 0) {\n            return (Math.abs(u) + Math.abs(v));\n        }"},{"entropy_rank":5,"patch_id":21,"patch_code":"if ((u * v == 0) || !((u & 1) == 0 && (v & 1) == 0)) {\n            return (Math.abs(u) + Math.abs(v));\n        }if (u * v == 0) {\n            return (Math.abs(u) + Math.abs(v));\n        }"},{"entropy_rank":6,"patch_id":38,"patch_code":"if (u == v || (u * v == 0)) {\n            return (Math.abs(u) + Math.abs(v));\n        }if (u * v == 0) {\n            return (Math.abs(u) + Math.abs(v));\n        }"},{"entropy_rank":7,"patch_id":23,"patch_code":"if ((u * v == 0) || (((u & 1) == 1))) {\n            return (Math.abs(u) + Math.abs(v));\n        }if (u * v == 0) {\n            return (Math.abs(u) + Math.abs(v));\n        }"},{"entropy_rank":8,"patch_id":24,"patch_code":"if ((u * v == 0) && (((u & 1) == 1))) {\n            return (Math.abs(u) + Math.abs(v));\n        }if (u * v == 0) {\n            return (Math.abs(u) + Math.abs(v));\n        }"},{"entropy_rank":9,"patch_id":46,"patch_code":"if (u >= v || (u * v == 0)) {\n            return (Math.abs(u) + Math.abs(v));\n        }if (u * v == 0) {\n            return (Math.abs(u) + Math.abs(v));\n        }"},{"entropy_rank":10,"patch_id":27,"patch_code":"if ((u * v == 0) || ((v & 1) == 0)) {\n            return (Math.abs(u) + Math.abs(v));\n        }if (u * v == 0) {\n            return (Math.abs(u) + Math.abs(v));\n        }"},{"entropy_rank":11,"patch_id":28,"patch_code":"if ((u * v == 0) && ((v & 1) == 0)) {\n            return (Math.abs(u) + Math.abs(v));\n        }if (u * v == 0) {\n            return (Math.abs(u) + Math.abs(v));\n        }"},{"entropy_rank":12,"patch_id":11,"patch_code":"if ((u * v == 0) || (v > 0)) {\n            return (Math.abs(u) + Math.abs(v));\n        }if (u * v == 0) {\n            return (Math.abs(u) + Math.abs(v));\n        }"},{"entropy_rank":13,"patch_id":40,"patch_code":"if (u < v || (u * v == 0)) {\n            return (Math.abs(u) + Math.abs(v));\n        }if (u * v == 0) {\n            return (Math.abs(u) + Math.abs(v));\n        }"},{"entropy_rank":14,"patch_id":25,"patch_code":"if ((u * v == 0) || !(((u & 1) == 1))) {\n            return (Math.abs(u) + Math.abs(v));\n        }if (u * v == 0) {\n            return (Math.abs(u) + Math.abs(v));\n        }"},{"entropy_rank":15,"patch_id":44,"patch_code":"if (u > v || (u * v == 0)) {\n            return (Math.abs(u) + Math.abs(v));\n        }if (u * v == 0) {\n            return (Math.abs(u) + Math.abs(v));\n        }"},{"entropy_rank":17,"patch_id":42,"patch_code":"if (u <= v || (u * v == 0)) {\n            return (Math.abs(u) + Math.abs(v));\n        }if (u * v == 0) {\n            return (Math.abs(u) + Math.abs(v));\n        }"},{"entropy_rank":18,"patch_id":29,"patch_code":"if ((u * v == 0) || !((v & 1) == 0)) {\n            return (Math.abs(u) + Math.abs(v));\n        }if (u * v == 0) {\n            return (Math.abs(u) + Math.abs(v));\n        }"},{"entropy_rank":19,"patch_id":13,"patch_code":"if ((u * v == 0) || !(v > 0)) {\n            return (Math.abs(u) + Math.abs(v));\n        }if (u * v == 0) {\n            return (Math.abs(u) + Math.abs(v));\n        }"},{"entropy_rank":20,"patch_id":36,"patch_code":"if (u != v || (u * v == 0)) {\n            return (Math.abs(u) + Math.abs(v));\n        }if (u * v == 0) {\n            return (Math.abs(u) + Math.abs(v));\n        }"},{"entropy_rank":22,"patch_id":35,"patch_code":"if (u != v && (u * v == 0)) {\n            return (Math.abs(u) + Math.abs(v));\n        }if (u * v == 0) {\n            return (Math.abs(u) + Math.abs(v));\n        }"},{"entropy_rank":23,"patch_id":31,"patch_code":"if ((u * v == 0) || ((u & 1) == 0)) {\n            return (Math.abs(u) + Math.abs(v));\n        }if (u * v == 0) {\n            return (Math.abs(u) + Math.abs(v));\n        }"},{"entropy_rank":24,"patch_id":33,"patch_code":"if ((u * v == 0) || !((u & 1) == 0)) {\n            return (Math.abs(u) + Math.abs(v));\n        }if (u * v == 0) {\n            return (Math.abs(u) + Math.abs(v));\n        }"},{"entropy_rank":25,"patch_id":34,"patch_code":"if ((u * v == 0) && !((u & 1) == 0)) {\n            return (Math.abs(u) + Math.abs(v));\n        }if (u * v == 0) {\n            return (Math.abs(u) + Math.abs(v));\n        }"},{"entropy_rank":26,"patch_id":6,"patch_code":"if (u \/ v == 0) {\n            return (Math.abs(u) + Math.abs(v));\n        }if (u * v == 0) {\n            return (Math.abs(u) + Math.abs(v));\n        }"},{"entropy_rank":27,"patch_id":49,"patch_code":"\n        \/\/ keep u and v negative, as negative integers range down to\n        \/\/ -2^31, while positive numbers can only be as large as 2^31-1\n        \/\/ (i.e. we can't necessarily negate a negative number without\n        \/\/ overflow)\n        \/* assert u!=0 && v!=0; *\/\n        if (u > 0) {\n            u = -u;\n        } \/\/ make u negative\n        if (v > 0) {\n            v = -v;\n        } \/\/ make v negative\n        \/\/ B1. [Find power of 2]\n        int k = 0;\n\tif (u * v == 0) {\n            return (Math.abs(u) + Math.abs(v));\n        }\n"},{"entropy_rank":28,"patch_id":5,"patch_code":"if (u * v>=0) {\n            return (Math.abs(u) + Math.abs(v));\n        }if (u * v == 0) {\n            return (Math.abs(u) + Math.abs(v));\n        }"},{"entropy_rank":29,"patch_id":3,"patch_code":"if (u * v<=0) {\n            return (Math.abs(u) + Math.abs(v));\n        }if (u * v == 0) {\n            return (Math.abs(u) + Math.abs(v));\n        }"},{"entropy_rank":30,"patch_id":52,"patch_code":"\n        \/\/ keep u and v negative, as negative integers range down to\n        \/\/ -2^31, while positive numbers can only be as large as 2^31-1\n        \/\/ (i.e. we can't necessarily negate a negative number without\n        \/\/ overflow)\n        \/* assert u!=0 && v!=0; *\/\n        if (u > 0) {\n            u = -u;\n        } \/\/ make u negative\n        if (v > 0) {\n            v = -v;\n        } \/\/ make v negative\n        \/\/ B1. [Find power of 2]\n        int k = 0;\n        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { \/\/ while u and v are\n                                                            \/\/ both even...\n            u \/= 2;\n            v \/= 2;\n            k++; \/\/ cast out twos.\n        }\n        if (k == 31) {\n            throw new ArithmeticException(\"overflow: gcd is 2^31\");\n        }\n        \/\/ B2. Initialize: u and v have been divided by 2^k and at least\n        \/\/ one is odd.\n        int t = ((u & 1) == 1) ? v : -(u \/ 2)\/* B3 *\/;\n\tif (u * v == 0) {\n            return (Math.abs(u) + Math.abs(v));\n        }\n"},{"entropy_rank":31,"patch_id":51,"patch_code":"\n        \/\/ keep u and v negative, as negative integers range down to\n        \/\/ -2^31, while positive numbers can only be as large as 2^31-1\n        \/\/ (i.e. we can't necessarily negate a negative number without\n        \/\/ overflow)\n        \/* assert u!=0 && v!=0; *\/\n        if (u > 0) {\n            u = -u;\n        } \/\/ make u negative\n        if (v > 0) {\n            v = -v;\n        } \/\/ make v negative\n        \/\/ B1. [Find power of 2]\n        int k = 0;\n        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { \/\/ while u and v are\n                                                            \/\/ both even...\n            u \/= 2;\n            v \/= 2;\n            k++; \/\/ cast out twos.\n        }\n        if (k == 31) {\n            throw new ArithmeticException(\"overflow: gcd is 2^31\");\n        }\n\tif (u * v == 0) {\n            return (Math.abs(u) + Math.abs(v));\n        }\n"},{"entropy_rank":32,"patch_id":50,"patch_code":"\n        \/\/ keep u and v negative, as negative integers range down to\n        \/\/ -2^31, while positive numbers can only be as large as 2^31-1\n        \/\/ (i.e. we can't necessarily negate a negative number without\n        \/\/ overflow)\n        \/* assert u!=0 && v!=0; *\/\n        if (u > 0) {\n            u = -u;\n        } \/\/ make u negative\n        if (v > 0) {\n            v = -v;\n        } \/\/ make v negative\n        \/\/ B1. [Find power of 2]\n        int k = 0;\n        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { \/\/ while u and v are\n                                                            \/\/ both even...\n            u \/= 2;\n            v \/= 2;\n            k++; \/\/ cast out twos.\n        }\n\tif (u * v == 0) {\n            return (Math.abs(u) + Math.abs(v));\n        }\n"}],"Math_96":[{"entropy_rank":1,"patch_id":109,"patch_code":"ret = (Double.doubleToRawLongBits(real) < Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) < Double.doubleToRawLongBits(rhs.getImaginary()));ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));"},{"entropy_rank":2,"patch_id":104,"patch_code":"ret = (Double.doubleToRawLongBits(real)<Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));"},{"entropy_rank":3,"patch_id":7,"patch_code":"ret = (Double.doubleToRawLongBits(getReal()) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));"},{"entropy_rank":4,"patch_id":48,"patch_code":"ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(getImaginary()) == Double.doubleToRawLongBits(rhs.getImaginary()));ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));"},{"entropy_rank":5,"patch_id":2,"patch_code":"ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(this.real) == Double.doubleToRawLongBits(rhs.getImaginary()));ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));"},{"entropy_rank":6,"patch_id":45,"patch_code":"ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(abs()) == Double.doubleToRawLongBits(rhs.getImaginary()));ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));"},{"entropy_rank":7,"patch_id":103,"patch_code":"ret = (Double.doubleToRawLongBits(real)!=Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));"},{"entropy_rank":8,"patch_id":6,"patch_code":"ret = (Double.doubleToRawLongBits(getImaginary()) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));"},{"entropy_rank":9,"patch_id":49,"patch_code":"ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(getReal()) == Double.doubleToRawLongBits(rhs.getImaginary()));ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));"},{"entropy_rank":10,"patch_id":67,"patch_code":"ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(conjugate().getImaginary()));ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));"},{"entropy_rank":11,"patch_id":47,"patch_code":"ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(hashCode()) == Double.doubleToRawLongBits(rhs.getImaginary()));ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));"},{"entropy_rank":11,"patch_id":73,"patch_code":"ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(negate().getImaginary()));ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));"},{"entropy_rank":13,"patch_id":107,"patch_code":"ret = (Double.doubleToRawLongBits(real)>=Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));"},{"entropy_rank":14,"patch_id":1,"patch_code":"ret = (Double.doubleToRawLongBits(this.imaginary) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));"},{"entropy_rank":15,"patch_id":77,"patch_code":"ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(cos().getImaginary()));ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));"},{"entropy_rank":16,"patch_id":5,"patch_code":"ret = (Double.doubleToRawLongBits(hashCode()) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));"},{"entropy_rank":17,"patch_id":3,"patch_code":"ret = (Double.doubleToRawLongBits(abs()) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));"},{"entropy_rank":18,"patch_id":35,"patch_code":"ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(cos().getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));"},{"entropy_rank":19,"patch_id":25,"patch_code":"ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(conjugate().getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));"},{"entropy_rank":20,"patch_id":74,"patch_code":"ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(acos().getImaginary()));ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));"},{"entropy_rank":21,"patch_id":31,"patch_code":"ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(negate().getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));"},{"entropy_rank":22,"patch_id":81,"patch_code":"ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(sin().getImaginary()));ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));"},{"entropy_rank":23,"patch_id":79,"patch_code":"ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(exp().getImaginary()));ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));"},{"entropy_rank":24,"patch_id":32,"patch_code":"ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(acos().getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));"},{"entropy_rank":25,"patch_id":85,"patch_code":"ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(tan().getImaginary()));ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));"},{"entropy_rank":25,"patch_id":80,"patch_code":"ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(log().getImaginary()));ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));"},{"entropy_rank":27,"patch_id":83,"patch_code":"ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(sqrt().getImaginary()));ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));"},{"entropy_rank":28,"patch_id":86,"patch_code":"ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(tanh().getImaginary()));ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));"},{"entropy_rank":29,"patch_id":78,"patch_code":"ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(cosh().getImaginary()));ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));"},{"entropy_rank":30,"patch_id":82,"patch_code":"ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(sinh().getImaginary()));ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));"},{"entropy_rank":31,"patch_id":44,"patch_code":"ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(tanh().getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));"},{"entropy_rank":32,"patch_id":43,"patch_code":"ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(tan().getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));"},{"entropy_rank":33,"patch_id":75,"patch_code":"ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(asin().getImaginary()));ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));"},{"entropy_rank":34,"patch_id":41,"patch_code":"ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(sqrt().getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));"},{"entropy_rank":35,"patch_id":38,"patch_code":"ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(log().getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));"},{"entropy_rank":36,"patch_id":37,"patch_code":"ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(exp().getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));"},{"entropy_rank":37,"patch_id":39,"patch_code":"ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(sin().getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));"},{"entropy_rank":37,"patch_id":36,"patch_code":"ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(cosh().getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));"},{"entropy_rank":39,"patch_id":76,"patch_code":"ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(atan().getImaginary()));ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));"},{"entropy_rank":40,"patch_id":40,"patch_code":"ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(sinh().getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));"},{"entropy_rank":41,"patch_id":88,"patch_code":"if (rhs == null) {\n\t    throw new IllegalArgumentException(\"Null 'rhs' argument.\");\n\t}\nret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));"},{"entropy_rank":42,"patch_id":33,"patch_code":"ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(asin().getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));"},{"entropy_rank":43,"patch_id":84,"patch_code":"ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(sqrt1z().getImaginary()));ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));"},{"entropy_rank":44,"patch_id":34,"patch_code":"ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(atan().getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));"},{"entropy_rank":45,"patch_id":42,"patch_code":"ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(sqrt1z().getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));"},{"entropy_rank":46,"patch_id":100,"patch_code":"if (rhs == null) rhs = Complex.ZERO;\n ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));"},{"entropy_rank":47,"patch_id":94,"patch_code":"if (rhs == null) rhs = Complex.NaN;\n ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));"},{"entropy_rank":48,"patch_id":98,"patch_code":"if (rhs == null) rhs = Complex.ONE;\n ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));"},{"entropy_rank":49,"patch_id":99,"patch_code":"if (rhs == null) rhs = ZERO;\n ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));"},{"entropy_rank":50,"patch_id":96,"patch_code":"if (rhs == null) rhs = Complex.INF;\n ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));"},{"entropy_rank":51,"patch_id":92,"patch_code":"if (rhs == null) rhs = Complex.I;\n ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));"},{"entropy_rank":52,"patch_id":89,"patch_code":"if (rhs == null) {\n\t    return false;\n\t}\nret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));"},{"entropy_rank":53,"patch_id":90,"patch_code":"if (rhs == null) {\n\t    return true;\n\t}\nret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));"},{"entropy_rank":54,"patch_id":97,"patch_code":"if (rhs == null) rhs = ONE;\n ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));"},{"entropy_rank":55,"patch_id":93,"patch_code":"if (rhs == null) rhs = NaN;\n ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));"},{"entropy_rank":56,"patch_id":95,"patch_code":"if (rhs == null) rhs = INF;\n ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));"},{"entropy_rank":57,"patch_id":91,"patch_code":"if (rhs == null) rhs = I;\n ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));"}],"Math_99":[{"entropy_rank":1,"patch_id":13,"patch_code":""},{"entropy_rank":2,"patch_id":5,"patch_code":"return (Math.abs(u) - Math.abs(v));return (Math.abs(u) + Math.abs(v));"},{"entropy_rank":3,"patch_id":6,"patch_code":"return (Math.abs(p) + Math.abs(v));return (Math.abs(u) + Math.abs(v));"},{"entropy_rank":4,"patch_id":9,"patch_code":"return (Math.abs(u) + Math.abs(q));return (Math.abs(u) + Math.abs(v));"},{"entropy_rank":5,"patch_id":7,"patch_code":"return (Math.abs(q) + Math.abs(v));return (Math.abs(u) + Math.abs(v));"},{"entropy_rank":6,"patch_id":8,"patch_code":"return (Math.abs(u) + Math.abs(p));return (Math.abs(u) + Math.abs(v));"},{"entropy_rank":7,"patch_id":11,"patch_code":"return a;return lcm;"},{"entropy_rank":8,"patch_id":12,"patch_code":"return b;return lcm;"},{"entropy_rank":9,"patch_id":2,"patch_code":"return u;\nreturn (Math.abs(u) + Math.abs(v));"},{"entropy_rank":10,"patch_id":4,"patch_code":"return q;\nreturn (Math.abs(u) + Math.abs(v));"},{"entropy_rank":11,"patch_id":1,"patch_code":"return v;\nreturn (Math.abs(u) + Math.abs(v));"},{"entropy_rank":12,"patch_id":3,"patch_code":"return p;\nreturn (Math.abs(u) + Math.abs(v));"}],"Time_17":[{"entropy_rank":2,"patch_id":57,"patch_code":"long instantBefore = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);"},{"entropy_rank":3,"patch_id":56,"patch_code":"long instantBefore = convertUTCToLocal(instant - 3 \/ DateTimeConstants.MILLIS_PER_HOUR);long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);"},{"entropy_rank":4,"patch_id":55,"patch_code":"long instantBefore = convertUTCToLocal((instant - 3) * DateTimeConstants.MILLIS_PER_HOUR);long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);"},{"entropy_rank":5,"patch_id":53,"patch_code":"long instantBefore = previousTransition(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);"},{"entropy_rank":6,"patch_id":50,"patch_code":"long instantBefore = getStandardOffset(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);"},{"entropy_rank":7,"patch_id":52,"patch_code":"long instantBefore = nextTransition(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);"},{"entropy_rank":8,"patch_id":49,"patch_code":"long instantBefore = getOffset(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);"},{"entropy_rank":10,"patch_id":51,"patch_code":"long instantBefore = getOffsetFromLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);"},{"entropy_rank":11,"patch_id":24,"patch_code":"long instantBefore = convertUTCToLocal(hashCode() - 3 * DateTimeConstants.MILLIS_PER_HOUR);long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);"}],"Time_18":[{"entropy_rank":1,"patch_id":108,"patch_code":"instant = iGregorianChronology.getDateTimeMillis\n                (dayOfMonth, year, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);instant = iGregorianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);"},{"entropy_rank":2,"patch_id":85,"patch_code":"if (iGregorianChronology == null) {\n\t    throw new IllegalArgumentException(\"Null 'iGregorianChronology' argument.\");\n\t}\ninstant = iGregorianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);instant = iGregorianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);"},{"entropy_rank":3,"patch_id":81,"patch_code":"instant = iGregorianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, getMinimumDaysInFirstWeek());instant = iGregorianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);"},{"entropy_rank":4,"patch_id":27,"patch_code":"instant = iGregorianChronology.getDateTimeMillis\n                (getMinimumDaysInFirstWeek(), monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);instant = iGregorianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);"},{"entropy_rank":5,"patch_id":89,"patch_code":"if (iGregorianChronology == null) return this.iCutoverMillis;\n\t instant = iGregorianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);instant = iGregorianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);"},{"entropy_rank":6,"patch_id":72,"patch_code":"instant = iGregorianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, getMinimumDaysInFirstWeek(), millisOfSecond);instant = iGregorianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);"},{"entropy_rank":7,"patch_id":54,"patch_code":"instant = iGregorianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 getMinimumDaysInFirstWeek(), minuteOfHour, secondOfMinute, millisOfSecond);instant = iGregorianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);"},{"entropy_rank":8,"patch_id":63,"patch_code":"instant = iGregorianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, getMinimumDaysInFirstWeek(), secondOfMinute, millisOfSecond);instant = iGregorianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);"},{"entropy_rank":9,"patch_id":45,"patch_code":"instant = iGregorianChronology.getDateTimeMillis\n                (year, monthOfYear, getMinimumDaysInFirstWeek(),\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);instant = iGregorianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);"},{"entropy_rank":10,"patch_id":55,"patch_code":"instant = iGregorianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hashCode(), minuteOfHour, secondOfMinute, millisOfSecond);instant = iGregorianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);"},{"entropy_rank":11,"patch_id":36,"patch_code":"instant = iGregorianChronology.getDateTimeMillis\n                (year, getMinimumDaysInFirstWeek(), dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);instant = iGregorianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);"},{"entropy_rank":12,"patch_id":73,"patch_code":"instant = iGregorianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, hashCode(), millisOfSecond);instant = iGregorianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);"},{"entropy_rank":13,"patch_id":82,"patch_code":"instant = iGregorianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, hashCode());instant = iGregorianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);"},{"entropy_rank":14,"patch_id":86,"patch_code":"if (iGregorianChronology == null) {\n\t    return 0;\n\t}\ninstant = iGregorianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);instant = iGregorianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);"},{"entropy_rank":15,"patch_id":90,"patch_code":"if (iGregorianChronology == null) return this.iGapDuration;\n\t instant = iGregorianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);instant = iGregorianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);"},{"entropy_rank":16,"patch_id":100,"patch_code":"instant = iGregorianChronology.getDateTimeMillis\n                (monthOfYear, hourOfDay, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);instant = iGregorianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);"},{"entropy_rank":17,"patch_id":64,"patch_code":"instant = iGregorianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, hashCode(), secondOfMinute, millisOfSecond);instant = iGregorianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);"},{"entropy_rank":18,"patch_id":99,"patch_code":"instant = iGregorianChronology.getDateTimeMillis\n                (monthOfYear, dayOfMonth, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);instant = iGregorianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);"},{"entropy_rank":19,"patch_id":16,"patch_code":"instant = withUTC().getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);instant = iGregorianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);"},{"entropy_rank":20,"patch_id":13,"patch_code":"instant = getInstance().getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);instant = iGregorianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);"},{"entropy_rank":21,"patch_id":12,"patch_code":"instant = getInstanceUTC().getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);instant = iGregorianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);"},{"entropy_rank":22,"patch_id":101,"patch_code":"instant = iGregorianChronology.getDateTimeMillis\n                (monthOfYear, minuteOfHour, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);instant = iGregorianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);"},{"entropy_rank":23,"patch_id":28,"patch_code":"instant = iGregorianChronology.getDateTimeMillis\n                (hashCode(), monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);instant = iGregorianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);"},{"entropy_rank":24,"patch_id":98,"patch_code":"instant = iGregorianChronology.getDateTimeMillis\n                (monthOfYear, year, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);instant = iGregorianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);"},{"entropy_rank":25,"patch_id":46,"patch_code":"instant = iGregorianChronology.getDateTimeMillis\n                (year, monthOfYear, hashCode(),\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);instant = iGregorianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);"},{"entropy_rank":26,"patch_id":37,"patch_code":"instant = iGregorianChronology.getDateTimeMillis\n                (year, hashCode(), dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);instant = iGregorianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);"}],"Time_19":[{"entropy_rank":1,"patch_id":3,"patch_code":"if (offsetLocal<0) {\n            long prev = previousTransition(instantAdjusted);\n            if (prev < instantAdjusted) {\n                int offsetPrev = getOffset(prev);\n                int diff = offsetPrev - offsetLocal;\n                if (instantAdjusted - prev <= diff) {\n                    return offsetPrev;\n                }\n            }\n        }if (offsetLocal > 0) {\n            long prev = previousTransition(instantAdjusted);\n            if (prev < instantAdjusted) {\n                int offsetPrev = getOffset(prev);\n                int diff = offsetPrev - offsetLocal;\n                if (instantAdjusted - prev <= diff) {\n                    return offsetPrev;\n                }\n            }\n        }"},{"entropy_rank":2,"patch_id":1,"patch_code":"if (offsetLocal==0) {\n            long prev = previousTransition(instantAdjusted);\n            if (prev < instantAdjusted) {\n                int offsetPrev = getOffset(prev);\n                int diff = offsetPrev - offsetLocal;\n                if (instantAdjusted - prev <= diff) {\n                    return offsetPrev;\n                }\n            }\n        }if (offsetLocal > 0) {\n            long prev = previousTransition(instantAdjusted);\n            if (prev < instantAdjusted) {\n                int offsetPrev = getOffset(prev);\n                int diff = offsetPrev - offsetLocal;\n                if (instantAdjusted - prev <= diff) {\n                    return offsetPrev;\n                }\n            }\n        }"},{"entropy_rank":3,"patch_id":4,"patch_code":"if (offsetLocal<=0) {\n            long prev = previousTransition(instantAdjusted);\n            if (prev < instantAdjusted) {\n                int offsetPrev = getOffset(prev);\n                int diff = offsetPrev - offsetLocal;\n                if (instantAdjusted - prev <= diff) {\n                    return offsetPrev;\n                }\n            }\n        }if (offsetLocal > 0) {\n            long prev = previousTransition(instantAdjusted);\n            if (prev < instantAdjusted) {\n                int offsetPrev = getOffset(prev);\n                int diff = offsetPrev - offsetLocal;\n                if (instantAdjusted - prev <= diff) {\n                    return offsetPrev;\n                }\n            }\n        }"},{"entropy_rank":4,"patch_id":2,"patch_code":"if (offsetLocal!=0) {\n            long prev = previousTransition(instantAdjusted);\n            if (prev < instantAdjusted) {\n                int offsetPrev = getOffset(prev);\n                int diff = offsetPrev - offsetLocal;\n                if (instantAdjusted - prev <= diff) {\n                    return offsetPrev;\n                }\n            }\n        }if (offsetLocal > 0) {\n            long prev = previousTransition(instantAdjusted);\n            if (prev < instantAdjusted) {\n                int offsetPrev = getOffset(prev);\n                int diff = offsetPrev - offsetLocal;\n                if (instantAdjusted - prev <= diff) {\n                    return offsetPrev;\n                }\n            }\n        }"},{"entropy_rank":5,"patch_id":5,"patch_code":"if (offsetLocal>=0) {\n            long prev = previousTransition(instantAdjusted);\n            if (prev < instantAdjusted) {\n                int offsetPrev = getOffset(prev);\n                int diff = offsetPrev - offsetLocal;\n                if (instantAdjusted - prev <= diff) {\n                    return offsetPrev;\n                }\n            }\n        }if (offsetLocal > 0) {\n            long prev = previousTransition(instantAdjusted);\n            if (prev < instantAdjusted) {\n                int offsetPrev = getOffset(prev);\n                int diff = offsetPrev - offsetLocal;\n                if (instantAdjusted - prev <= diff) {\n                    return offsetPrev;\n                }\n            }\n        }"}],"Time_2":[{"entropy_rank":7,"patch_id":36,"patch_code":"if (compare != i && (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false))) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }"},{"entropy_rank":8,"patch_id":38,"patch_code":"if (compare == i && (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false))) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }"},{"entropy_rank":9,"patch_id":16,"patch_code":"if ((compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) || (compare == 0)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }"},{"entropy_rank":10,"patch_id":20,"patch_code":"if ((compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) || (compare > 0)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }"},{"entropy_rank":11,"patch_id":39,"patch_code":"if (compare == i || (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false))) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }"},{"entropy_rank":12,"patch_id":21,"patch_code":"if ((compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) && (compare > 0)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }"},{"entropy_rank":13,"patch_id":37,"patch_code":"if (compare != i || (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false))) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }"},{"entropy_rank":15,"patch_id":46,"patch_code":"if (compare >= i && (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false))) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }"},{"entropy_rank":16,"patch_id":23,"patch_code":"if ((compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) && !(compare > 0)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }"},{"entropy_rank":17,"patch_id":19,"patch_code":"if ((compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) && !(compare == 0)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }"},{"entropy_rank":18,"patch_id":18,"patch_code":"if ((compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) || !(compare == 0)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }"},{"entropy_rank":19,"patch_id":22,"patch_code":"if ((compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) || !(compare > 0)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }"},{"entropy_rank":20,"patch_id":6,"patch_code":"if (compare < 0 || (compare==0 && loopUnitField.isSupported() == false)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }"},{"entropy_rank":21,"patch_id":17,"patch_code":"if ((compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) && (compare == 0)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }"},{"entropy_rank":22,"patch_id":41,"patch_code":"if (compare < i || (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false))) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }"},{"entropy_rank":23,"patch_id":9,"patch_code":"if (compare < 0 || (compare>0 && loopUnitField.isSupported() == false)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }"},{"entropy_rank":24,"patch_id":26,"patch_code":"if (compare == i && (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false))) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }"},{"entropy_rank":26,"patch_id":43,"patch_code":"if (compare <= i || (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false))) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }"},{"entropy_rank":27,"patch_id":5,"patch_code":"if (compare>=0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }"},{"entropy_rank":28,"patch_id":7,"patch_code":"if (compare < 0 || (compare<0 && loopUnitField.isSupported() == false)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }"},{"entropy_rank":30,"patch_id":24,"patch_code":"if (compare != i && (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false))) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }"},{"entropy_rank":31,"patch_id":3,"patch_code":"if (compare<=0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }"},{"entropy_rank":32,"patch_id":45,"patch_code":"if (compare > i || (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false))) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }"},{"entropy_rank":33,"patch_id":1,"patch_code":"if (compare==0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }"},{"entropy_rank":33,"patch_id":2,"patch_code":"if (compare!=0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }"},{"entropy_rank":35,"patch_id":10,"patch_code":"if (compare < 0 || (compare>=0 && loopUnitField.isSupported() == false)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }"},{"entropy_rank":36,"patch_id":27,"patch_code":"if (compare == i || (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false))) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }"},{"entropy_rank":37,"patch_id":4,"patch_code":"if (compare>0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }"},{"entropy_rank":38,"patch_id":32,"patch_code":"if (compare > i && (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false))) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }"},{"entropy_rank":39,"patch_id":8,"patch_code":"if (compare < 0 || (compare<=0 && loopUnitField.isSupported() == false)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }"},{"entropy_rank":40,"patch_id":42,"patch_code":"if (compare <= i && (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false))) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }"},{"entropy_rank":41,"patch_id":34,"patch_code":"if (compare >= i && (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false))) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }"},{"entropy_rank":42,"patch_id":44,"patch_code":"if (compare > i && (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false))) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }"},{"entropy_rank":43,"patch_id":28,"patch_code":"if (compare < i && (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false))) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }"},{"entropy_rank":44,"patch_id":40,"patch_code":"if (compare < i && (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false))) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }"},{"entropy_rank":45,"patch_id":25,"patch_code":"if (compare != i || (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false))) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }"},{"entropy_rank":46,"patch_id":30,"patch_code":"if (compare <= i && (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false))) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }"},{"entropy_rank":47,"patch_id":33,"patch_code":"if (compare > i || (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false))) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }"},{"entropy_rank":49,"patch_id":54,"patch_code":"if (compare < 0 || (compare != 0 || loopUnitField.isSupported() == false)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }"},{"entropy_rank":50,"patch_id":11,"patch_code":"if (compare < 0 || (compare != 0 && loopUnitField.isSupported()!=false)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }"},{"entropy_rank":51,"patch_id":35,"patch_code":"if (compare >= i || (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false))) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }"},{"entropy_rank":52,"patch_id":29,"patch_code":"if (compare < i || (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false))) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }"},{"entropy_rank":54,"patch_id":31,"patch_code":"if (compare <= i || (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false))) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }"},{"entropy_rank":56,"patch_id":47,"patch_code":"if (compare >= i || (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false))) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }"},{"entropy_rank":58,"patch_id":96,"patch_code":"DurationField rangeField = loopType.getRangeDurationType().getField(iChronology);DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);"},{"entropy_rank":59,"patch_id":68,"patch_code":"if (compare < 0 || (size() != 0 && loopUnitField.isSupported() == false)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }"}],"Time_26":[{"entropy_rank":8,"patch_id":26,"patch_code":"return iZone.convertLocalToUTC(instant, false);return iZone.convertLocalToUTC(localInstant, false);"},{"entropy_rank":10,"patch_id":11,"patch_code":"if (iZone == null) {\n\t    throw new IllegalArgumentException(\"Null 'iZone' argument.\");\n\t}\nreturn iZone.convertLocalToUTC(localInstant, false);return iZone.convertLocalToUTC(localInstant, false);"},{"entropy_rank":11,"patch_id":27,"patch_code":"return iZone.convertLocalToUTC(value, false);return iZone.convertLocalToUTC(localInstant, false);"},{"entropy_rank":12,"patch_id":99,"patch_code":"return iZone.convertLocalToUTC(localInstant, false, instant);return iZone.convertLocalToUTC(localInstant, false);"},{"entropy_rank":14,"patch_id":32,"patch_code":"if (iZone == null) return instant;\n\t return iZone.convertLocalToUTC(localInstant, false);return iZone.convertLocalToUTC(localInstant, false);"},{"entropy_rank":16,"patch_id":15,"patch_code":"return iZone.convertLocalToUTC(localInstant, true);return iZone.convertLocalToUTC(localInstant, false);"},{"entropy_rank":18,"patch_id":47,"patch_code":"if (iZone == null) {\n\t    return 0;\n\t}\nreturn iZone.convertLocalToUTC(localInstant, false);return iZone.convertLocalToUTC(localInstant, false);"},{"entropy_rank":19,"patch_id":29,"patch_code":"if (iZone == null) {\n\t    throw new IllegalArgumentException(\"Null 'iZone' argument.\");\n\t}\nreturn iZone.convertLocalToUTC(localInstant, false);return iZone.convertLocalToUTC(localInstant, false);"},{"entropy_rank":22,"patch_id":30,"patch_code":"if (iZone == null) {\n\t    return 0;\n\t}\nreturn iZone.convertLocalToUTC(localInstant, false);return iZone.convertLocalToUTC(localInstant, false);"},{"entropy_rank":24,"patch_id":46,"patch_code":"if (iZone == null) {\n\t    throw new IllegalArgumentException(\"Null 'iZone' argument.\");\n\t}\nreturn iZone.convertLocalToUTC(localInstant, false);return iZone.convertLocalToUTC(localInstant, false);"},{"entropy_rank":25,"patch_id":86,"patch_code":"return iZone.convertLocalToUTC(instant, false);return iZone.convertLocalToUTC(localInstant, false);"},{"entropy_rank":27,"patch_id":14,"patch_code":"if (iZone == null) return instant;\n\t return iZone.convertLocalToUTC(localInstant, false);return iZone.convertLocalToUTC(localInstant, false);"},{"entropy_rank":35,"patch_id":23,"patch_code":"return iZone.convertLocalToUTC(localInstant, false, value);return iZone.convertLocalToUTC(localInstant, false);"},{"entropy_rank":36,"patch_id":61,"patch_code":"if (iZone == null) {\n\t    throw new IllegalArgumentException(\"Null 'iZone' argument.\");\n\t}\nlong result = iZone.convertLocalToUTC(localInstant, false);long result = iZone.convertLocalToUTC(localInstant, false);"},{"entropy_rank":40,"patch_id":58,"patch_code":"long result = iZone.convertLocalToUTC(instant, false);long result = iZone.convertLocalToUTC(localInstant, false);"}],"Time_3":[{"entropy_rank":1,"patch_id":101,"patch_code":"addWeekyears(amount);\n\tsetMillis(type.getField(getChronology()).add(getMillis(), amount));setMillis(type.getField(getChronology()).add(getMillis(), amount));"},{"entropy_rank":2,"patch_id":95,"patch_code":"addYears(amount);\n\tsetMillis(type.getField(getChronology()).add(getMillis(), amount));setMillis(type.getField(getChronology()).add(getMillis(), amount));"},{"entropy_rank":3,"patch_id":98,"patch_code":"setWeekyear(amount);\n\tsetMillis(type.getField(getChronology()).add(getMillis(), amount));setMillis(type.getField(getChronology()).add(getMillis(), amount));"},{"entropy_rank":4,"patch_id":92,"patch_code":"setYear(amount);\n\tsetMillis(type.getField(getChronology()).add(getMillis(), amount));setMillis(type.getField(getChronology()).add(getMillis(), amount));"},{"entropy_rank":5,"patch_id":88,"patch_code":"setMillis(type.getField(getChronology()).add(getMillis(), amount));\n\tif (type == null) {\n            throw new IllegalArgumentException(\"Field must not be null\");\n        }\n            "},{"entropy_rank":6,"patch_id":151,"patch_code":"setMillisOfDay(amount);setMillis(type.getField(getChronology()).add(getMillis(), amount));"},{"entropy_rank":7,"patch_id":2,"patch_code":"add(type.getField(getChronology()).add(getMillis(), amount));setMillis(type.getField(getChronology()).add(getMillis(), amount));"},{"entropy_rank":8,"patch_id":30,"patch_code":"setTime(type.getField(getChronology()).add(getMillis(), amount));setMillis(type.getField(getChronology()).add(getMillis(), amount));"},{"entropy_rank":9,"patch_id":139,"patch_code":"addMinutes(amount);setMillis(type.getField(getChronology()).add(getMillis(), amount));"},{"entropy_rank":10,"patch_id":152,"patch_code":"setMillisOfDay(amount);\n\tsetMillis(type.getField(getChronology()).add(getMillis(), amount));setMillis(type.getField(getChronology()).add(getMillis(), amount));"},{"entropy_rank":11,"patch_id":29,"patch_code":"setDate(type.getField(getChronology()).add(getMillis(), amount));setMillis(type.getField(getChronology()).add(getMillis(), amount));"},{"entropy_rank":12,"patch_id":66,"patch_code":"setMillis(type.getField(getChronology()).add(getMillis(), getRoundingMode()));setMillis(type.getField(getChronology()).add(getMillis(), amount));"},{"entropy_rank":13,"patch_id":99,"patch_code":"setMillis(type.getField(getChronology()).add(getMillis(), amount));\n\tsetWeekyear(amount);setMillis(type.getField(getChronology()).add(getMillis(), amount));"},{"entropy_rank":14,"patch_id":104,"patch_code":"setMonthOfYear(amount);\n\tsetMillis(type.getField(getChronology()).add(getMillis(), amount));setMillis(type.getField(getChronology()).add(getMillis(), amount));"},{"entropy_rank":15,"patch_id":115,"patch_code":"setDayOfYear(amount);setMillis(type.getField(getChronology()).add(getMillis(), amount));"},{"entropy_rank":16,"patch_id":93,"patch_code":"setMillis(type.getField(getChronology()).add(getMillis(), amount));\n\tsetYear(amount);setMillis(type.getField(getChronology()).add(getMillis(), amount));"},{"entropy_rank":17,"patch_id":153,"patch_code":"setMillis(type.getField(getChronology()).add(getMillis(), amount));\n\tsetMillisOfDay(amount);setMillis(type.getField(getChronology()).add(getMillis(), amount));"},{"entropy_rank":18,"patch_id":39,"patch_code":"setMillis(type.getField(getChronology()).add(getMillis(), this.iRoundingMode));setMillis(type.getField(getChronology()).add(getMillis(), amount));"},{"entropy_rank":19,"patch_id":140,"patch_code":"addMinutes(amount);\n\tsetMillis(type.getField(getChronology()).add(getMillis(), amount));setMillis(type.getField(getChronology()).add(getMillis(), amount));"},{"entropy_rank":20,"patch_id":127,"patch_code":"setHourOfDay(amount);setMillis(type.getField(getChronology()).add(getMillis(), amount));"},{"entropy_rank":21,"patch_id":116,"patch_code":"setDayOfYear(amount);\n\tsetMillis(type.getField(getChronology()).add(getMillis(), amount));setMillis(type.getField(getChronology()).add(getMillis(), amount));"},{"entropy_rank":22,"patch_id":89,"patch_code":"setMillis(type.getField(getChronology()).add(getMillis(), amount));"},{"entropy_rank":23,"patch_id":106,"patch_code":"addMonths(amount);setMillis(type.getField(getChronology()).add(getMillis(), amount));"},{"entropy_rank":24,"patch_id":144,"patch_code":"setMillis(type.getField(getChronology()).add(getMillis(), amount));\n\tsetSecondOfDay(amount);setMillis(type.getField(getChronology()).add(getMillis(), amount));"},{"entropy_rank":25,"patch_id":100,"patch_code":"addWeekyears(amount);setMillis(type.getField(getChronology()).add(getMillis(), amount));"},{"entropy_rank":26,"patch_id":117,"patch_code":"setMillis(type.getField(getChronology()).add(getMillis(), amount));\n\tsetDayOfYear(amount);setMillis(type.getField(getChronology()).add(getMillis(), amount));"},{"entropy_rank":27,"patch_id":109,"patch_code":"setWeekOfWeekyear(amount);setMillis(type.getField(getChronology()).add(getMillis(), amount));"},{"entropy_rank":28,"patch_id":141,"patch_code":"setMillis(type.getField(getChronology()).add(getMillis(), amount));\n\taddMinutes(amount);setMillis(type.getField(getChronology()).add(getMillis(), amount));"},{"entropy_rank":29,"patch_id":105,"patch_code":"setMillis(type.getField(getChronology()).add(getMillis(), amount));\n\tsetMonthOfYear(amount);setMillis(type.getField(getChronology()).add(getMillis(), amount));"},{"entropy_rank":30,"patch_id":122,"patch_code":"setDayOfWeek(amount);\n\tsetMillis(type.getField(getChronology()).add(getMillis(), amount));setMillis(type.getField(getChronology()).add(getMillis(), amount));"},{"entropy_rank":31,"patch_id":145,"patch_code":"setSecondOfMinute(amount);setMillis(type.getField(getChronology()).add(getMillis(), amount));"},{"entropy_rank":32,"patch_id":128,"patch_code":"setHourOfDay(amount);\n\tsetMillis(type.getField(getChronology()).add(getMillis(), amount));setMillis(type.getField(getChronology()).add(getMillis(), amount));"},{"entropy_rank":33,"patch_id":134,"patch_code":"setMinuteOfDay(amount);\n\tsetMillis(type.getField(getChronology()).add(getMillis(), amount));setMillis(type.getField(getChronology()).add(getMillis(), amount));"},{"entropy_rank":34,"patch_id":94,"patch_code":"addYears(amount);setMillis(type.getField(getChronology()).add(getMillis(), amount));"},{"entropy_rank":35,"patch_id":111,"patch_code":"setMillis(type.getField(getChronology()).add(getMillis(), amount));\n\tsetWeekOfWeekyear(amount);setMillis(type.getField(getChronology()).add(getMillis(), amount));"},{"entropy_rank":36,"patch_id":110,"patch_code":"setWeekOfWeekyear(amount);\n\tsetMillis(type.getField(getChronology()).add(getMillis(), amount));setMillis(type.getField(getChronology()).add(getMillis(), amount));"},{"entropy_rank":37,"patch_id":129,"patch_code":"setMillis(type.getField(getChronology()).add(getMillis(), amount));\n\tsetHourOfDay(amount);setMillis(type.getField(getChronology()).add(getMillis(), amount));"},{"entropy_rank":38,"patch_id":123,"patch_code":"setMillis(type.getField(getChronology()).add(getMillis(), amount));\n\tsetDayOfWeek(amount);setMillis(type.getField(getChronology()).add(getMillis(), amount));"},{"entropy_rank":39,"patch_id":146,"patch_code":"setSecondOfMinute(amount);\n\tsetMillis(type.getField(getChronology()).add(getMillis(), amount));setMillis(type.getField(getChronology()).add(getMillis(), amount));"},{"entropy_rank":40,"patch_id":96,"patch_code":"setMillis(type.getField(getChronology()).add(getMillis(), amount));\n\taddYears(amount);setMillis(type.getField(getChronology()).add(getMillis(), amount));"},{"entropy_rank":41,"patch_id":154,"patch_code":"setMillisOfSecond(amount);setMillis(type.getField(getChronology()).add(getMillis(), amount));"},{"entropy_rank":42,"patch_id":97,"patch_code":"setWeekyear(amount);setMillis(type.getField(getChronology()).add(getMillis(), amount));"},{"entropy_rank":43,"patch_id":124,"patch_code":"addDays(amount);setMillis(type.getField(getChronology()).add(getMillis(), amount));"},{"entropy_rank":44,"patch_id":135,"patch_code":"setMillis(type.getField(getChronology()).add(getMillis(), amount));\n\tsetMinuteOfDay(amount);setMillis(type.getField(getChronology()).add(getMillis(), amount));"},{"entropy_rank":45,"patch_id":136,"patch_code":"setMinuteOfHour(amount);setMillis(type.getField(getChronology()).add(getMillis(), amount));"},{"entropy_rank":46,"patch_id":107,"patch_code":"addMonths(amount);\n\tsetMillis(type.getField(getChronology()).add(getMillis(), amount));setMillis(type.getField(getChronology()).add(getMillis(), amount));"},{"entropy_rank":47,"patch_id":112,"patch_code":"addWeeks(amount);setMillis(type.getField(getChronology()).add(getMillis(), amount));"},{"entropy_rank":48,"patch_id":91,"patch_code":"setYear(amount);setMillis(type.getField(getChronology()).add(getMillis(), amount));"},{"entropy_rank":49,"patch_id":118,"patch_code":"setDayOfMonth(amount);setMillis(type.getField(getChronology()).add(getMillis(), amount));"},{"entropy_rank":50,"patch_id":142,"patch_code":"setSecondOfDay(amount);setMillis(type.getField(getChronology()).add(getMillis(), amount));"},{"entropy_rank":51,"patch_id":130,"patch_code":"addHours(amount);setMillis(type.getField(getChronology()).add(getMillis(), amount));"},{"entropy_rank":52,"patch_id":125,"patch_code":"addDays(amount);\n\tsetMillis(type.getField(getChronology()).add(getMillis(), amount));setMillis(type.getField(getChronology()).add(getMillis(), amount));"},{"entropy_rank":53,"patch_id":137,"patch_code":"setMinuteOfHour(amount);\n\tsetMillis(type.getField(getChronology()).add(getMillis(), amount));setMillis(type.getField(getChronology()).add(getMillis(), amount));"},{"entropy_rank":54,"patch_id":147,"patch_code":"setMillis(type.getField(getChronology()).add(getMillis(), amount));\n\tsetSecondOfMinute(amount);setMillis(type.getField(getChronology()).add(getMillis(), amount));"}],"Time_7":[{"entropy_rank":1,"patch_id":22,"patch_code":"int defaultYear = getChronology().year().get(instantLocal);int defaultYear = chrono.year().get(instantLocal);"},{"entropy_rank":2,"patch_id":14,"patch_code":"int defaultYear = chrono.year().get(instantMillis);int defaultYear = chrono.year().get(instantLocal);"},{"entropy_rank":3,"patch_id":42,"patch_code":"int defaultYear = chrono.year().get(getDefaultYear());int defaultYear = chrono.year().get(instantLocal);"},{"entropy_rank":4,"patch_id":13,"patch_code":"int defaultYear = this.iChrono.year().get(instantLocal);int defaultYear = chrono.year().get(instantLocal);"},{"entropy_rank":5,"patch_id":41,"patch_code":"int defaultYear = chrono.year().get(getPivotYear());int defaultYear = chrono.year().get(instantLocal);"},{"entropy_rank":6,"patch_id":23,"patch_code":"int defaultYear = getChronolgy().year().get(instantLocal);int defaultYear = chrono.year().get(instantLocal);"}]}